[{"id":"9e7562adc34393738695af14263310c0","title":"Lattice-NTRU-2","content":"多项式卷积乘法多项式的卷积乘法可以看成一个矩阵操作。假设和在上相乘，表述为：\n\n那么就有（参考多项式乘法，用分配律也行）：\n\n由于的结果肯定也是个多项式（封闭性），所以先把上面结构调整到像一个多项式，即合并次数相同的项（注意和最高项只能是 ，所以不考虑模的时候乘起来最高项只能是，然后小于次的项和大于等于次的项分开处理）：\n\n最开始讲环的时候说到，是模的，所以，所以有：\n\n所以说未知数的指数部分需要模，可以继续化简：\n\n其中的即为的次项系数。 \n\n\n\n\n\n\n\n\n\n设则: \n\n检验通过\n以下用矩阵的形式表达，且记的第次项系数为，有：\n\n","slug":"多项式卷积乘法","date":"2023-09-25T00:54:38.000Z","categories_index":"Crypto","tags_index":"Lattice,Crypto","author_index":"C4IN"},{"id":"d702884c0497c30710829cd42dd95573","title":"Lattice-NTRU-1","content":"NTRU是一个带有专利保护的开源公开密钥加密系统，使用基于格的加密算法来加密数据。它包括两部分算法：NTRUEncrypt用来加密，NTRUSign用来进行数字签名。与其他流行的公钥加密系统不同，它可以防止被Shor算法破解，并显著提升了性能。\n多项式除法我们首先了解一下多项式除法。多项式除法是代数中的一种算法，用一个同次或低次的多项式去除另一个多项式。它可以很容易地手算，因为它将一个相对复杂的除法问题分解成更小的一些问题。多项式除法和我们小学学到的带余除法是有些相似的（算数的长除法）。\n下面有个例子：\n计算\n\n横线上多项式即为商，而剩下的（-123）就是余数。\n\n多项式除法-wiki\nNTRU我们先看三个卷积多项式环（Convolution Polynomial Rings）。\n\n其中是整数域上的多项式，比如这类的多项式，长横线是商环（Quotient Ring），分子上的多项式模上分母的就会落在，其中是NTRU的参数。\n\n\n\n\n\n\n\n\n\n比如说我们取，即，我们试着把换到上，模数是，有\n\n就是最后落在上的结果，即是上面说的多项式除法的余数。\n\n标记一下Sage这个东西\n\n类似，但是系数模的多项式，也就是多项式的系数需要模，使其落在中。说白了就是的另一种写法。\n\n\n\n\n\n\n\n\n\n同样的来看一个例子，设，把转换到中：\n\n上述是NTRU的公开参数，要求为素数，且\n\n\n\n\n\n\n\n\n\n\n更详细的参数设置建议（[HPS17]）：\n一般取，为了加快运算一般取2的幂次方，通用取素数。\n三元多项式和密钥生成输入为两个整数，输出一个三元多项式，三元即，函数会采样有个项系数为1，个项系数为-1，其余项系数为0（即没有）且落在上的多项式。\n然后利用采样密钥：\n\n私钥：\n可信方选择满足上述条件的公共参数，私钥由两个随机选择的多项式组成\n\n取的原因是不可逆。计算逆元\n\n是两个落在上的主要的私钥，把和事先存储起来可以加快运算速度，因为计算多项式环的逆元需要一段时间。\n\n公钥：\n\n或者\n\n\n\nCenter-Lift和加解密Center-lift是把和中的多项式转换回中，使得多项式系数的绝对值最小。Center-lift的定义可以看[HSP14]的7.9节，主要是针对多项式系数的操作，可以和补码类比。\n上面假设是多项式的Center-lift，即转换到。 上图的为上的一个多项式，为其Center-lift到后的结果， 为的次项系数，为的次项系数，结果是所有的系数会落在区间 ，而且还能保证。\nCenter-lift的方法也不难，和转补码相似\n\n然后看看加密：\n明文空间是做Center-Lift后的空间，加密使用的随机数在中采样，加密公式是：\n\n如果要解密的话，只需要将去除即可，由于，所以直观上把放入中就可以把去除，而明文空间是做Center-Lift的空间，所以把放入并不会改变的结构，即可以恢复明文。但实际上我们没办法保证，除非，但由于，所以这种情况并不存在，不能直接转换到上。\n前面说过可以转换到上，所以可以考虑把转换（Center-Lift）到上，然后再转到上。但同时也会有新的问题，直接把上的转换到上的结果不一定是原来的上的，比如说，除了把放在上运算后的系数就落在上，也即上的元素做Center-lift后的区间。\n参考：\n[HPS14]Hoffstein J, Pipher J, Silverman J H, et al. An introduction to mathematical cryptographyM]. New York: springer, 2008.\n[HPS17] [Hoffstein J, Pipher J, Schanck J M, et al. Choosing parameters for NTRUEncrypt[C]//Topics in Cryptology–CT-RSA 2017: The Cryptographers’ Track at the RSA Conference 2017, San Francisco, CA, USA, February 14–17, 2017, Proceedings. Springer International Publishing, 2017: 3-18.\nhttps://0xffff.one/d/1424-ntru-xue-xi-bi-ji\n","slug":"Lattcies-NRTU","date":"2023-09-19T13:46:45.000Z","categories_index":"Crypto","tags_index":"Lattice","author_index":"C4IN"},{"id":"f321673e1ae041d21d7612aab6d63663","title":"lattice-crypto-1","content":"线性独立空间上有集合，格 (Lattices) 就是这些向量的线性组合，用公式表示为: \n\n而其中任意一组可以生成格的线性无关的向量都称为格的基，格的维数等于格中向量的个数。某种意义上格可以理解为系数均为整数的向量空间。\n\n格的困难问题最短向量问题（SVP，The Shortest Vector Problem）寻找一个格中最短的非零向量。即，寻找一个满足其欧几里德范数最小。\n最接近向量问题（CVP，The Closest Vector Problem）对于一个非格中的向量，在格中寻找一个向量，使得  最小。 \n由于CVP和SVP都是NP完备问题，因此求解起来十分困难，因此这两个问题都是可以作为密钥体制的基础的。\ntoy model它是 lattice 可用于传统公钥密码分析的例证，另外也是 NTRU 公钥密码体系的一个低端版本。\n首先Alice选择一个大整数作为公共参数，然后选择两个比较小的整数满足\n\n亦即的长度大约小于 的一半；的长度大约在的一半到的一半之间。从而远远小于, 为。另外要求与都互质。接下来, Alice 计算\n\n注意到尽管很小, 其逆元仍然会很大, 于是是的级别。Alice 的公钥是 , 私钥是 。\n假设Bob有一个小于的明文，然后他随机选择整数，计算\n\n将作为密文发送给Alice，Alice解密：\n先计算\n，\n然后计算\n，\n特别注意这里的模数是。\n带入，得到\n\n\n于是我们断言。\n\n\n\n\n\n\n\n\n\n原因：\n首先我们有,\n注意到，所以，即就是的真实值。\n将模，分离出，然后乘以得到，我们可以知道，于是就是真实值。\n我们可以发现，假如一个敌手想攻破该密码体系，只需要伪造一组，使其解密时与相同即可。也就是说需要满足：\n\n然后按照上述步骤进行，就可以获得。也就是说只需要找到合法的，就可以攻破这个密码体系。\n将改写成，那么就可以转化为找到足够小的使得\n\n这个式子等价于这两个向量以为系数进行线性组合，如果我们能找到合适的，使得线性组合得到的向量足够短，那我们就攻破了该密码体系。\n上面的问题总结起来就是：有两个已知的向量，需要找出一套线性组合系数（必须是整数），来生成一个足够短的向量。\n对于敌手，已知长度均为向量，需要寻找长度为的线性组合来攻破密码体系。从格的角度来说，即在lattcie 寻找一个很短的向量：\n\n在二维的 lattice 里面找最短向量，是有高效算法的（Gauss 的工作）。于是攻破了这个密码体系。\n推荐https://www.ruanx.net/lattice-1/\nhttps://lazzzaro.github.io/2020/11/07/crypto-%E6%A0%BC%E5%AF%86%E7%A0%81/index.html\n","slug":"lattice-1","date":"2023-09-19T10:44:02.000Z","categories_index":"","tags_index":"Crypto,lattice","author_index":"C4IN"},{"id":"030d8a1cfb3d1c00a80edaa1d841a1b0","title":"MASCOT前置知识（二）","content":"SPDZ框架摘要SPDZ是一种MPC计算的协议框架，基于同态加密、秘密共享等技术实现安全多方计算，相关内容引自参考文献[1].\n\nSPDZ主要包括两个阶段，离线阶段（预计算）主要基于同态加密生成在现阶段需要的参数，在线阶段主要基于秘密共享完成各种计算。\nSPDZ可以计算有限域中的任何计算。\nSPDZ 满足 UC 安全框架下的静态恶意敌手(static adaptive adversay)攻击模型，即 n 个参与方中，即使最多 n-1 个参与方恶意违反协议或者合谋。\nSPDZ使用Message Authentication Code (MAC)，检测参与方是否诚实地进行计算，MAC参数在离线阶段生成。\nSPDZ不检测哪个参与方为恶意参与方，在检测到协议被违反情况即停止协议运行而防止数据泄漏。\n\n安全模型安全多方计算安全模型一般采用Universally composable（UC）模型[2]，按照攻击者能力可以划分为半诚实、恶意参与者，按照恶意参与者的门限可以划分为多数诚实、多数恶意协议。\n按照攻击者能力：\n\n半诚实模型：各参与方在计算过程中完全遵从 MPC 协议，既不会违反协议篡改数据也不会多个参与方之间进行合谋。\n恶意模型：攻击者允许随意篡改协议，可以联合他人进行合谋攻击。\n\n按照攻击者门限：\n\n多数诚实：恶意参与者不超过总参与方一半。\n多数恶意：恶意参与者至多可以有个（总参与方为）。\n\nSPDZ协议满足Universally composable（UC）框架下的静态恶意敌手(static adaptive adversary)攻击模型，最多允许个恶意参与方。\n基本定义秘密分享共有两种表示方法和，第一种主要用于表示输入的秘密分享值，第二种则主要用于表示全局密钥和随机数等参数。\n$表示\">表示有限域中的值的秘密分享值表示方法为：\n\n\\langle a \\rangle := (\\delta,(a_1,\\cdots,a_n),(\\gamma(a)_1,\\cdots,(a)_n))其中，\n各参与方持有，是公开值，为全局MAC密钥。\n秘密分享值计算具有以下性质：\n\n\n\n\n\n\n\n\n\n\n\n\n其中\n表示的秘密分享值表示方法为：\n各参与方持有\n\n(\\alpha_i,\\beta_i,\\gamma(\\alpha)_1^i,\\cdots,\\gamma(\\alpha)_n^i)其中为各参与方的密钥，主要验证MAC密钥和随机数秘密分享值的MAC验证。\nMAC密钥MAC密钥全局MAC密钥秘密分享值表示方法为，由于每个参与方持有\n\n(\\alpha_i,\\beta_i,\\gamma(\\alpha)_1^i,\\cdots,\\gamma(\\alpha)_n^i)因此各参与方可通过验证MAC密钥。为了打开，参与方将发送给，校验是否成立。\n三元组及乘法运算加法计算相对直接，直接利用秘密分享值的性质，计算加法，即可得到结果：\n乘法计算需要借助三元组（Beaver Triple[3]），三元组在离线阶段生成，表示为，且满足。\n由于在实际生成三元组过程中可能会引入误差，因此需要额外“消耗”(sacrificing)一组三元组用于校验三元组。\n给定一三元组，设输入为则乘法可按一下方式计算：\n\n打开得到，\n打开得到，\n然后计算\n\n正确性验证：\n\n\\begin{align}\n\\lang x \\rang \\cdot \\lang y \\rang &= \\lang c \\rang +\\epsilon\\lang b \\rang + \\delta \\lang a \\rang +\\epsilon\\delta \\\\\n&=\\lang ab \\rang + (\\lang x \\rang - \\lang a \\rang)\\lang b \\rang+(\\lang y \\rang - \\lang b \\rang )\\lang a \\rang + (\\lang x \\rang - \\lang a \\rang )(\\lang y \\rang - \\lang b \\rang)\\\\\n&=\\lang ab \\rang + \\lang bx\\rang-\\lang ab \\rang +\\lang ay \\rang -\\lang ab \\rang+\\lang xy \\rang-\\lang ay \\rang - \\lang bx \\rang +\\lang ab \\rang\\\\\n&=\\lang xy \\rang\n\\end{align}SPDZ协议SPDZ协议主要包括离线阶段和在线阶段。\n\n离线阶段\n离线阶段需要用到同态加密技术，产生的辅助数据包括：\n\n多元乘法三元组的秘密分享值；\n随机数秘密分享值；\n全局MAC密钥。\n\n这些辅助信息和在线计算阶段的输入数据无关，因此可以提前进行计算。\n以全局MAC密钥​为例，介绍离线阶段生成参数过程：\n\n各参与方联合生成同态加密公钥和私钥，以 BGV 方案[4]为例，私钥和公钥具有线性特性，因此解密过程中各方可利用进行部分解密，然后把解密结果汇总得到最终明文结果，解密过程中不泄漏各自部分的私钥； \n各参与方生成随机数，然后利用进行同态加密得到密文(表示$$\\alpha_i的同态密文)，并将密文发送给其他参与方; \n各参与方汇总得到，利用私钥进行联合解密，联合解密过程中会加入一个随机数进行混淆，然后reShare得到。\n\n\n在线阶段\n\n初始化。准备全局MAC密钥，随机数秘密分享值，乘法三元组等参数。\n输入阶段。设参与方的输入为，向打开，然后广播，各参与方计算。输入阶段主要是将输入值分片，产生对应的秘密分享值。\n加法计算。设输入为，计算。 \n乘法计算。设输入为，则计算分为两步：\n使用三元组校验；\n计算。 \n\n\n输出阶段。再输出最终结果前，需要对中间值、结果进行MAC校验，SPDZ 协议 MAC 验证时为了提高效率，可以在打开多个秘密分享值后通过一次MAC批量校验。\n\n\n\n协议离线阶段离线阶段主要借助同态加密、、、协议实现，其中同态加密主要保证秘密共享的同态加法、乘法性质，协议主要将秘密值进行分割，进行加法秘密共享，协议主要生成形式的秘密共享值，协议主要生成形式的秘密共享值。\n同态加密同态加密方案未提出具体方案，可参考BGV[1]等同态加密方案（在后续SPDZ改进论文中，使用了一层的BGV方案）。\n协议协议主要输入同态加密密文（明文为），以及一个参数，若，则输出为（由参与方持有)，且有；若，则输出一个新的密文，新的密文仍然包含。\n1.各参与方随机选择，记。\n2.各参与方计算，并将结果发送给其他参与方。\n3.各参与方生成的零知识证明，并发送给其他参与方进行验证（零知识证明为一种密码协议，可以在不泄漏秘密值的情况下证明秘密值的正确性）。\n4.所有参与方计算， 。（PS+不一定是简单相加）\n5.所有参与方运行分布式解密算法，解密，得到。\n6.参与方计算，其他参与方计算。\n7.若，则所有参与方计算。\nP Bracket协议P Bracket协议输入为各参与方的秘密份额，以及一个公共的秘密份额（密文中包含），输出形式的秘密分享值。\n1.对于， 所有参与方计算；各参与方计算，因此各参与方得到了的秘密值份额。\n2.输出。\nP Angle协议P Angle协议输入为各参与方的秘密份额，以及一个公共的秘密份额（密文中包含），输出形式的秘密分享值。\n1.所有参与方计算；\n2.各参与方计算，因此各参与方得到了的秘密值份额。\n3.输出。\n离线阶段完整协议初始化\n所有参与方运行分布式密钥生成算法，得到公钥；\n各参与方生成； \n各参与方生成，记，为全局MAC密钥；\n各参与方计算并广播密文,，其中；\n各参与方使用零知识证明协议验证为正确；\n所有参与方计算，生成秘密分享值。\n\n生成随机秘密共享值\n各参与方生成，记；\n各参与方计算并广播密文，记； \n各参与方使用零知识证明验证密文的正确性；\n所有参与方计算。\n\n生成乘法三元组\n各参与方生成记，；\n各参与方计算并广播密文；\n各参与方使用零知识证明协议验证密文的正确性； \n所有参与方计算；\n所有参与方计算； \n所有参与方计算； \n所有参与方计算；\n所有参与方计算。\n\n在线阶段完整协议在现阶段主要完成计算以及中间值和结果的MAC校验等，基础计算主要包括加法、乘法等。\n在线阶段主要过程如下：\n\n初始化。准备全局MAC密钥，随机数秘密分享值、，乘法三元组等参数。\n输入阶段。设参与方的输入为，向打开，然后广播，各参与方计算。输入阶段主要是将输入值分片，产生对应的秘密分享值。\n加法计算。设输入为，计算。\n乘法计算。设输入为，则计算分为两步：\n使用三元组校验；\n计算。\n\n\n输出阶段。再输出最终结果前，需要对中间值、结果进行MAC校验，SPDZ 协议 MAC 验证时为了提高效率，可以在打开多个秘密分享值后通过一次MAC批量校验。\n\n\n设在此次验证 MAC 前已有个秘密分享值被打开，即有个MAC 未验证，记为，其中对应的秘密分享值为，需要先打开一个随机值，然后各参与方计算，最后各参与方计算；\n各参与方使用对和输出值进行“承诺”，“承诺”函数包括承诺阶段和打开阶段，承诺阶段对秘密值进行“混淆”，生成承诺值，并发送给验证方；打开阶段，发送方将秘密值发送给验证方，验证方使用秘密值（通常也会加入随机数）验证承诺值。“承诺”函数可由Paillier加密、离散对数、哈希等方法构造。\n打开全局MAC密钥。\n各参与方通过承诺函数，打开，然后所有参与方验证，若公式成立，则验证通过，即输出结果正确，否则，终止协议。\n打开最终结果前，需要对的承诺值进行验证。验证通过后，计算，然后验证，验证通过，则即为最终正确结果。\n\n参考文献[1] I Damgård, Pastro V , Smart N , et al. Multiparty Computation from Somewhat Homomorphic Encryption[C]// Springer-Verlag New York, Inc. Springer-Verlag New York, Inc. 2012.\n[2] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable two-party and multi-party secure computation. In STOC, pages 494–503, 2002.\n[3] Beaver. Efficient multiparty protocols using circuit randomization. In J. Feigenbaum, editor, CRYPTO, volume 576 of Lecture Notes in Computer Science, pages 420–432. Springer, 1991.\n[4] Z. Brakerski, C. Gentry, and V. Vaikuntanathan. (leveled) fully homomorphic encryption without bootstrapping. In ITCS, pages 309–325. ACM, 2012.\nhttps://mp.weixin.qq.com/s/uwUnRc6j_ZpMxd6Dfnv3-w\n​       https://mp.weixin.qq.com/s/mR847vF1Djb-aINJTaFKAA\n","slug":"MASCOT前置知识（二）","date":"2023-09-19T08:29:14.000Z","categories_index":"Crypto,多方安全计算,MASCOT","tags_index":"Crypto,Basic","author_index":"C4IN"},{"id":"e7f9c8c700d84e1b335913cf1672fdbf","title":"aurora主题的latex配置","content":"如何给aurora主题配置latex公式支持最近换了个主题，然后latex公式怎么搞都搞不好。找了好久终于找到了解决方法。\n进入博客根目录，下载hexo-renderer-kramed、hexo-math、hexo-filter-mathjax\nnpm install hexo-math --save\n## 卸载默认 markdown 渲染引擎 hexo-renderer-marked；若不卸载，会和新的引擎发生冲突（conflict）\n$ npm uninstall hexo-renderer-marked --save\n## 安装新引擎 hexo-renderer-kramed \n$ npm install hexo-renderer-kramed --save\n\n$ npm install hexo-filter-mathjax\n$ hexo clean\n然后修改kramed配置，解决冲突：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,\n\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n只要改这俩就行啦。\n然后在根目录下的_config.yml开启渲染：\n# MathJax Support\nmathjax:\n  tags: none # or 'ams' or 'all'\n  single_dollars: true # enable single dollar signs as in-line math delimiters\n  cjk_width: 0.9 # relative CJK char width\n  normal_width: 0.6 # relative normal (monospace) width\n  append_css: true # add CSS to pages rendered by MathJax\n  every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter\n  packages: # extra packages to load\n  extension_options: {}\n    # you can put your extension options here\n    # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail\n # MathJax\nmath:\n  engine: 'mathjax'\n  mathjax:\n    src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML\n在你的文章markdown文件中加入：\nmathjax: true\n\n然后试试：\n// inline \n$p=P\\left(A_{1}\\right)+P\\left(A_{2}\\right)+\\ldots+P\\left(A_{n}\\right)=p_{1}+p_{2}+\\ldots+p_{n}$\n\n// block\n$\n\\begin{aligned}\np &amp; =P\\left(A_{1} \\cup A_{2} \\cup \\cdots \\cup A_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1} \\bar{A}_{2} \\cdots \\bar{A}_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1}\\right) P\\left(\\bar{A}_{2}\\right) \\cdots P\\left(\\bar{A}_{n}\\right)\n\\end{aligned}\n$\n结果：\n行内公式 inline equation\n公式块\n\n参考链接：\nhttps://cps.ninja/2019/03/16/hexo-with-latex/\nhttps://github.com/auroral-ui/hexo-theme-aurora/issues/55\nhttps://github.com/next-theme/hexo-filter-mathjax\n","slug":"aurora主题的latex配置","date":"2023-09-17T12:02:13.000Z","categories_index":"","tags_index":"头疼的配置问题","author_index":"C4IN"},{"id":"67a2e1ac4586a101302bb0a481c51db5","title":"MASCOT前置知识（一）","content":"这几天开始看MASCOT，先学学里面提到的一些基础知识。\n\n通用哈希函数(Universal Hash Function)通用哈希函数是指从具有一定数学特性的散列函数族中随机选择一个散列函数（见下文定义）。这样，即使数据是由对手选择的，也能保证较低的预期碰撞次数。\n假设我们想把某一个全集映射到m个“区”中（记为 ）。通常哈希是都需要减少发生哈希碰撞的几率（碰撞集合数据 ），一个确定性哈希函数往往不能保证在敌手模型（ ）下不被敌手精确选择作为哈希映射的前象。为了解决这个问题，我们随机选取哈希函数族中的一个函数称为通用哈希族（Universal family），且\nhttps://en.wikipedia.org/wiki/Universal_hashing\n剩余哈希引理(Leftover Hash Lemma)如果敌手获得了n比特密钥中的t个比特，我们可以生成一个比特左右的密钥，保证敌手对该密钥相关的信息一无所知。\n准确来说，我们可以提取一个长度渐进于（的最小熵）的均匀随机分布的变量。换句话说，敌手对X有一定的了解，但是对提取得到的值几乎一无所知。我们又称它为隐私放大，这是MASCOT的核心之一。\n令是在上的一个随机变量，且。令为一个2-universal哈希函数，如果则对于在上的且与无关，我们能得到：其中且与无关。\n是的最小熵，用来衡量的随机性，最小熵需要永远小于等于香农熵。注意是正确猜测的可能性。因此，最小熵衡量猜测的难度。\n是与的统计距离。\n\n\n\n\n\n\n\n\n\n香农熵：由热力学的熵引入到信息论中。\n香农把随机变量X的熵值定义如下，其值域为在这里b是对数所使用的底)，通常是2,自然常数e)，或是10。当b = 2，熵的单位是bit；当b = e，熵的单位是nat)；而当b = 10,熵的单位是Hart。\n熵（信息论）-wiki)\n","slug":"MASCOT前置知识","date":"2023-09-16T05:30:58.000Z","categories_index":"Crypto,多方安全计算,MASCOT","tags_index":"Crypto,Basic","author_index":"C4IN"},{"id":"02610888fe553149eda2045d277295dd","title":"多方安全计算介绍","content":"多方安全计算安全多方计算(MPC)已经从20世纪80年代的一种理论发展成为今天构建真实系统的工具。在过去的十年中，MPC已经成为理论和应用密码学中最活跃的研究领域之一。\n安全多方计算(MPC)的目标是使一组互不信任的独立数据所有者或任何公共第三方能够联合计算依赖于他们所有私人输入的函数。MPC与外包计算的不同之处在于，所有协议参与者都是参与执行协议的数据所有者。\n\nMPC支持保护隐私的应用程序，其中多个互不信任的数据所有者合作计算一个函数。在分布式的多方安全计算（Secure Multi-Party Computation , SMPC）环境中,含有隐私输入的两方或者多方参与者希望协作和交互式地计算一个目标函数f\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right)=\\left(y_{1}, y_{2}, \\ldots, y_{n}\\right)，一旦计算完成，每一个参与者应该能够获取与之相对应的且不包含其他信息的输出。多方安全计算目的是构建一个安全协议，这个安全协议能允许多个互不信任的参与者在自己隐私输入上联合计算目标函数，同时确保输出的准确，甚至在面对不诚实行为时，能够保护和管控自己的隐私输入。\n\n\n\n\n\n\n\n\n\n\n\n姚氏百万富翁问题\n姚(1982)简单地介绍道:“两个百万富翁想知道谁更富有；然而，他们不希望无意中发现任何关于彼此财富的额外信息。”也就是说，目标是计算的布尔结果，其中是第一方的私有输入，是第二方的私有输入。\n\n拍卖安全问题\n在一次拍卖中，学习到的唯一出价信息是出价最高者的出价，显然可以得出所有其他出价都低于中标价，但无法得到其它竞标失败的出价。\n\n\n研究领域理论研究包括安全模型、可行性和复杂性等方面的研究。理论研究的目的是将来自理论研究的优雅的理论想法转化成解决现实世界安全问题的具体的SMPC协议。实用的多方安全协议注重于效率问题。SMPC理论协议涉及的研究和方法主要从计算成本、通信成本和交互轮数方面提高通用和特定协议的效率。\n面向应用的SMPC包括隐私集合计算、隐私保护机器学习、数据挖掘和安全基因组计算等领域的研究。\n所有这些协议都涉及到基本的构造块，如不经意传输、秘密共享、投币、同态加密、承诺方案、零知识证明等。这些构造块为理论和实用的SMPC奠定了基础。\nMPC的可行性在存在恶意的情况下依然可以安全地计算任何分布式计算任务。现在我们简要说明这些结果中最重要的部分，假设表示参与方的数量，表示可能被腐坏的计算方的数量的界限 (其中被腐坏方的身份未知)：\n\n对于 (即，当不到三分之一的参与方可能被腐坏时)，任何具有计算安全性的函数都可以实现具有公平性和有保证的输出的安全多方协议，假设一个具有认证信道的同步点到点网络，在信息论安全的前提下，假设信道也是私有的。\n对于 (即，在保证诚实多数的情况下)，对于任何具有计算和信息论安全性的函数，都可以实现具有公平性和保证输出的安全多方协议，假设各方也可以访问广播信道。\n对于(即当腐坏方的数量不受限制时)，可以实现安全的多方协议 (没有公平性或保证输出)。\n\n","slug":"多方安全计算基础","date":"2023-08-20T02:47:19.000Z","categories_index":"Crypto,多方安全计算","tags_index":"Crypto,MPC","author_index":"C4IN"},{"id":"2cbb891df5dd9e9d79cc9907faec0ead","title":"安洁莉卡&罗兰","content":"\n安洁莉卡最喜欢的诗\n\n痛苦啊，你便是我的唯一除了你，我皆无欲求痛苦啊，你忠实的陪伴我，直至现在也没有一丝改变当我的灵魂徘徊于深渊之底唯有你相伴在我身旁，守护着我我又怎能埋怨你呢痛苦啊，你绝不会从我身旁遁走我终于能表达对你的尊敬现在也认识到你的存在而你只是存于世，便那么美丽痛苦啊，你就像那从未离开我那贫苦的心之火炉旁的人一样比我那身为至爱的恋人还要多情我知道在我迈向死亡的那一天你会走进我内心的深处与我并排躺下\n\n小时候的罗兰，只有奶奶相伴。在奶奶的指导下，成为了都市里的一名收尾人。在千疮百孔的都市中，凭着“奇点”技术，人们克服了疾病，征服了大自然，却逐渐患上了心病，不再追求曾经炫目的梦想，任由自己的思想为”翼“所指导。在”翼“的庇佑下，巢中的羽过着安全、稳定的生活，而在巢之外的后巷，人们只为了活下去而活下去，人的生命根本不值一提，人们渴望着有朝一日能进入”翼“，能从眼前的地狱中解放。都市脆弱的秩序由收尾人来维持。这些收尾人或许受雇于巢，或许受雇于后巷势力，接手各种各样的工作，从送货到杀人，再到处理大型事件。在都市中，收尾人的工作机遇与危险并存，最忌讳的就是在收尾时产生情感。罗兰在查尔斯事务所中遇到了安洁莉卡。他来自后巷，而她来自翼的实验室。在一次次的生死中，两人相爱，并结了婚。罗兰兢兢业业干了那么多年，好不容易有了爱他的人，他们一定会很幸福不是……吗？\n\n\n\n\n\n\n\n\n\n“闯进我世界之人，最后成了我的全世界”\n“一码，归一码”\n早些年罗兰参加了烟霾战争，翼曾向他承诺，会优先安排巢的易居权。但，这是都市。翼玩了一次文字游戏，罗兰移居巢的梦想彻底破灭，只得住在相对安全的音之巷内。妻子怀孕了有了孩子，罗兰更加自责，害怕自己的妻子和孩子的安全会受到威胁。虽然没有住在巢中，安洁莉卡没有说什么，安洁莉卡非常爱罗兰，她看的透罗兰，她知道一旦出事罗兰便会怪自己。\n\n\n\n\n\n\n\n\n\n“说起来，那里的葱饼味道还不错？，回来的时候麻烦捎一个吧”“非常乐意为您效劳，在下去去就回”\n罗兰的老友奥利维耶打来通讯，说一个委托急缺人手，他便去帮忙了。等他带着妻子爱吃的葱饼回到家中时——只有坍塌的房子。一切都没了，他的妻子，与他的孩子，就这么没了。\n罗兰彻底崩溃了。\n\n\n\n\n\n\n\n\n\n“为什么，我那来之不易的幸福却能如此轻易地从我手中溜走……”\n“全都是我的错……”\n罗兰的世界破碎了。他开始调查实验室，屠杀了手指，向都市发起他最恶毒的诅咒。\n\n\n\n\n\n\n\n\n\n“越是沿往昔之路，尸山越发高耸。层峦叠嶂，不见前路”\n“不见前路。我仅是回首遥望。”\n墙对面传来的欢笑声，其中或许有属于我的风景，我遗落的风景。成团的漆黑独守空房。\n罗兰的故事，总给我一种触动。\n","slug":"Ruina","date":"2023-07-28T13:40:40.000Z","categories_index":"这都是些什么啊,Library of Ruina","tags_index":"闲","author_index":"C4IN"}]