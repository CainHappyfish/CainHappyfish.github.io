[{"id":"ec97abd0452c3383ae6efc5f2ebc40f7","title":"buuoj-reverse WP-1","content":"Buuoj-Reverse WP-1来学学逆向工程，顺便学学计组\nreverse1在strings窗口发现flag，但直接输入发现flag错误。\n\n进行反汇编，发现\n\n该for循环将所有的o替换成0，所以最后的flag是flag&#123;hell0_w0rld&#125;。\nreverse2打开strings窗口，发现flag的一部分\n\n类似reverse1，该题将 flag 中的 i 和 r 都替换成 1。\n\n内涵的软件打开strings窗口即可发现flag。\n\n新年快乐\nexe 被 upx 压缩，使用命令 upx.exe -d xnkl.exe -o xnkl_unpack.exe 解压。\nXOR反汇编，发现flag应该和global有关\n\n找到对应的数据\n\n查看反汇编的代码，发现对flag进行了异或操作，编写脚本：\n&quot;&quot;&quot;\n__global\n__cstring:0000000100000F6E aFKWOXZUPFVMDGH db &#39;f&#39;,0Ah              ; DATA XREF: __data:_global↓o\n__cstring:0000000100000F6E                 db &#39;k&#39;,0Ch,&#39;w&amp;O.@&#39;,11h,&#39;x&#39;,0Dh,&#39;Z;U&#39;,11h,&#39;p&#39;,19h,&#39;F&#39;,1Fh,&#39;v&quot;M#D&#39;,0Eh,&#39;g&#39;\n__cstring:0000000100000F6E                 db 6,&#39;h&#39;,0Fh,&#39;G2O&#39;,0\n&quot;&quot;&quot;\n\nstr_xor = [&#39;f&#39;, 0x0A, &#39;k&#39;, 0x0C, &#39;w&#39;, &#39;&amp;&#39;, &#39;O&#39;, &#39;.&#39;, &#39;@&#39;, 0x11, &#39;x&#39;, 0x0D, &#39;Z&#39;, &#39;;&#39;, &#39;U&#39;, 0x11, &#39;p&#39;, 0x19, &#39;F&#39;, 0x1F,\n           &#39;v&#39;, &#39;&quot;&#39;, &#39;M&#39;, &#39;#&#39;, &#39;D&#39;, 0x0E, &#39;g&#39;, 6, &#39;h&#39;, 0x0F, &#39;G&#39;, &#39;2&#39;, &#39;O&#39;, 0]\n\nprint(len(str_xor))\n\nfor i in range(0, len(str_xor)):\n    if isinstance(str_xor[i], int):\n        str_xor[i] = chr(str_xor[i])\n\nfor i in range(0, len(str_xor) - 1):\n    print(str_xor[i], end=&quot; &quot;)\n\nprocess = &#39;&#39;.join(str_xor)\n\nprint(process)\n\nflag = &#39;&#39;\nfor i in range(0, len(str_xor)-1):\n    flag += chr(ord(str_xor[i]) ^ ord(str_xor[i - 1]))\n\nprint(flag)\n\nreverse3首先先找到flag\n\n进行反编译：\n\n发现重要函数sub_4110BE，而该函数返回的是sub_411AB0：\nvoid *__cdecl sub_411AB0(char *a1, unsigned int a2, int *a3)\n&#123;\n  int v4; // [esp+D4h] [ebp-38h]\n  int v5; // [esp+D4h] [ebp-38h]\n  int v6; // [esp+D4h] [ebp-38h]\n  int v7; // [esp+D4h] [ebp-38h]\n  int i; // [esp+E0h] [ebp-2Ch]\n  unsigned int v9; // [esp+ECh] [ebp-20h]\n  int v10; // [esp+ECh] [ebp-20h]\n  int v11; // [esp+ECh] [ebp-20h]\n  void *v12; // [esp+F8h] [ebp-14h]\n  char *v13; // [esp+104h] [ebp-8h]\n\n  if ( !a1 || !a2 )\n    return 0;\n  v9 = a2 / 3;\n  if ( (int)(a2 / 3) % 3 )\n    ++v9;\n  v10 = 4 * v9;\n  *a3 = v10;\n  v12 = malloc(v10 + 1);\n  if ( !v12 )\n    return 0;\n  j_memset(v12, 0, v10 + 1);\n  v13 = a1;\n  v11 = a2;\n  v4 = 0;\n  while ( v11 &gt; 0 )\n  &#123;\n    byte_41A144[2] = 0;\n    byte_41A144[1] = 0;\n    byte_41A144[0] = 0;\n    for ( i = 0; i &lt; 3 &amp;&amp; v11 &gt;= 1; ++i )\n    &#123;\n      byte_41A144[i] = *v13;\n      --v11;\n      ++v13;\n    &#125;\n    if ( !i )\n      break;\n    switch ( i )\n    &#123;\n      case 1:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v5 = v4 + 1;\n        *((_BYTE *)v12 + v5) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];\n        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];\n        v4 = v5 + 1;\n        break;\n      case 2:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v6 = v4 + 1;\n        *((_BYTE *)v12 + v6) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | (4 * (byte_41A144[1] &amp; 0xF))];\n        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[64];\n        v4 = v6 + 1;\n        break;\n      case 3:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v7 = v4 + 1;\n        *((_BYTE *)v12 + v7) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | (4 * (byte_41A144[1] &amp; 0xF))];\n        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[byte_41A144[2] &amp; 0x3F];\n        v4 = v7 + 1;\n        break;\n    &#125;\n  &#125;\n  *((_BYTE *)v12 + v4) = 0;\n  return v12;\n&#125;\n查看aAbcdefghijklmn：\n\n发现是常用的base64编码表，编写脚本：\nimport base64\n\n_str = &#39;e3nifIH9b_C@n@dH&#39;\n\nrawDest = &quot;&quot;\nfor i in range(len(_str)):\n    rawDest += chr(ord(_str[i]) - i)\nprint(rawDest)\n\nflag = base64.b64decode(rawDest)\nprint(flag)\n得到flag：\n\nSimpleRev将文件拖进IDA，查看关键函数及数据\nDecry:\nunsigned __int64 Decry()\n&#123;\n  char v1; // [rsp+Fh] [rbp-51h]\n  int v2; // [rsp+10h] [rbp-50h]\n  int v3; // [rsp+14h] [rbp-4Ch]\n  int i; // [rsp+18h] [rbp-48h]\n  int v5; // [rsp+1Ch] [rbp-44h]\n  char src[8]; // [rsp+20h] [rbp-40h] BYREF\n  __int64 v7; // [rsp+28h] [rbp-38h]\n  int v8; // [rsp+30h] [rbp-30h]\n  __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF\n  int v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  *(_QWORD *)src = 0x534C43444ELL;\n  v7 = 0LL;\n  v8 = 0;\n  v9[0] = 0x776F646168LL;\n  v9[1] = 0LL;\n  v10 = 0;\n  text = (char *)join(key3, v9);\n  strcpy(key, key1);\n  strcat(key, src);\n  v2 = 0;\n  v3 = 0;\n  getchar();\n  v5 = strlen(key);\n  for ( i = 0; i &lt; v5; ++i )\n  &#123;\n    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )\n      key[i] = key[v3 % v5] + 32;\n    ++v3;\n  &#125;\n  printf(&quot;Please input your flag:&quot;);\n  while ( 1 )\n  &#123;\n    v1 = getchar();\n    if ( v1 == 10 )\n      break;\n    if ( v1 == 32 )\n    &#123;\n      ++v2;\n    &#125;\n    else\n    &#123;\n      if ( v1 &lt;= 96 || v1 &gt; 122 )\n      &#123;\n        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )\n        &#123;\n          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n          ++v3;\n        &#125;\n      &#125;\n      else\n      &#123;\n        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n        ++v3;\n      &#125;\n      if ( !(v3 % v5) )\n        putchar(32);\n      ++v2;\n    &#125;\n  &#125;\n  if ( !strcmp(text, str2) )\n    puts(&quot;Congratulation!\\n&quot;);\n  else\n    puts(&quot;Try again!\\n&quot;);\n  return __readfsqword(0x28u) ^ v11;\n&#125;\n数据：\nsrc: NDCLS\nv9: hadow\nkey1: ADSFK\nkey3: kills\n注意v9， key1的数据类型是__int64，是以大端存储的，我们要将其倒过来读取，所以strcpy(key, key1); strcat(key, src);将字符串拼接到key中，得到ADSFKNDCLS，text为killshadow。\n接下来我们分析代码：\n大写转小写：\n  for ( i = 0; i &lt; v5; ++i )\n  &#123;\n    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )\n      key[i] = key[v3 % v5] + 32;\n    ++v3;\n  &#125;\n输入处理：\nprintf(&quot;Please input your flag:&quot;);\n  while ( 1 )\n  &#123;\n    v1 = getchar();\n    if ( v1 == 10 )            // 换行停止\n      break;\n    if ( v1 == 32 )            // 过滤空格\n    &#123;\n      ++v2;\n    &#125;\n    else\n    &#123;\n      if ( v1 &lt;= 96 || v1 &gt; 122 )\n      &#123;\n        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )        // 处理大写字母\n        &#123;\n          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n          ++v3;\n        &#125;\n      &#125;\n      else                                // 处理小写字母\n      &#123;\n        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n        ++v3;\n      &#125;\n      if ( !(v3 % v5) )\n        putchar(32);\n      ++v2;\n    &#125;\n  &#125;\n  if ( !strcmp(text, str2) )\n    puts(&quot;Congratulation!\\n&quot;);\n  else\n    puts(&quot;Try again!\\n&quot;);\n  return __readfsqword(0x28u) ^ v11;\n&#125;\n我们需要将处理后的输入与text比较。采用爆破方式编写解密脚本：\nimport string\n\nkey = &quot;ADSFKNDCLS&quot;.lower()\nkey = list(map(ord, key))  # 转化为ASCII表示\ntext = &quot;killshadow&quot;\ntext = list(map(ord, text))  \n\nflag = &#39;&#39;\ncharSet = string.ascii_uppercase + string.ascii_lowercase  \ncharSet = list(map(ord, charSet))  \nfor i in range(len(key)):\n    for char in charSet:\n        if text[i] == (char - 39 - key[i] + ord(&#39;a&#39;)) % 26 + ord(&#39;a&#39;):\n            flag += chr(char)\n            break\nprint(flag)\n得到：KLDQCUDFZO\nJavaRev拖进jadx中，在defpackage/Reverse找到对应源码：\npackage defpackage;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/* loaded from: Reverse.class */\npublic class Reverse &#123;\n    public static void main(String[] args) &#123;\n        Scanner s = new Scanner(System.in);\n        System.out.println(&quot;Please input the flag ：&quot;);\n        String str = s.next();\n        System.out.println(&quot;Your input is ：&quot;);\n        System.out.println(str);\n        char[] stringArr = str.toCharArray();\n        Encrypt(stringArr);\n    &#125;\n\n    public static void Encrypt(char[] arr) &#123;\n        ArrayList&lt;Integer&gt; Resultlist = new ArrayList&lt;&gt;();\n        for (char c : arr) &#123;\n            int result = (c + &#39;@&#39;) ^ 32;\n            Resultlist.add(Integer.valueOf(result));\n        &#125;\n        int[] KEY = &#123;180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65&#125;;\n        ArrayList&lt;Integer&gt; KEYList = new ArrayList&lt;&gt;();\n        for (int i : KEY) &#123;\n            KEYList.add(Integer.valueOf(i));\n        &#125;\n        System.out.println(&quot;Result:&quot;);\n        if (Resultlist.equals(KEYList)) &#123;\n            System.out.println(&quot;Congratulations！&quot;);\n        &#125; else &#123;\n            System.err.println(&quot;Error！&quot;);\n        &#125;\n    &#125;\n&#125;\n我们对Encrypt函数进行分析：\n对于数组 arr 中的每个字符 c，首先将字符 c 转换为其对应的ASCII码值，再加上 @ 字符的ASCII码值（64）并对结果与32进行异或。将处理后的结果转换为整数，并将其加到 Resultlist 中，然后与KEY进行比较。\n编写解密脚本：\nKey = [180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65]\nflag = &quot;&quot;\n\nfor i in range(0, len(Key)):\n\n    flag += chr((Key[i] ^ 32) - 64)\n\nprint(flag)\n\n\n\n\n\n\n\n\n\n注意，异或运算的优先级低于加减\n[GXYCTF2019]luck_guy将文件拖进IDA中，打开字符串窗口，发现GXY&#123;do_not_。\n找到关键代码get_flag()，分析：\nunsigned __int64 get_flag()\n&#123;\n  unsigned int v0; // eax\n  int i; // [rsp+4h] [rbp-3Ch]\n  int j; // [rsp+8h] [rbp-38h]\n  __int64 s; // [rsp+10h] [rbp-30h] BYREF\n  char v5; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  v0 = time(0LL);\n  srand(v0);\n  for ( i = 0; i &lt;= 4; ++i )\n  &#123;\n    switch ( rand() % 200 )\n    &#123;\n      case 1:\n        puts(&quot;OK, it&#39;s flag:&quot;);\n        memset(&amp;s, 0, 0x28uLL);\n        strcat((char *)&amp;s, f1);\n        strcat((char *)&amp;s, &amp;f2);\n        printf(&quot;%s&quot;, (const char *)&amp;s);\n        break;\n      case 2:\n        printf(&quot;Solar not like you&quot;);\n        break;\n      case 3:\n        printf(&quot;Solar want a girlfriend&quot;);\n        break;\n      case 4:\n        s = 0x7F666F6067756369LL;\n        v5 = 0;\n        strcat(&amp;f2, (const char *)&amp;s);\n        break;\n      case 5:\n        for ( j = 0; j &lt;= 7; ++j )\n        &#123;\n          if ( j % 2 == 1 )\n            *(&amp;f2 + j) -= 2;\n          else\n            --*(&amp;f2 + j);\n        &#125;\n        break;\n      default:\n        puts(&quot;emmm,you can&#39;t find flag 23333&quot;);\n        break;\n    &#125;\n  &#125;\n  return __readfsqword(0x28u) ^ v6;\n&#125;\n首先我们先排除没用的2,3，然后对剩下的进行排序：\n\ncase 4初始化s, f2，放在第一个执行\ncase 5对f2进行一系列操作，放在第二个执行\ncase 1输出flag，放在最后执行\n\n我们得到正确的执行顺序应该为case4-&gt;case5-&gt;case1。\n方法一：直接编写python脚本\n按上面那个顺序写就可以了。\nflag = &quot;GXY&#123;do_not_&quot;\nf2 = [0x69, 0x63, 0x75, 0x67, 0x60, 0x6f, 0x66, 0x7f]  # 注意大端序\nfor i in range(0, len(f2)):\n    if i % 2 == 1:\n        f2[i] -= 2\n        flag += chr(f2[i])\n    else:\n        f2[i] -= 1\n        flag += chr(f2[i])\n\nprint(flag)\n方法二：patch\n\n\n\n\n\n\n\n\n\n牛魔酬宾什么鬼东西，给骗了    我有jumpout恐惧症\n\n我们先进入case 4\n\n我们删除case 4中的jmp指令，选中后右键菜单选择nop\n\n同样把case 5的跳转改为case 1的地址\n\n我们再回到case 1，将case 1运行结束后跳转至整个程序的结束。\n\n\n我们只要在反汇编中找到对应的jmp，然后修改跳转的地址就行了，修改后反编译的结果如下：\nint get_flag()\n&#123;\n  unsigned int v0; // eax\n  int i; // [rsp+8h] [rbp-38h]\n  __int64 s; // [rsp+10h] [rbp-30h] BYREF\n  char v6; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v7; // [rsp+38h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  v0 = time(0LL);\n  srand(v0);\n  s = 0x7F666F6067756369LL;\n  v6 = 0;\n  strcat(&amp;f2, (const char *)&amp;s);\n  __asm &#123; insb &#125;\n  for ( i = 0; i &lt;= 7; ++i )\n  &#123;\n    if ( i % 2 == 1 )\n      *(&amp;f2 + i) -= 2;\n    else\n      --*(&amp;f2 + i);\n  &#125;\n  puts(&quot;OK, it&#39;s flag:&quot;);\n  memset(&amp;s, 0, 0x28uLL);\n  strcat((char *)&amp;s, f1);\n  strcat((char *)&amp;s, &amp;f2);\n  return printf(&quot;%s&quot;, (const char *)&amp;s);\n&#125;\n","slug":"WP-1","date":"2023-11-05T06:31:12.000Z","categories_index":"","tags_index":"CTF,Reverse,buuoj","author_index":"C4IN"},{"id":"d99770e1923876729b03e08dda13a753","title":"联邦学习出门","content":"联邦学习初识本质：联邦学习本质上是一种分布式机器学习技术，或机器学习框架。\n目标：联邦学习的目标是在保证数据隐私安全及合法合规的基础上，实现共同建模，提升AI模型的效果。（也就是解决所谓的数据孤岛问题）\n联邦学习的分类根据多参与方之间数据分布的不同，把联邦学习分为三类：横向联邦学习、纵向联邦学习和联邦迁移学习。\n横向联邦学习\n横向联邦学习的本质是样本的联合，适用于参与者间业态相同但触达客户不同，即特征重叠多，用户重叠少时的场景，比如不同地区的银行间，他们的业务相似（特征相似），但用户不同（样本不同）。\n\n步骤：\n\n各参与方从服务器A下载最新的模型，利用本地的数据训练模型，将得到的梯度加密后上传给服务器A，\n服务器A加权聚合各用户的梯度并更新模型参数。\n服务器A返回更新后的模型给各个参与方，各参与方更新各自的模型，直至模型收敛。\n\n\n\n\n\n\n\n\n\n\n加权聚合：，为权重，是值\n在横向联邦学习中，可以看作是基于样本的分布式模型训练，分发全部数据到不同的机器，每台机器从服务器下载模型，然后利用本地数据训练模型，之后返回给服务器需要更新的参数；服务器聚合各机器上的返回的参数，更新模型，再把最新的模型反馈到每台机器。在这个过程中，每台机器下都是相同且完整的模型，且机器之间不交流不依赖，在预测时每台机器也可以独立预测。\n纵向联邦学习\n纵向联邦学习又称基于特征学习，适用于两个数据集共享相同的样本ID空间，但特征空间不同的情况。比如在同一诚实的两家不同的公司，他们的受众都是这个城市的居民，但是两家公司提供的服务与需求不同。\n纵向联合学习是将这些不同的特征聚合在一起，以保护隐私的方式计算训练损失和梯度，从而利用双方的数据协同构建模型的过程。\n\n假设A和B想用自己的数据联合训练一个机器学习模型，且只有B有模型需要预测的标签数据。出于数据隐私和安全原因，A和B不能直接交换数据。为了保证训练过程中数据的保密性，我们引入了第三方合作者C。这里我们假设合作者C是诚实的，不与A或B串通，但A和B是诚实的，但彼此好奇，也就是该方法是在可信第三方下满足半诚实安全性的。\n加密样本对齐：使用基于加密的用户ID对齐技术来确认共同用户（也就是重叠样本），而不会暴露A和B各自的数据。在实体对齐期间，系统不会公开彼此不重叠的用户。\n训练加密样本：在确定共同用户（重叠样本）之后，我们可以使用这些共同用户的数据来训练机器学习模型。\n\n合作者C生成密钥对，将公钥发送给A,B\nA和B计算梯度以及损失，将得到的中间结果进行加密和交换\nA和B分别计算加密梯度并添加附加掩码，同时B计算加密损失；A和B将加密值发送给C\nC进行解密，并将解密后的梯度以及误差发送给A和B。A和B去除梯度的掩码，更新相应的模型参数。\n\n我们以线性回归和同态加密为例：\n假设学习率为 ，正则化参数，数据集以及分别对应的特征空间的模型参数，训练目标是：\n\n令，加密损失是：\n\n我们定义加法同态加密为，令，以及，我们有\n\n同样，令，则梯度为：\n\n\n为了进一步防止C从A或B那里学习信息，A和B可以通过添加加密的随机掩码（）进一步对C隐藏它们的梯度。\n\n\n\n\n\n\n\n\n\n正则化：添加参数来防止曲线过拟合\n\n联邦迁移学习\n联邦迁移学习适用于两个数据集不仅在样本上不同，而且在特征空间上也不同的情况。比如两个机构，一个是位于中国的银行，另一个是位于美国的电子商务公司，此时两者的样本与特征均只有小部分重叠 。我们可以使用有限的公共样本集学习两个特征空间之间的重叠部分，然后应用于其中一侧特征的样本的预测。                                                                                    \n联邦迁移学习与纵向联邦学习相似。在纵向联邦学习，若A，B仅有非常小的重叠样本集，为了将其覆盖范围扩展到整个样本空间，我们引入了迁移学习。迁移学习引入的目的是减少预测时的错误，因此在梯度计算时和纵向联邦略有不同。\n知乎-联邦学习\nWardseptember’ github\n聚合&amp;模型选择\nFederated Machine Learning: Concept and Applications\n","slug":"联邦学习出门","date":"2023-11-03T09:57:05.000Z","categories_index":"","tags_index":"联邦学习","author_index":"C4IN"},{"id":"e16b1f3b0f9a87736cbe2367687acdd5","title":"概率论公式整理-1","content":"\n\n\n\n\n\n\n\n\n😭要期中考了\n🐻1.2 随机事件和随机事件包含关系若，即事件发生，必然导致事件发生，称事件包含事件A，或是的子事件\n和事件从集合角度:  或\n从事件角度:  是事件与至少有一个发生\n积事件从集合角度:  且\n从事件角度:  是事件与同时发生\n互不相容事件\n若, 称、为互不相容或互斥事件,即、不可能同时发生\n\n中任意两个互不相容, 称互不相容(两两互斥)\n\n事件列互不相容是指其中任意有限个事件互不相容\n\n\n对立事件(逆事件)若, 且 , 称、互为对立事件 (逆事件)，记为从集合角度:  从事件角度:  是事件不发生\n差事件事件与之差记为从集合角度:  但从事件角度:  是事件发生并且不发生有\n完备事件组若两两互斥，且, 则称为完备事件组, 或称为的一个有限划分\n运算律\n交换律:  \n\n\n\n结合律:  \n\n\n\n分配律:  \n \n\n\n德·摩根律:\n\n\n吸收律:\n如果, 则，有\n \n\n\n🐶 1.3 概率频率\n频率具有稳定性：在一定条件下，频率稳定于概率\n古典概型\n仅有有限多个基本事件\n每个基本事件发生的可能性相等.\n\n所含的基本事件个数基本事件总数所含样本点的数目样本空间的样本点总数\n古典概率具有如下三个性质：\n\n对任意事件, 有\n\n\n\n若互不相容, 则\n\n\n\n概率的公理化定义设的样本空间为, 对于  E  的每个事件  A  均对应于唯一一个实数，记为  P(A) ,其对应规则为\n\n非负性：对任一事件, 有\n\n规范性：\n\n可列可加性：的事件列 , 互不相容,则\n\n​    \n​    称是的概率\n性质：\n\n不可能事件的概率为 0 , 即\n有限可加性：若试验的事件组互不相容, 则有\n\n​    \n\n对立事件概率之和为 1 , 即\n\n​    \n\n概率单调性：若事件和满足, 则有\n\n由概率的有限可加性，得\n\n有用结论:\n\n\n\n\n概率加法定理: 对试验的任意两个事件和有\n\n🥚1.4 条件概率定义: 设，是随机试验的两个随机事件，且，称\n为在事件发生的条件下，事件发生的条件概率\n非负性​    \n归一性​    \n可列可加性​    \n\n\n\n\n\n\n\n\n\n\n乘法公式​    设, 则有\n​    若, 有\n​    更一般地有, 若, 则\n​    \n全概率公式（事前概率）设随机试验的样本空间为, 为的一个有限划分, 且, 则有\n\n贝叶斯公式（事后概率）设随机试验的样本空间为为的一个有限划分, 且, 则有\n\n🐺1.5 随机事件的独立性事件的独立性设是试验的两个事件，若满足\n\n\n称事件与相互独立（上述两公式等价）。若事件和相互独立，则下列三对事件也相互独立\n​    \n设为试验的事件，若对任意的及 , 有\n\n成立，则称事件相互独立。若对一切, 有\n\n成立，则称事件两两独立。\n若个事件，相互独立，则将，，中的任意多个事件换成它们的对立事件后，所得到的个事件仍然相互独立。\n🍕2.1 随机变量的分布函数设的样本空间为, 对于每一个样本点, 都有唯一实数与之对应,且对于任意实数 , 事件都有确定的概率，则称为随机变量，简记为\n\n\n\n\n\n\n\n\n\n且使总有意义.\n分布函数设是一个随机变量,  是任意实数，称函数\n\n为随机变量的分布函数,  也记为\n分布函数的函数值表示事件 “随机点落在内“。\n的改变量是事件 “随机点落在内” 概率。\n分布函数的性质\n为单调不降函数, 即若，则有\n, 且\n\n是右连续函数, 即，从而有\n\n\n🍔2.2 离散型随机变量如果随机变量  X  至多取可列无穷个数值:  , 记, 且满足\n\n称是离散型随机变量\n离散型随机变量的分布律称为的分布律。表示为\n\n\n\n\nX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对于离散型随机变量，因\n\n故由概率可加性\n\n贝努里实验和二项分布在重贝努里试验中, 事件发生概率为, 则事件发生的次数的分布律为\n\n称随机变量服从二项分布, 记为。分布可以看作\n泊松分布若随机变量的分布律为\n\n称服从参数为的泊松分布。记为泊松分布的重要性在于:\n\n现实中大量随机变量服从泊松分布\n泊松分布可视为二项分布的极限分布\n\n设随机变量序列，即有\n\n若, 则有\n\n即数列与是同阶的无穷小。故\n\n当  n  够大,  p  较小时有\n\n​    \n​    其中\n\n实际问题中,  n  次独立重复试验中, “稀有事件” 出现的次数可认为服从泊松分布.\n\n🍟2.3 连续型随机变量概率密度函数设随机变量的分布函数为, 若存在非负函数, 对于任意实数, 均有\n\n称随机变量是连续型随机变量, 称函数为的概率密度。\n\n连续型随机变量X的分布函数是连续函数\n\n是连续型随机变量，则对任意实数 , 有\n\n\n , 但是其逆不真\n\n\n概率密度函数的性质\n\n\n，即概率曲线下总面积为1\n\n满足上式的函数必是某个随机变量的概率密度函数。\n\n\n\n若在点处连续, 则有\n\n\n\n均匀分布设随机变量的概率密度函数为\n其他\n称随机变量在区间上服从均匀分布, 记为\n随机变量落在的子区间的概率与位置无关，仅与测度 (即长度) 成正比，即对于, 有\n\n指数分布设随机变量的概率密度函数为\n其他\n称随机变量服从参数为的指数分布。指数分布具有无后效性， 即有\n\n正态分布（高斯分布）设随机变量的概率密度函数为\n\n其中是常数，则称随机变量服从参数为的正态分布(或高斯分布)，记为\n特别当时，其概率密度为\n\n称随机变量服从标准正态分布，即\n\n正态分布概率密度曲线的特征\n即概率曲线下总面积为 1 \n\n曲线关于直线对称, 即对任意实数有\n\n\n\n  曲线下直线两侧的面积各为, 并且\n  \n正态分布概率的计算\n若随机变量, 其分布函数为\n\n若随机变量服从标准正态分布,其分布函数为\n\n有\n\n若随机变量, 则\n\n​    \n\n若随机变量, 则\n\n​    \n\n分位数  \n, 若实数使\n\n\n​    \n​    则称为标准正态分布的对应于的上侧分位数。\n😍3.1 二维随机变量及其分布设随机试验的样本空间为, 对于每一样本点, 有两个实数与之对应，称它们构成的有序数组为二维随机变量。\n联合分布函数记事件\n\n对任意实数对, 称二元函数\n\n为的联合分布函数，其几何意义就是与坐标轴包围的面积。\n\n\n一维随机变量、的分布函数和称为的边缘分布函数.由联合分布函数可确定边缘分布函数\n\n\n\n\n\n\n\n\n\n\n注意，无法仅由边缘分布函数确定联合分布函数\n多维随机变量的联合分布不仅与每个分量的边缘分布有关，而且还与每个分量之间的联系有关\n联合分布函数的性质\n\n单调不减性  \n分别对 单调不减。\n当  \n当  \n\n\n  \n\n有界性 \n\n  \n\n右连续性 \n分别关于或右连续。\n\n\n​    \n\n相容性\n\n​    对任意, 有\n​    \n若二元函数满足上述4条性质，则必存在二维随机变量以为分布函数。\n维随机变量的联合分布函数为\n\n由的联合分布函数，可确定其中任意个分量的联合分布函数，称为维边缘分布函数。\n\n联合分布律设二维随机变量  (X, Y)  至多取可列对数值:  \n\n\n若 \n\n\n\n\n称为二维离散型随机变量，称\n为\n的联合分布律。\n联合分布函数为\n\n由联合分布律确定随机变量的分布律\n\n\n联合概率密度二维随机变量的联合分布函数为, 如果存在非负的函数使得对任意实数对, 有\n\n称是连续型随机变量，称为的联合概率密度.\n性质\n\n\n\n\n\n前两条可作为判断一个二元函数是否是联合概率密度的标准\n\n\n若在处连续, 则\n\n\n​    \n\n若, 有\n\n​    \n\n关于和的边缘概率密度为\n\n  \n二维均匀分布设, 面积为, 若二维随机变量的联合概率密度为\n其他\n则称在上服从均匀分布。\n\n在上服从均匀分布，设则有\n\n\n设则  \n的长度的长度\n\n\n二维正态分布二维随机变量联合概率密度为\n\n其中均为常数 , 且，称服从二维正态分布，记为：\n\n若，则\n😋3.2 二维随机变量的独立性随机事件与相互独立，若\n\n设是二维随机变量, 若对任意实数对均有\n\n成立，称 与相互独立。\n等价条件\n\n与相互独立对任意实数均成立\n\n离散型：    \n\n连续型：\n，在平面上除去 “面积” 为 0 的集合外成立\n\n\n多维随机变量的独立性设维随机变量的联合分布函数为 , 若对任意实数均有\n\n称相互独立。\n对任意实数向量, 个随机事件都相互独立\n若维随机变量相互独立，则任意个随机变量也相互独立。\n 随机变量相互独立则一定两两独立，但逆不真。\n若维随机变量相互独立，则\n\n随机变量也相互独立\n\n维随机向量与维随机向量也相互独立\n\n随机变量与也相互独立\n\n\n🥰3.3 条件分布设的联合分布律为:\n\n若, 则在事件发生的条件下事件发生的条件概率为\n\n此概率数列具有分布律的性质:\n\n\n\n\n称 的条件下，随机变量的条件分布律，可以等价地改写为乘法\n\n\n​    \n条件概率密度给定, 对任意有\n\n且对任意, 极限\n\n存在,称此极限函数为在的条件下，随机变量的条件分布函数。记作。\n设是连续型随机变量，且满足在附近连续, 且则有\n\n我们称\n\n为在的条件下随机变量的条件概率密度。\n判断两个离散型随机变量相互独立\n1)  2)  3)  4)  \n判断两个连续型随机变量相互独立\n1)  2)  3)  4)  \n🤤3.4 随机变量函数及其分布离散型随机变量的分布律为\n\n是随机变量, 则\n\n其中\n设随机变量是离散型随机变量,  相互独立,其分布律分别为\n\n则的分布律为\n\n二维离散型随机变量  (X, Y)  的联合分布律为\n\n是随机变量, 则\n\n其中\n设随机变量是离散型随机变量,  相互独立,其分布律分别为\n\n则的分布律为\n\n若相互独立, 且则\n反之若, 则存在相互独立的, 使\n\n随机变量相互独立\n具有相同类型的分布;\n\n若的分布除参数变化，而分布类型不变，称分布具有可加性（二项分布、泊松分布）。\n连续型随机变量的函数及其概率密度\n设是连续型随机变量，若也是连续型随机变量，则\n\n​    的连续点其他\n\n\n\n\n\n\n\n\n\n从分布函数定义出发\n将转换为关于的不等式：\n\n当为单调递增函数时\n\n从而有\n\n当为单调递减函数\n\n\n\n  有\n\n求二维连续型随机变量的函数的概率密度\n\n\n先求出的分布函数\n\n\n对微分得到\n\n\n特殊函数分布\n若与相互独立, 有\n\n又若与有相同分布\n从而\n设随机变量的联合概率密度为\n\n做积分变量变换, 令\n\n由连续型随机变量定义\n\n得到公式\n\n类似可以得到：\n\n设随机变量的联合概率密度为\n\n\n\n\n\n做积分变量变换，令，有\n\n","slug":"概率论公式整理-1","date":"2023-10-27T08:29:15.000Z","categories_index":"","tags_index":"课内,概率论与数理统计","author_index":"C4IN"},{"id":"c7a71862699349f10d6bd40f9dbcde05","title":"TinyOLE","content":"TinyOLE是一种实现无条件安全双方计算的有前景的方法。建立在OLE原语之上，该协议高效且可应用于广泛的应用场景。虽然该协议存在一些限制，但它代表了安全计算领域的重要进展。\n文章引入了一种基于不经意线性函数计算(OLE)的主动安全两方安全计算(2PC)的新方法，这是不经意传输(OT)的拓展。该协议在概念上简单，提供无条件的UC-安全性，并将OLE原始操作作为黑盒使用。\n在1-out-of-2 OT中，发送者输入两个消息和，接收者输入一个选择位b并只获取。OLE在有限域F上工作，其中发送者输入两个域元素a和b，接收者输入一个域元素并只获取。注意，如果我们设置和，那么和。因此，对于有两个元素的字段，OLE等同于比特的1-out-of-2 OT。因此，OLE可以被视为OT的拓展，适用于较大字段的情况。在多种假设下，可以有效地实现OLE，既有独立的安全性，也有UC-安全性。\n文章所提出的协议可以评估一个有限域F上的算术电路，前提是拥有OLE的黑盒访问机制。这种方法每个乘法门只消耗22个OLE。从概念上讲，文章所提出的方案采用了Nielsen等人在tinyOT中的技术，将基于OT的布尔电路的实际积极安全的2PC提升到算术设置。在此过程中，文章开发了几种新的方案，用于生成各种风格的OLE并组合它们。\n参考隐私计算研习社-TinyOLE\n论文链接\n","slug":"TinyOLE","date":"2023-10-27T08:10:18.000Z","categories_index":"","tags_index":"","author_index":"C4IN"},{"id":"9e7562adc34393738695af14263310c0","title":"Lattice-NTRU-2","content":"多项式卷积乘法多项式的卷积乘法可以看成一个矩阵操作。假设和在上相乘，表述为：\n\n那么就有（参考多项式乘法，用分配律也行）：\n\n由于的结果肯定也是个多项式（封闭性），所以先把上面结构调整到像一个多项式，即合并次数相同的项（注意和最高项只能是 ，所以不考虑模的时候乘起来最高项只能是，然后小于次的项和大于等于次的项分开处理）：\n\n最开始讲环的时候说到，是模的，所以，所以有：\n\n所以说未知数的指数部分需要模，可以继续化简：\n\n其中的即为的次项系数。 \n\n\n\n\n\n\n\n\n\n设则: \n\n检验通过\n以下用矩阵的形式表达，且记的第次项系数为，有：\n\n","slug":"多项式卷积乘法","date":"2023-09-25T00:54:38.000Z","categories_index":"Crypto","tags_index":"Lattice,Crypto","author_index":"C4IN"},{"id":"d702884c0497c30710829cd42dd95573","title":"Lattice-NTRU-1","content":"NTRU是一个带有专利保护的开源公开密钥加密系统，使用基于格的加密算法来加密数据。它包括两部分算法：NTRUEncrypt用来加密，NTRUSign用来进行数字签名。与其他流行的公钥加密系统不同，它可以防止被Shor算法破解，并显著提升了性能。\n多项式除法我们首先了解一下多项式除法。多项式除法是代数中的一种算法，用一个同次或低次的多项式去除另一个多项式。它可以很容易地手算，因为它将一个相对复杂的除法问题分解成更小的一些问题。多项式除法和我们小学学到的带余除法是有些相似的（算数的长除法）。\n下面有个例子：\n计算\n\n横线上多项式即为商，而剩下的（-123）就是余数。\n\n多项式除法-wiki\nNTRU我们先看三个卷积多项式环（Convolution Polynomial Rings）。\n\n其中是整数域上的多项式，比如这类的多项式，长横线是商环（Quotient Ring），分子上的多项式模上分母的就会落在，其中是NTRU的参数。\n\n\n\n\n\n\n\n\n\n比如说我们取，即，我们试着把换到上，模数是，有\n\n就是最后落在上的结果，即是上面说的多项式除法的余数。\n\n标记一下Sage这个东西\n\n类似，但是系数模的多项式，也就是多项式的系数需要模，使其落在中。说白了就是的另一种写法。\n\n\n\n\n\n\n\n\n\n同样的来看一个例子，设，把转换到中：\n\n上述是NTRU的公开参数，要求为素数，且\n\n\n\n\n\n\n\n\n\n\n更详细的参数设置建议（[HPS17]）：\n一般取，为了加快运算一般取2的幂次方，通用取素数。\n三元多项式和密钥生成输入为两个整数，输出一个三元多项式，三元即，函数会采样有个项系数为1，个项系数为-1，其余项系数为0（即没有）且落在上的多项式。\n然后利用采样密钥：\n\n私钥：\n可信方选择满足上述条件的公共参数，私钥由两个随机选择的多项式组成\n\n取的原因是不可逆。计算逆元\n\n是两个落在上的主要的私钥，把和事先存储起来可以加快运算速度，因为计算多项式环的逆元需要一段时间。\n\n公钥：\n\n或者\n\n\n\nCenter-Lift和加解密Center-lift是把和中的多项式转换回中，使得多项式系数的绝对值最小。Center-lift的定义可以看[HSP14]的7.9节，主要是针对多项式系数的操作，可以和补码类比。\n上面假设是多项式的Center-lift，即转换到。 上图的为上的一个多项式，为其Center-lift到后的结果， 为的次项系数，为的次项系数，结果是所有的系数会落在区间 ，而且还能保证。\nCenter-lift的方法也不难，和转补码相似\n\n然后看看加密：\n明文空间是做Center-Lift后的空间，加密使用的随机数在中采样，加密公式是：\n\n如果要解密的话，只需要将去除即可，由于，所以直观上把放入中就可以把去除，而明文空间是做Center-Lift的空间，所以把放入并不会改变的结构，即可以恢复明文。但实际上我们没办法保证，除非，但由于，所以这种情况并不存在，不能直接转换到上。\n前面说过可以转换到上，所以可以考虑把转换（Center-Lift）到上，然后再转到上。但同时也会有新的问题，直接把上的转换到上的结果不一定是原来的上的，比如说，除了把放在上运算后的系数就落在上，也即上的元素做Center-lift后的区间。\n参考：\n[HPS14]Hoffstein J, Pipher J, Silverman J H, et al. An introduction to mathematical cryptographyM]. New York: springer, 2008.\n[HPS17] [Hoffstein J, Pipher J, Schanck J M, et al. Choosing parameters for NTRUEncrypt[C]//Topics in Cryptology–CT-RSA 2017: The Cryptographers’ Track at the RSA Conference 2017, San Francisco, CA, USA, February 14–17, 2017, Proceedings. Springer International Publishing, 2017: 3-18.\nhttps://0xffff.one/d/1424-ntru-xue-xi-bi-ji\n","slug":"Lattcies-NRTU","date":"2023-09-19T13:46:45.000Z","categories_index":"Crypto","tags_index":"Lattice","author_index":"C4IN"},{"id":"f321673e1ae041d21d7612aab6d63663","title":"lattice-crypto-1","content":"线性独立空间上有集合，格 (Lattices) 就是这些向量的线性组合，用公式表示为: \n\n而其中任意一组可以生成格的线性无关的向量都称为格的基，格的维数等于格中向量的个数。某种意义上格可以理解为系数均为整数的向量空间。\n\n格的困难问题最短向量问题（SVP，The Shortest Vector Problem）寻找一个格中最短的非零向量。即，寻找一个满足其欧几里德范数最小。\n最接近向量问题（CVP，The Closest Vector Problem）对于一个非格中的向量，在格中寻找一个向量，使得  最小。 \n由于CVP和SVP都是NP完备问题，因此求解起来十分困难，因此这两个问题都是可以作为密钥体制的基础的。\ntoy model它是 lattice 可用于传统公钥密码分析的例证，另外也是 NTRU 公钥密码体系的一个低端版本。\n首先Alice选择一个大整数作为公共参数，然后选择两个比较小的整数满足\n\n亦即的长度大约小于 的一半；的长度大约在的一半到的一半之间。从而远远小于, 为。另外要求与都互质。接下来, Alice 计算\n\n注意到尽管很小, 其逆元仍然会很大, 于是是的级别。Alice 的公钥是 , 私钥是 。\n假设Bob有一个小于的明文，然后他随机选择整数，计算\n\n将作为密文发送给Alice，Alice解密：\n先计算\n，\n然后计算\n，\n特别注意这里的模数是。\n带入，得到\n\n\n于是我们断言。\n\n\n\n\n\n\n\n\n\n原因：\n首先我们有,\n注意到，所以，即就是的真实值。\n将模，分离出，然后乘以得到，我们可以知道，于是就是真实值。\n我们可以发现，假如一个敌手想攻破该密码体系，只需要伪造一组，使其解密时与相同即可。也就是说需要满足：\n\n然后按照上述步骤进行，就可以获得。也就是说只需要找到合法的，就可以攻破这个密码体系。\n将改写成，那么就可以转化为找到足够小的使得\n\n这个式子等价于这两个向量以为系数进行线性组合，如果我们能找到合适的，使得线性组合得到的向量足够短，那我们就攻破了该密码体系。\n上面的问题总结起来就是：有两个已知的向量，需要找出一套线性组合系数（必须是整数），来生成一个足够短的向量。\n对于敌手，已知长度均为向量，需要寻找长度为的线性组合来攻破密码体系。从格的角度来说，即在lattcie 寻找一个很短的向量：\n\n在二维的 lattice 里面找最短向量，是有高效算法的（Gauss 的工作）。于是攻破了这个密码体系。\n推荐https://www.ruanx.net/lattice-1/\nhttps://lazzzaro.github.io/2020/11/07/crypto-%E6%A0%BC%E5%AF%86%E7%A0%81/index.html\n","slug":"lattice-1","date":"2023-09-19T10:44:02.000Z","categories_index":"","tags_index":"Crypto,lattice","author_index":"C4IN"},{"id":"030d8a1cfb3d1c00a80edaa1d841a1b0","title":"MASCOT前置知识（二）","content":"SPDZ框架摘要SPDZ是一种MPC计算的协议框架，基于同态加密、秘密共享等技术实现安全多方计算，相关内容引自参考文献[1].\n\nSPDZ主要包括两个阶段，离线阶段（预计算）主要基于同态加密生成在现阶段需要的参数，在线阶段主要基于秘密共享完成各种计算。\nSPDZ可以计算有限域中的任何计算。\nSPDZ 满足 UC 安全框架下的静态恶意敌手(static adaptive adversay)攻击模型，即 n 个参与方中，即使最多 n-1 个参与方恶意违反协议或者合谋。\nSPDZ使用Message Authentication Code (MAC)，检测参与方是否诚实地进行计算，MAC参数在离线阶段生成。\nSPDZ不检测哪个参与方为恶意参与方，在检测到协议被违反情况即停止协议运行而防止数据泄漏。\n\n安全模型安全多方计算安全模型一般采用Universally composable（UC）模型[2]，按照攻击者能力可以划分为半诚实、恶意参与者，按照恶意参与者的门限可以划分为多数诚实、多数恶意协议。\n按照攻击者能力：\n\n半诚实模型：各参与方在计算过程中完全遵从 MPC 协议，既不会违反协议篡改数据也不会多个参与方之间进行合谋。\n恶意模型：攻击者允许随意篡改协议，可以联合他人进行合谋攻击。\n\n按照攻击者门限：\n\n多数诚实：恶意参与者不超过总参与方一半。\n多数恶意：恶意参与者至多可以有个（总参与方为）。\n\nSPDZ协议满足Universally composable（UC）框架下的静态恶意敌手(static adaptive adversary)攻击模型，最多允许个恶意参与方。\n基本定义秘密分享共有两种表示方法和，第一种主要用于表示输入的秘密分享值，第二种则主要用于表示全局密钥和随机数等参数。\n$表示\">表示有限域中的值的秘密分享值表示方法为：\n\n\\langle a \\rangle := (\\delta,(a_1,\\cdots,a_n),(\\gamma(a)_1,\\cdots,(a)_n))其中，\n各参与方持有，是公开值，为全局MAC密钥。\n秘密分享值计算具有以下性质：\n\n\n\n\n\n\n\n\n\n\n\n\n其中\n表示的秘密分享值表示方法为：\n各参与方持有\n\n(\\alpha_i,\\beta_i,\\gamma(\\alpha)_1^i,\\cdots,\\gamma(\\alpha)_n^i)其中为各参与方的密钥，主要验证MAC密钥和随机数秘密分享值的MAC验证。\nMAC密钥MAC密钥全局MAC密钥秘密分享值表示方法为，由于每个参与方持有\n\n(\\alpha_i,\\beta_i,\\gamma(\\alpha)_1^i,\\cdots,\\gamma(\\alpha)_n^i)因此各参与方可通过验证MAC密钥。为了打开，参与方将发送给，校验是否成立。\n三元组及乘法运算加法计算相对直接，直接利用秘密分享值的性质，计算加法，即可得到结果：\n乘法计算需要借助三元组（Beaver Triple[3]），三元组在离线阶段生成，表示为，且满足。\n由于在实际生成三元组过程中可能会引入误差，因此需要额外“消耗”(sacrificing)一组三元组用于校验三元组。\n给定一三元组，设输入为则乘法可按一下方式计算：\n\n打开得到，\n打开得到，\n然后计算\n\n正确性验证：\n\n\\begin{align}\n\\lang x \\rang \\cdot \\lang y \\rang &= \\lang c \\rang +\\epsilon\\lang b \\rang + \\delta \\lang a \\rang +\\epsilon\\delta \\\\\n&=\\lang ab \\rang + (\\lang x \\rang - \\lang a \\rang)\\lang b \\rang+(\\lang y \\rang - \\lang b \\rang )\\lang a \\rang + (\\lang x \\rang - \\lang a \\rang )(\\lang y \\rang - \\lang b \\rang)\\\\\n&=\\lang ab \\rang + \\lang bx\\rang-\\lang ab \\rang +\\lang ay \\rang -\\lang ab \\rang+\\lang xy \\rang-\\lang ay \\rang - \\lang bx \\rang +\\lang ab \\rang\\\\\n&=\\lang xy \\rang\n\\end{align}SPDZ协议SPDZ协议主要包括离线阶段和在线阶段。\n\n离线阶段\n离线阶段需要用到同态加密技术，产生的辅助数据包括：\n\n多元乘法三元组的秘密分享值；\n随机数秘密分享值；\n全局MAC密钥。\n\n这些辅助信息和在线计算阶段的输入数据无关，因此可以提前进行计算。\n以全局MAC密钥​为例，介绍离线阶段生成参数过程：\n\n各参与方联合生成同态加密公钥和私钥，以 BGV 方案[4]为例，私钥和公钥具有线性特性，因此解密过程中各方可利用进行部分解密，然后把解密结果汇总得到最终明文结果，解密过程中不泄漏各自部分的私钥； \n各参与方生成随机数，然后利用进行同态加密得到密文(表示$$\\alpha_i的同态密文)，并将密文发送给其他参与方; \n各参与方汇总得到，利用私钥进行联合解密，联合解密过程中会加入一个随机数进行混淆，然后reShare得到。\n\n\n在线阶段\n\n初始化。准备全局MAC密钥，随机数秘密分享值，乘法三元组等参数。\n输入阶段。设参与方的输入为，向打开，然后广播，各参与方计算。输入阶段主要是将输入值分片，产生对应的秘密分享值。\n加法计算。设输入为，计算。 \n乘法计算。设输入为，则计算分为两步：\n使用三元组校验；\n计算。 \n\n\n输出阶段。再输出最终结果前，需要对中间值、结果进行MAC校验，SPDZ 协议 MAC 验证时为了提高效率，可以在打开多个秘密分享值后通过一次MAC批量校验。\n\n\n\n协议离线阶段离线阶段主要借助同态加密、、、协议实现，其中同态加密主要保证秘密共享的同态加法、乘法性质，协议主要将秘密值进行分割，进行加法秘密共享，协议主要生成形式的秘密共享值，协议主要生成形式的秘密共享值。\n同态加密同态加密方案未提出具体方案，可参考BGV[1]等同态加密方案（在后续SPDZ改进论文中，使用了一层的BGV方案）。\n协议协议主要输入同态加密密文（明文为），以及一个参数，若，则输出为（由参与方持有)，且有；若，则输出一个新的密文，新的密文仍然包含。\n1.各参与方随机选择，记。\n2.各参与方计算，并将结果发送给其他参与方。\n3.各参与方生成的零知识证明，并发送给其他参与方进行验证（零知识证明为一种密码协议，可以在不泄漏秘密值的情况下证明秘密值的正确性）。\n4.所有参与方计算， 。（PS+不一定是简单相加）\n5.所有参与方运行分布式解密算法，解密，得到。\n6.参与方计算，其他参与方计算。\n7.若，则所有参与方计算。\nP Bracket协议P Bracket协议输入为各参与方的秘密份额，以及一个公共的秘密份额（密文中包含），输出形式的秘密分享值。\n1.对于， 所有参与方计算；各参与方计算，因此各参与方得到了的秘密值份额。\n2.输出。\nP Angle协议P Angle协议输入为各参与方的秘密份额，以及一个公共的秘密份额（密文中包含），输出形式的秘密分享值。\n1.所有参与方计算；\n2.各参与方计算，因此各参与方得到了的秘密值份额。\n3.输出。\n离线阶段完整协议初始化\n所有参与方运行分布式密钥生成算法，得到公钥；\n各参与方生成； \n各参与方生成，记，为全局MAC密钥；\n各参与方计算并广播密文,，其中；\n各参与方使用零知识证明协议验证为正确；\n所有参与方计算，生成秘密分享值。\n\n生成随机秘密共享值\n各参与方生成，记；\n各参与方计算并广播密文，记； \n各参与方使用零知识证明验证密文的正确性；\n所有参与方计算。\n\n生成乘法三元组\n各参与方生成记，；\n各参与方计算并广播密文；\n各参与方使用零知识证明协议验证密文的正确性； \n所有参与方计算；\n所有参与方计算； \n所有参与方计算； \n所有参与方计算；\n所有参与方计算。\n\n在线阶段完整协议在现阶段主要完成计算以及中间值和结果的MAC校验等，基础计算主要包括加法、乘法等。\n在线阶段主要过程如下：\n\n初始化。准备全局MAC密钥，随机数秘密分享值、，乘法三元组等参数。\n输入阶段。设参与方的输入为，向打开，然后广播，各参与方计算。输入阶段主要是将输入值分片，产生对应的秘密分享值。\n加法计算。设输入为，计算。\n乘法计算。设输入为，则计算分为两步：\n使用三元组校验；\n计算。\n\n\n输出阶段。再输出最终结果前，需要对中间值、结果进行MAC校验，SPDZ 协议 MAC 验证时为了提高效率，可以在打开多个秘密分享值后通过一次MAC批量校验。\n\n\n设在此次验证 MAC 前已有个秘密分享值被打开，即有个MAC 未验证，记为，其中对应的秘密分享值为，需要先打开一个随机值，然后各参与方计算，最后各参与方计算；\n各参与方使用对和输出值进行“承诺”，“承诺”函数包括承诺阶段和打开阶段，承诺阶段对秘密值进行“混淆”，生成承诺值，并发送给验证方；打开阶段，发送方将秘密值发送给验证方，验证方使用秘密值（通常也会加入随机数）验证承诺值。“承诺”函数可由Paillier加密、离散对数、哈希等方法构造。\n打开全局MAC密钥。\n各参与方通过承诺函数，打开，然后所有参与方验证，若公式成立，则验证通过，即输出结果正确，否则，终止协议。\n打开最终结果前，需要对的承诺值进行验证。验证通过后，计算，然后验证，验证通过，则即为最终正确结果。\n\n参考文献[1] I Damgård, Pastro V , Smart N , et al. Multiparty Computation from Somewhat Homomorphic Encryption[C]// Springer-Verlag New York, Inc. Springer-Verlag New York, Inc. 2012.\n[2] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable two-party and multi-party secure computation. In STOC, pages 494–503, 2002.\n[3] Beaver. Efficient multiparty protocols using circuit randomization. In J. Feigenbaum, editor, CRYPTO, volume 576 of Lecture Notes in Computer Science, pages 420–432. Springer, 1991.\n[4] Z. Brakerski, C. Gentry, and V. Vaikuntanathan. (leveled) fully homomorphic encryption without bootstrapping. In ITCS, pages 309–325. ACM, 2012.\nhttps://mp.weixin.qq.com/s/uwUnRc6j_ZpMxd6Dfnv3-w\n​       https://mp.weixin.qq.com/s/mR847vF1Djb-aINJTaFKAA\n","slug":"MASCOT前置知识（二）","date":"2023-09-19T08:29:14.000Z","categories_index":"Crypto,多方安全计算,MASCOT","tags_index":"Crypto,Basic","author_index":"C4IN"},{"id":"e7f9c8c700d84e1b335913cf1672fdbf","title":"aurora主题的latex配置","content":"如何给aurora主题配置latex公式支持最近换了个主题，然后latex公式怎么搞都搞不好。找了好久终于找到了解决方法。\n进入博客根目录，下载hexo-renderer-kramed、hexo-math、hexo-filter-mathjax\nnpm install hexo-math --save\n## 卸载默认 markdown 渲染引擎 hexo-renderer-marked；若不卸载，会和新的引擎发生冲突（conflict）\n$ npm uninstall hexo-renderer-marked --save\n## 安装新引擎 hexo-renderer-kramed \n$ npm install hexo-renderer-kramed --save\n\n$ npm install hexo-filter-mathjax\n$ hexo clean\n然后修改kramed配置，解决冲突：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,\n\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n只要改这俩就行啦。\n然后在根目录下的_config.yml开启渲染：\n# MathJax Support\nmathjax:\n  tags: none # or 'ams' or 'all'\n  single_dollars: true # enable single dollar signs as in-line math delimiters\n  cjk_width: 0.9 # relative CJK char width\n  normal_width: 0.6 # relative normal (monospace) width\n  append_css: true # add CSS to pages rendered by MathJax\n  every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter\n  packages: # extra packages to load\n  extension_options: {}\n    # you can put your extension options here\n    # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail\n # MathJax\nmath:\n  engine: 'mathjax'\n  mathjax:\n    src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML\n在你的文章markdown文件中加入：\nmathjax: true\n\n然后试试：\n// inline \n$p=P\\left(A_{1}\\right)+P\\left(A_{2}\\right)+\\ldots+P\\left(A_{n}\\right)=p_{1}+p_{2}+\\ldots+p_{n}$\n\n// block\n$\n\\begin{aligned}\np &amp; =P\\left(A_{1} \\cup A_{2} \\cup \\cdots \\cup A_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1} \\bar{A}_{2} \\cdots \\bar{A}_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1}\\right) P\\left(\\bar{A}_{2}\\right) \\cdots P\\left(\\bar{A}_{n}\\right)\n\\end{aligned}\n$\n结果：\n行内公式 inline equation\n公式块\n\n参考链接：\nhttps://cps.ninja/2019/03/16/hexo-with-latex/\nhttps://github.com/auroral-ui/hexo-theme-aurora/issues/55\nhttps://github.com/next-theme/hexo-filter-mathjax\n","slug":"aurora主题的latex配置","date":"2023-09-17T12:02:13.000Z","categories_index":"","tags_index":"头疼的配置问题","author_index":"C4IN"},{"id":"67a2e1ac4586a101302bb0a481c51db5","title":"MASCOT前置知识（一）","content":"这几天开始看MASCOT，先学学里面提到的一些基础知识。\n\n通用哈希函数(Universal Hash Function)通用哈希函数是指从具有一定数学特性的散列函数族中随机选择一个散列函数（见下文定义）。这样，即使数据是由对手选择的，也能保证较低的预期碰撞次数。\n假设我们想把某一个全集映射到m个“区”中（记为 ）。通常哈希是都需要减少发生哈希碰撞的几率（碰撞集合数据 ），一个确定性哈希函数往往不能保证在敌手模型（ ）下不被敌手精确选择作为哈希映射的前象。为了解决这个问题，我们随机选取哈希函数族中的一个函数称为通用哈希族（Universal family），且\nhttps://en.wikipedia.org/wiki/Universal_hashing\n剩余哈希引理(Leftover Hash Lemma)如果敌手获得了n比特密钥中的t个比特，我们可以生成一个比特左右的密钥，保证敌手对该密钥相关的信息一无所知。\n准确来说，我们可以提取一个长度渐进于（的最小熵）的均匀随机分布的变量。换句话说，敌手对X有一定的了解，但是对提取得到的值几乎一无所知。我们又称它为隐私放大，这是MASCOT的核心之一。\n令是在上的一个随机变量，且。令为一个2-universal哈希函数，如果则对于在上的且与无关，我们能得到：其中且与无关。\n是的最小熵，用来衡量的随机性，最小熵需要永远小于等于香农熵。注意是正确猜测的可能性。因此，最小熵衡量猜测的难度。\n是与的统计距离。\n\n\n\n\n\n\n\n\n\n香农熵：由热力学的熵引入到信息论中。\n香农把随机变量X的熵值定义如下，其值域为在这里b是对数所使用的底)，通常是2,自然常数e)，或是10。当b = 2，熵的单位是bit；当b = e，熵的单位是nat)；而当b = 10,熵的单位是Hart。\n熵（信息论）-wiki)\n","slug":"MASCOT前置知识","date":"2023-09-16T05:30:58.000Z","categories_index":"Crypto,多方安全计算,MASCOT","tags_index":"Crypto,Basic","author_index":"C4IN"},{"id":"02610888fe553149eda2045d277295dd","title":"多方安全计算介绍","content":"多方安全计算安全多方计算(MPC)已经从20世纪80年代的一种理论发展成为今天构建真实系统的工具。在过去的十年中，MPC已经成为理论和应用密码学中最活跃的研究领域之一。\n安全多方计算(MPC)的目标是使一组互不信任的独立数据所有者或任何公共第三方能够联合计算依赖于他们所有私人输入的函数。MPC与外包计算的不同之处在于，所有协议参与者都是参与执行协议的数据所有者。\n\nMPC支持保护隐私的应用程序，其中多个互不信任的数据所有者合作计算一个函数。在分布式的多方安全计算（Secure Multi-Party Computation , SMPC）环境中,含有隐私输入的两方或者多方参与者希望协作和交互式地计算一个目标函数f\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right)=\\left(y_{1}, y_{2}, \\ldots, y_{n}\\right)，一旦计算完成，每一个参与者应该能够获取与之相对应的且不包含其他信息的输出。多方安全计算目的是构建一个安全协议，这个安全协议能允许多个互不信任的参与者在自己隐私输入上联合计算目标函数，同时确保输出的准确，甚至在面对不诚实行为时，能够保护和管控自己的隐私输入。\n\n\n\n\n\n\n\n\n\n\n\n姚氏百万富翁问题\n姚(1982)简单地介绍道:“两个百万富翁想知道谁更富有；然而，他们不希望无意中发现任何关于彼此财富的额外信息。”也就是说，目标是计算的布尔结果，其中是第一方的私有输入，是第二方的私有输入。\n\n拍卖安全问题\n在一次拍卖中，学习到的唯一出价信息是出价最高者的出价，显然可以得出所有其他出价都低于中标价，但无法得到其它竞标失败的出价。\n\n\n研究领域理论研究包括安全模型、可行性和复杂性等方面的研究。理论研究的目的是将来自理论研究的优雅的理论想法转化成解决现实世界安全问题的具体的SMPC协议。实用的多方安全协议注重于效率问题。SMPC理论协议涉及的研究和方法主要从计算成本、通信成本和交互轮数方面提高通用和特定协议的效率。\n面向应用的SMPC包括隐私集合计算、隐私保护机器学习、数据挖掘和安全基因组计算等领域的研究。\n所有这些协议都涉及到基本的构造块，如不经意传输、秘密共享、投币、同态加密、承诺方案、零知识证明等。这些构造块为理论和实用的SMPC奠定了基础。\nMPC的可行性在存在恶意的情况下依然可以安全地计算任何分布式计算任务。现在我们简要说明这些结果中最重要的部分，假设表示参与方的数量，表示可能被腐坏的计算方的数量的界限 (其中被腐坏方的身份未知)：\n\n对于 (即，当不到三分之一的参与方可能被腐坏时)，任何具有计算安全性的函数都可以实现具有公平性和有保证的输出的安全多方协议，假设一个具有认证信道的同步点到点网络，在信息论安全的前提下，假设信道也是私有的。\n对于 (即，在保证诚实多数的情况下)，对于任何具有计算和信息论安全性的函数，都可以实现具有公平性和保证输出的安全多方协议，假设各方也可以访问广播信道。\n对于(即当腐坏方的数量不受限制时)，可以实现安全的多方协议 (没有公平性或保证输出)。\n\n","slug":"多方安全计算基础","date":"2023-08-20T02:47:19.000Z","categories_index":"Crypto,多方安全计算","tags_index":"Crypto,MPC","author_index":"C4IN"},{"id":"2cbb891df5dd9e9d79cc9907faec0ead","title":"安洁莉卡&罗兰","content":"\n安洁莉卡最喜欢的诗\n\n痛苦啊，你便是我的唯一除了你，我皆无欲求痛苦啊，你忠实的陪伴我，直至现在也没有一丝改变当我的灵魂徘徊于深渊之底唯有你相伴在我身旁，守护着我我又怎能埋怨你呢痛苦啊，你绝不会从我身旁遁走我终于能表达对你的尊敬现在也认识到你的存在而你只是存于世，便那么美丽痛苦啊，你就像那从未离开我那贫苦的心之火炉旁的人一样比我那身为至爱的恋人还要多情我知道在我迈向死亡的那一天你会走进我内心的深处与我并排躺下\n\n小时候的罗兰，只有奶奶相伴。在奶奶的指导下，成为了都市里的一名收尾人。在千疮百孔的都市中，凭着“奇点”技术，人们克服了疾病，征服了大自然，却逐渐患上了心病，不再追求曾经炫目的梦想，任由自己的思想为”翼“所指导。在”翼“的庇佑下，巢中的羽过着安全、稳定的生活，而在巢之外的后巷，人们只为了活下去而活下去，人的生命根本不值一提，人们渴望着有朝一日能进入”翼“，能从眼前的地狱中解放。都市脆弱的秩序由收尾人来维持。这些收尾人或许受雇于巢，或许受雇于后巷势力，接手各种各样的工作，从送货到杀人，再到处理大型事件。在都市中，收尾人的工作机遇与危险并存，最忌讳的就是在收尾时产生情感。罗兰在查尔斯事务所中遇到了安洁莉卡。他来自后巷，而她来自翼的实验室。在一次次的生死中，两人相爱，并结了婚。罗兰兢兢业业干了那么多年，好不容易有了爱他的人，他们一定会很幸福不是……吗？\n\n\n\n\n\n\n\n\n\n“闯进我世界之人，最后成了我的全世界”\n“一码，归一码”\n早些年罗兰参加了烟霾战争，翼曾向他承诺，会优先安排巢的易居权。但，这是都市。翼玩了一次文字游戏，罗兰移居巢的梦想彻底破灭，只得住在相对安全的音之巷内。妻子怀孕了有了孩子，罗兰更加自责，害怕自己的妻子和孩子的安全会受到威胁。虽然没有住在巢中，安洁莉卡没有说什么，安洁莉卡非常爱罗兰，她看的透罗兰，她知道一旦出事罗兰便会怪自己。\n\n\n\n\n\n\n\n\n\n“说起来，那里的葱饼味道还不错？，回来的时候麻烦捎一个吧”“非常乐意为您效劳，在下去去就回”\n罗兰的老友奥利维耶打来通讯，说一个委托急缺人手，他便去帮忙了。等他带着妻子爱吃的葱饼回到家中时——只有坍塌的房子。一切都没了，他的妻子，与他的孩子，就这么没了。\n罗兰彻底崩溃了。\n\n\n\n\n\n\n\n\n\n“为什么，我那来之不易的幸福却能如此轻易地从我手中溜走……”\n“全都是我的错……”\n罗兰的世界破碎了。他开始调查实验室，屠杀了手指，向都市发起他最恶毒的诅咒。\n\n\n\n\n\n\n\n\n\n“越是沿往昔之路，尸山越发高耸。层峦叠嶂，不见前路”\n“不见前路。我仅是回首遥望。”\n墙对面传来的欢笑声，其中或许有属于我的风景，我遗落的风景。成团的漆黑独守空房。\n罗兰的故事，总给我一种触动。\n","slug":"Ruina","date":"2023-07-28T13:40:40.000Z","categories_index":"这都是些什么啊,Library of Ruina","tags_index":"闲","author_index":"C4IN"}]