[{"id":"030d8a1cfb3d1c00a80edaa1d841a1b0","title":"MASCOT前置知识（二）","content":"SPDZ框架摘要SPDZ是一种MPC计算的协议框架，基于同态加密、秘密共享等技术实现安全多方计算，相关内容引自参考文献[1].\n\nSPDZ主要包括两个阶段，离线阶段（预计算）主要基于同态加密生成在现阶段需要的参数，在线阶段主要基于秘密共享完成各种计算。\nSPDZ可以计算有限域中的任何计算。\nSPDZ 满足 UC 安全框架下的静态恶意敌手(static adaptive adversay)攻击模型，即 n 个参与方中，即使最多 n-1 个参与方恶意违反协议或者合谋。\nSPDZ使用Message Authentication Code (MAC)，检测参与方是否诚实地进行计算，MAC参数在离线阶段生成。\nSPDZ不检测哪个参与方为恶意参与方，在检测到协议被违反情况即停止协议运行而防止数据泄漏。\n\n安全模型安全多方计算安全模型一般采用Universally composable（UC）模型[2]，按照攻击者能力可以划分为半诚实、恶意参与者，按照恶意参与者的门限可以划分为多数诚实、多数恶意协议。\n按照攻击者能力：\n\n半诚实模型：各参与方在计算过程中完全遵从 MPC 协议，既不会违反协议篡改数据也不会多个参与方之间进行合谋。\n恶意模型：攻击者允许随意篡改协议，可以联合他人进行合谋攻击。\n\n按照攻击者门限：\n\n多数诚实：恶意参与者不超过总参与方一半。\n多数恶意：恶意参与者至多可以有个（总参与方为）。\n\nSPDZ协议满足Universally composable（UC）框架下的静态恶意敌手(static adaptive adversary)攻击模型，最多允许个恶意参与方。\n基本定义秘密分享共有两种表示方法和，第一种主要用于表示输入的秘密分享值，第二种则主要用于表示全局密钥和随机数等参数。\n$表示\">表示有限域中的值的秘密分享值表示方法为：\n\n\\langle a \\rangle := (\\delta,(a_1,\\cdots,a_n),(\\gamma(a)_1,\\cdots,(a)_n))其中，\n各参与方持有，是公开值，为全局MAC密钥。\n秘密分享值计算具有以下性质：\n\n\n\n\n\n\n\n\n\n\n\n\n其中\n表示的秘密分享值表示方法为：\n各参与方持有\n\n(\\alpha_i,\\beta_i,\\gamma(\\alpha)_1^i,\\cdots,\\gamma(\\alpha)_n^i)其中为各参与方的密钥，主要验证MAC密钥和随机数秘密分享值的MAC验证。\nMAC密钥MAC密钥全局MAC密钥秘密分享值表示方法为，由于每个参与方持有\n\n(\\alpha_i,\\beta_i,\\gamma(\\alpha)_1^i,\\cdots,\\gamma(\\alpha)_n^i)因此各参与方可通过验证MAC密钥。为了打开，参与方将发送给，校验是否成立。\n三元组及乘法运算加法计算相对直接，直接利用秘密分享值的性质，计算加法，即可得到结果：\n乘法计算需要借助三元组（Beaver Triple[3]），三元组在离线阶段生成，表示为，且满足。\n由于在实际生成三元组过程中可能会引入误差，因此需要额外“消耗”(sacrificing)一组三元组用于校验三元组。\n给定一三元组，设输入为则乘法可按一下方式计算：\n\n打开得到，\n打开得到，\n然后计算\n\n正确性验证：\n\n\\begin{align}\n\\lang x \\rang \\cdot \\lang y \\rang &= \\lang c \\rang +\\epsilon\\lang b \\rang + \\delta \\lang a \\rang +\\epsilon\\delta \\\\\n&=\\lang ab \\rang + (\\lang x \\rang - \\lang a \\rang)\\lang b \\rang+(\\lang y \\rang - \\lang b \\rang )\\lang a \\rang + (\\lang x \\rang - \\lang a \\rang )(\\lang y \\rang - \\lang b \\rang)\\\\\n&=\\lang ab \\rang + \\lang bx\\rang-\\lang ab \\rang +\\lang ay \\rang -\\lang ab \\rang+\\lang xy \\rang-\\lang ay \\rang - \\lang bx \\rang +\\lang ab \\rang\\\\\n&=\\lang xy \\rang\n\\end{align}SPDZ协议SPDZ协议主要包括离线阶段和在线阶段。\n\n离线阶段\n离线阶段需要用到同态加密技术，产生的辅助数据包括：\n\n多元乘法三元组的秘密分享值；\n随机数秘密分享值；\n全局MAC密钥。\n\n这些辅助信息和在线计算阶段的输入数据无关，因此可以提前进行计算。\n以全局MAC密钥​为例，介绍离线阶段生成参数过程：\n\n各参与方联合生成同态加密公钥和私钥，以 BGV 方案[4]为例，私钥和公钥具有线性特性，因此解密过程中各方可利用进行部分解密，然后把解密结果汇总得到最终明文结果，解密过程中不泄漏各自部分的私钥； \n各参与方生成随机数，然后利用进行同态加密得到密文(表示$$\\alpha_i的同态密文)，并将密文发送给其他参与方; \n各参与方汇总得到，利用私钥进行联合解密，联合解密过程中会加入一个随机数进行混淆，然后reShare得到。\n\n\n在线阶段\n\n初始化。准备全局MAC密钥，随机数秘密分享值，乘法三元组等参数。\n输入阶段。设参与方的输入为，向打开，然后广播，各参与方计算。输入阶段主要是将输入值分片，产生对应的秘密分享值。\n加法计算。设输入为，计算。 \n乘法计算。设输入为，则计算分为两步：\n使用三元组校验；\n计算。 \n\n\n输出阶段。再输出最终结果前，需要对中间值、结果进行MAC校验，SPDZ 协议 MAC 验证时为了提高效率，可以在打开多个秘密分享值后通过一次MAC批量校验。\n\n\n\n协议离线阶段离线阶段主要借助同态加密、、、协议实现，其中同态加密主要保证秘密共享的同态加法、乘法性质，协议主要将秘密值进行分割，进行加法秘密共享，协议主要生成形式的秘密共享值，协议主要生成形式的秘密共享值。\n同态加密同态加密方案未提出具体方案，可参考BGV[1]等同态加密方案（在后续SPDZ改进论文中，使用了一层的BGV方案）。\n协议协议主要输入同态加密密文（明文为），以及一个参数，若，则输出为（由参与方持有)，且有；若，则输出一个新的密文，新的密文仍然包含。\n1.各参与方随机选择，记。\n2.各参与方计算，并将结果发送给其他参与方。\n3.各参与方生成的零知识证明，并发送给其他参与方进行验证（零知识证明为一种密码协议，可以在不泄漏秘密值的情况下证明秘密值的正确性）。\n4.所有参与方计算， 。（PS+不一定是简单相加）\n5.所有参与方运行分布式解密算法，解密，得到。\n6.参与方计算，其他参与方计算。\n7.若，则所有参与方计算。\nP Bracket协议P Bracket协议输入为各参与方的秘密份额，以及一个公共的秘密份额（密文中包含），输出形式的秘密分享值。\n1.对于， 所有参与方计算；各参与方计算，因此各参与方得到了的秘密值份额。\n2.输出。\nP Angle协议P Angle协议输入为各参与方的秘密份额，以及一个公共的秘密份额（密文中包含），输出形式的秘密分享值。\n1.所有参与方计算；\n2.各参与方计算，因此各参与方得到了的秘密值份额。\n3.输出。\n离线阶段完整协议初始化\n所有参与方运行分布式密钥生成算法，得到公钥；\n各参与方生成； \n各参与方生成，记，为全局MAC密钥；\n各参与方计算并广播密文,，其中；\n各参与方使用零知识证明协议验证为正确；\n所有参与方计算，生成秘密分享值。\n\n生成随机秘密共享值\n各参与方生成，记；\n各参与方计算并广播密文，记； \n各参与方使用零知识证明验证密文的正确性；\n所有参与方计算。\n\n生成乘法三元组\n各参与方生成记，；\n各参与方计算并广播密文；\n各参与方使用零知识证明协议验证密文的正确性； \n所有参与方计算；\n所有参与方计算； \n所有参与方计算； \n所有参与方计算；\n所有参与方计算。\n\n在线阶段完整协议在现阶段主要完成计算以及中间值和结果的MAC校验等，基础计算主要包括加法、乘法等。\n在线阶段主要过程如下：\n\n初始化。准备全局MAC密钥，随机数秘密分享值、，乘法三元组等参数。\n输入阶段。设参与方的输入为，向打开，然后广播，各参与方计算。输入阶段主要是将输入值分片，产生对应的秘密分享值。\n加法计算。设输入为，计算。\n乘法计算。设输入为，则计算分为两步：\n使用三元组校验；\n计算。\n\n\n输出阶段。再输出最终结果前，需要对中间值、结果进行MAC校验，SPDZ 协议 MAC 验证时为了提高效率，可以在打开多个秘密分享值后通过一次MAC批量校验。\n\n\n设在此次验证 MAC 前已有个秘密分享值被打开，即有个MAC 未验证，记为，其中对应的秘密分享值为，需要先打开一个随机值，然后各参与方计算，最后各参与方计算；\n各参与方使用对和输出值进行“承诺”，“承诺”函数包括承诺阶段和打开阶段，承诺阶段对秘密值进行“混淆”，生成承诺值，并发送给验证方；打开阶段，发送方将秘密值发送给验证方，验证方使用秘密值（通常也会加入随机数）验证承诺值。“承诺”函数可由Paillier加密、离散对数、哈希等方法构造。\n打开全局MAC密钥。\n各参与方通过承诺函数，打开，然后所有参与方验证，若公式成立，则验证通过，即输出结果正确，否则，终止协议。\n打开最终结果前，需要对的承诺值进行验证。验证通过后，计算，然后验证，验证通过，则即为最终正确结果。\n\n参考文献[1] I Damgård, Pastro V , Smart N , et al. Multiparty Computation from Somewhat Homomorphic Encryption[C]// Springer-Verlag New York, Inc. Springer-Verlag New York, Inc. 2012.\n[2] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable two-party and multi-party secure computation. In STOC, pages 494–503, 2002.\n[3] Beaver. Efficient multiparty protocols using circuit randomization. In J. Feigenbaum, editor, CRYPTO, volume 576 of Lecture Notes in Computer Science, pages 420–432. Springer, 1991.\n[4] Z. Brakerski, C. Gentry, and V. Vaikuntanathan. (leveled) fully homomorphic encryption without bootstrapping. In ITCS, pages 309–325. ACM, 2012.\n","slug":"MASCOT前置知识（二）","date":"2023-09-19T08:29:14.000Z","categories_index":"Crypto,多方安全计算,MASCOT","tags_index":"Crypto,Basic","author_index":"C4IN"},{"id":"fc6c5ed894d2efb0a98271578a323f62","title":"词法分析","content":"词法分析词法分析是计算机科学中将字符序列转换为记号（token）序列的过程。代码被分割的过程就是词法分析的过程，而分割后得到的一个一个的单元，就称为token（记号）。\n\n特别需要注意的是，token是有类型区分的，不同类型的token也需要起着不同的作用。在不同的语言中，token类型也有差异，不过一般情况下，token的类型主要分为keyword关键字、Identifier标识符、operator、whitespace空白符等。\n\n状态转换图状态转换图是一张有限方向图。结点代表状态，用圆圈表示。状态之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入字符或字符类。一张转换图只包含有限个状态，其中有一个为初态，至少要有一个终态。\n\n含有回路的状态结对应一段由循环结构和if语句构成的程序，终态表示识别出某种单词符号，对应的语句为return(C,VAL)，C为单词种别，VAL为单词属性值。\n正则表达式假设为一个有限字母表，正则表达式可递归地定义：\n\n和是上的正则表达式，表示的集合分别为和\n如果a是字母表中的一个符号，那么a是上的正则表达式，它表示的集合为\n如果都是字母表上的正则表达式，那么、、也是字母表上的正则表达式，它们表示的集合分别是：。\n\n\n\n\n\n正则表达式\n表示的集合\n\n\n\n\n\n{a}\n\n\n\n{a, b}\n\n\n\n{ab}\n\n\n\n{00,01}\n\n\n\n{, a,aa, aaa, …}\n\n\n\n{01,001,0001,…}\n\n\n\n{ba,aaba,ababa,baba,…}\n\n\n\n\n运算律：\n\n化简规则\n一元运算符*具有最高的优先级，左结合\n\n.连接具有次高的优先级，左结合\n\n|的优先级最低，左结合\n\n\n\n\n\n\n\n\n\n化简(a)|((b)*(c))\n结果是a|b*c\n\n\n标识符的正规式(letter|_)(letter|digit|_)*\n状态转换图为：\n\n假设\n数字：digit=0|1|2| … |9\n字母：letter=a|b|c|…|z|A|B|C|…|Z\n正整数：digit digit*或digit+\n标识符：(letter|_) (letter|digit|_)*\n有限状态自动机（Finite Automaton, FA）M是一个五元组：\n\n：状态的非空有限集合。，称为的一个状态\n：输入字母表，输入字符串都是上的字符串\n：状态转移函数，\n表示：在当前状态为s，输入为a的时候，状态将转移到下一状态。成为的一个后继状态\n：，是的开始状态\n：，是的终止状态集合。，是的终止状态。\n\n\n\n即归纳为4个要素，即现态、条件、动作、次态。“现态”和“条件”是因，“动作”和“次态”是果。\n\n非确定的有限状态自动机（Non-deterministic Finite Automation, NFA）在状态q下,读取任意输入字符a,其状态将变成状态集合中的某一个状态，即。\nNFA中允许存在转换。初态可以是多个。\n确定的有限状态自动机(Deterministic Finite Automation, DFA)DFA-wiki\n在状态下,读取任意输入字符,其状态将变成唯一确定的状态，即，初态只能是一个。\n对于一个给定的DFA，存在唯一一个对应的有向图（但是严格意义上一个有向图不能确定出唯一一个DFA）。有向图的每个结点对应一个状态，每条有向边对应一种转移。习惯上将结点画成两个圈表示接受状态，一个圈表示拒绝状态。用一条没有起点的边指向起始状态。\n\n\n\n\n\n\n\n\n\n\n能被确定有限状态自动机识别的语言是正则语言。\n确定有限状态自动机是非确定有限状态自动机的一种极限形式。\n确定有限状态自动机在计算能力上等价于非确定有限状态自动机。\n没有接受状态列表并没有指定开始状态的确定有限状态机叫做转移系统或半自动机。\n\n例题：\n确定有限状态自动机，其能识别输入的字符串是否含有整数个0：\n\n\n\n\n\n\n状态转移表（定义状态转移函数）：\n\n对应的状态转移函数为：\n\n状态表示在输入的字符串中有偶数个0，而表示有奇数个0。在输入中1不改变自动机的状态。当读完输入的字符串的时候，状态将显示输入的字符串是否包含偶数个0。\n\n能识别的语言是 。用正则表达式表示为：(1*(01*0)*)*\n深入浅出理解有限状态机 - 知乎 (zhihu.com)\n","slug":"词法分析","date":"2023-09-18T04:21:25.000Z","categories_index":"","tags_index":"编译原理","author_index":"C4IN"},{"id":"e7f9c8c700d84e1b335913cf1672fdbf","title":"aurora主题的latex配置","content":"如何给aurora主题配置latex公式支持最近换了个主题，然后latex公式怎么搞都搞不好。找了好久终于找到了解决方法。\n进入博客根目录，下载hexo-renderer-kramed、hexo-math、hexo-filter-mathjax\nnpm install hexo-math --save\n## 卸载默认 markdown 渲染引擎 hexo-renderer-marked；若不卸载，会和新的引擎发生冲突（conflict）\n$ npm uninstall hexo-renderer-marked --save\n## 安装新引擎 hexo-renderer-kramed \n$ npm install hexo-renderer-kramed --save\n\n$ npm install hexo-filter-mathjax\n$ hexo clean\n然后修改kramed配置，解决冲突：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,\n\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n只要改这俩就行啦。\n然后在根目录下的_config.yml开启渲染：\n# MathJax Support\nmathjax:\n  tags: none # or 'ams' or 'all'\n  single_dollars: true # enable single dollar signs as in-line math delimiters\n  cjk_width: 0.9 # relative CJK char width\n  normal_width: 0.6 # relative normal (monospace) width\n  append_css: true # add CSS to pages rendered by MathJax\n  every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter\n  packages: # extra packages to load\n  extension_options: {}\n    # you can put your extension options here\n    # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail\n # MathJax\nmath:\n  engine: 'mathjax'\n  mathjax:\n    src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML\n在你的文章markdown文件中加入：\nmathjax: true\n\n然后试试：\n// inline \n$p=P\\left(A_{1}\\right)+P\\left(A_{2}\\right)+\\ldots+P\\left(A_{n}\\right)=p_{1}+p_{2}+\\ldots+p_{n}$\n\n// block\n$\n\\begin{aligned}\np &amp; =P\\left(A_{1} \\cup A_{2} \\cup \\cdots \\cup A_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1} \\bar{A}_{2} \\cdots \\bar{A}_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1}\\right) P\\left(\\bar{A}_{2}\\right) \\cdots P\\left(\\bar{A}_{n}\\right)\n\\end{aligned}\n$\n结果：\n行内公式 inline equation\n公式块\n\n参考链接：\nhttps://cps.ninja/2019/03/16/hexo-with-latex/\nhttps://github.com/auroral-ui/hexo-theme-aurora/issues/55\nhttps://github.com/next-theme/hexo-filter-mathjax\n","slug":"aurora主题的latex配置","date":"2023-09-17T12:02:13.000Z","categories_index":"","tags_index":"头疼的配置问题","author_index":"C4IN"},{"id":"67a2e1ac4586a101302bb0a481c51db5","title":"MASCOT前置知识（一）","content":"这几天开始看MASCOT，先学学里面提到的一些基础知识。\n\n通用哈希函数(Universal Hash Function)通用哈希函数是指从具有一定数学特性的散列函数族中随机选择一个散列函数（见下文定义）。这样，即使数据是由对手选择的，也能保证较低的预期碰撞次数。\n假设我们想把某一个全集映射到m个“区”中（记为 ）。通常哈希是都需要减少发生哈希碰撞的几率（碰撞集合数据 ），一个确定性哈希函数往往不能保证在敌手模型（ ）下不被敌手精确选择作为哈希映射的前象。为了解决这个问题，我们随机选取哈希函数族中的一个函数称为通用哈希族（Universal family），且\nhttps://en.wikipedia.org/wiki/Universal_hashing\n剩余哈希引理(Leftover Hash Lemma)如果敌手获得了n比特密钥中的t个比特，我们可以生成一个比特左右的密钥，保证敌手对该密钥相关的信息一无所知。\n准确来说，我们可以提取一个长度渐进于（的最小熵）的均匀随机分布的变量。换句话说，敌手对X有一定的了解，但是对提取得到的值几乎一无所知。我们又称它为隐私放大，这是MASCOT的核心之一。\n令是在上的一个随机变量，且。令为一个2-universal哈希函数，如果则对于在上的且与无关，我们能得到：其中且与无关。\n是的最小熵，用来衡量的随机性，最小熵需要永远小于等于香农熵。注意是正确猜测的可能性。因此，最小熵衡量猜测的难度。\n是与的统计距离。\n\n\n\n\n\n\n\n\n\n香农熵：由热力学的熵引入到信息论中。\n香农把随机变量X的熵值定义如下，其值域为在这里b是对数所使用的底)，通常是2,自然常数e)，或是10。当b = 2，熵的单位是bit；当b = e，熵的单位是nat)；而当b = 10,熵的单位是Hart。\n熵（信息论）-wiki)\n","slug":"MASCOT前置知识","date":"2023-09-16T05:30:58.000Z","categories_index":"Crypto,多方安全计算,MASCOT","tags_index":"Crypto,Basic","author_index":"C4IN"},{"id":"cb09ea597c4ce0f4355fa56a3ee4d067","title":"matlab基础入门","content":"matlab基础入门学数值计算学的（悲\n使用的是 MATLAB R2016a 版本。\n\n矩阵和数组矩阵运算是 MATLAB 最厉害的部分，其主要用于处理整个的矩阵和数组。所有 MATLAB 变量都是多维数组，与数据类型无关。矩阵是指通常用来进行线性代数运算的二维数组。\n创建创建时同一行（行向量）的元素之间用,或者空格隔开：\ntest = [1 2 3 4]\n输出：\n&gt;&gt; test = [1 2 3 4]\n\ntest =\n\n     1     2     3     4\n创建矩阵时行与行之间用;隔开：\ntest = [1,2,3; 4,5,6; 7,8,9]\n输出：\n&gt;&gt; test = [1,2,3; 4,5,6; 7,8,9]\n\ntest =\n\n     1     2     3\n     4     5     6\n     7     8     9\n还可以用ones, zeros, rand等函数创建矩阵：\nz = zeros(5,1)\n这将创建一个由0组成的列向量：\n&gt;&gt; z = zeros(5,1)\n\nz =\n\n     0\n     0\n     0\n     0\n     0\n其他函数的用法请查阅官方文档。\n运算对已定义的矩阵进行单一运算符的运算将处理矩阵中的所有值：\ntest + 10      % test和上面的一样\n输出\n&gt;&gt; test + 10\n\nans =\n\n    11    12    13\n    14    15    16\n    17    18    19\n使用单引号‘’转置矩阵：\ntest&#39;\n输出：\n&gt;&gt; test&#39;\n\nans =\n\n     1     4     7\n     2     5     8\n     3     6     9\n可以用*运算符进行标准矩阵乘法，这将计算行与列之间的内积。例如$A\\cdot A^{-1}=I$：\n\n\n\n\n\n\n\n\n\ninv()矩阵求逆函数\ntest*inv(test)\n输出：\n\n&gt;&gt; test = [1,2,7; 3,4,8; 5,6,10]\n\ntest =\n\n     1     2     7\n     3     4     8\n     5     6    10\n\n&gt;&gt; p = test * inv(test)\n\np =\n\n    1.0000   -0.0000    0.0000\n   -0.0000    1.0000    0.0000\n    0.0000   -0.0000    1.0000\n\n请注意，p不是整数值矩阵，MATLAB将数字存储为浮点值，算术运算可以区分实际值与其浮点表示之间的细微差别。使用format命令可以显示更多小数位数：\nformat long\n输出\n&gt;&gt; format long\n&gt;&gt; test * inv(test)\n\nans =\n\n   1.000000000000000  -0.000000000000003   0.000000000000002\n  -0.000000000000002   1.000000000000000   0.000000000000004\n   0.000000000000002  -0.000000000000012   1.000000000000004\n\n","slug":"matlab基础入门","date":"2023-09-11T00:56:02.000Z","categories_index":"编程,matlab","tags_index":"","author_index":"C4IN"},{"id":"e8805eec5bdd2acbc81f5c8e275b0c0a","title":"Java类和对象","content":"Java类和对象类的变量描述对象的属性，类的方法体现对象的行为。封装在类中的这些数据的变量和方法，为对象的创建提供了模板。对象之间的交互作用是通过对象的消息机制实现的。所谓消息是对象对其他或者自身方法的访问，一个消息的产生就是一个对象方法的调用。类和对象是面向对象程序设计中的基本概念，也是编程方法的基础。类就是Java的执行单位。Java运行的就是Java类本身。\nOOP的最重要的好处之一是对数据和操作该数据的代码的封装，通过类来完成封装性。在创建一个类时，你正在创建一种新的数据类型，不但要定义数据的属性，也要定义操作数据的代码。方法定义了对该类数据相一致的控制接口。通过类的方法来使用类，而没有必要担心它的实现细节或在类的内部数据实际上是如何被管理的。既然细节被隐蔽，当需要时，它的内部工作可以被改变。只要你的代码通过类的方法来使用它，内部的细节可以改变而不会对类的外部带来负面影响。\n\n对象对象是现实世界事物的模型化。用变量来表示状态，用方去来实现行为。对象的变量组成了对象的中心或核，而方法是围绕在变量四周的。\n封装:某一对象的变量对程序中的其它的对象而言是隐藏的，它是在这个对象方法的保护监理之下。\n\n消息消息是软件对象之间相互作用和互相联系。对象的行为由方法来实现，消息传递是对象之间进行交互的主要方式。\n\n接收消息的对象(目标对象)\n接收者采用的方法(目标方法)\n方法所需传递的参数\n\n类类定义了对象的类型。包括对象内部的数据，它是对象的寺性，和对象对自己的数据上的操作功能。因此类就是对象的模板。类是某种对象共有的状态和行为的原 型。一个类可以有许多的对象，每一个对象都是这个类的一个实例，它们也就都具有相同的特征。\n类的创建一个类包括三个部分：\n\n类声明\n\n类成员\n\n类的构造器（方法）\nclass &lt;Declaration&gt;&#123;\n\n    &lt;classBody&gt;\n\n&#125;\n\n\n类的一般声明形式：\n[public] class &lt;clsName&gt; extends &lt;supCls&gt; implements&lt;intf&gt;\nclass是表示创建类的关键字\n&lt;clsName&gt;是Java合法标识符[public]是可选项，表示该类是public类;类的可选项还有abstract, final等等;extends &lt;superCls&gt;则是继承性表示，该类继承了类&lt;superCls&gt;\nimplements &lt;intf&gt;则是对接口实现表示，该类实现了接口&lt;intf&gt;\n类体定义\n成员变量：在类中创建的变量，表示对象属性\n成员方法：类的方法表示对象的行为或能力\n类的构造器（方法）：为创建类的实例所使用\n\nclassDeclaration &#123;\n    &lt;memberVariableDeclaration&gt;\n    &lt;memberMethodDeclaration&gt;\n    &lt;classStructorDeclaration&gt;\n&#125;\n成员变量\n在类中创建的变量，表示对象属性\n\n作用域在类中是全局的，能被类中所有方法所访问\n\n在创建时有初始化值\n&lt;type&gt; variableList = initialValue;\n\n\n常用修饰符：\n\n访问权限控制：\npublic：公开，谁都能访问\nprotected：\nprivate：\n\n使用限制\nfinal：\n使用修饰符final修饰的变量就像常量一样地使用，称其为常量符号。常量符号数据只能读取，不能改变。通常常量符号标识符全用大写字母，单词间用“_”分隔。\nfinal int MAX_MONTH = 12;\nfinal int MAX_DAY = 31;\nfinal int MAX_WEEK = 7;\nstatic：\ntransient：\nvolatile：\n\n\n成员方法[accessControl] returnType methodName(paraList)\n[accessControl]是可选项，为访问控制修饰符，限定访问权限。\nreturnType是方法返回数据类型，它表示方法返回时返回数据的类型。\nmethodName是方法名，它是Java合法标识符\nparaList是方法参数列表，表示方法调用时所带参数。称为形式参数。\nint getMax(int a, int b)\nvoid setData(int x, int y)\n方法体由语句及语句块组成，包含有：\n\n局部变量声明\n流程控制语句\n语句块\nreturn（看情况）\n\n方法调用时的参数传递\n方法在被调用时，其参数的数据传递是值传递，即实际参数传值给形式参数。\n形式参数是简单类型，在方法调用时，实际参数将其存储单元的数据赋值给形式参数。\n形式参数是引用类型，在方法中，引用类型的参数没有发生引用的改变，则形式参数对引用中的变量值改变自然会影响到实际参数引用中变量的值。\nPoint pi=new Point(1,2);void setRefer1(Point p)    &#123;\n    p.x = 10;\n    p.y = 20;\n&#125;\nsetRefer1(pi)\n参数p是引用类型，其成员的x,y值发生改变，会影响调用的实参，即函数结束后成员x和y的值改变。\nPoint pi=new Point(1, 2)void setRefer2(Point p) &#123;\n    p= new Point();\n    p.x = 10;\n    p.y = 20;\n&#125;\nsetRefer2(pi)\n参数p是引用类型，改变引用，其变量x,y值发生改变，不会影响调用的实参，函数调用结束后pi的成员值不变。\n方法过载在同一个类中创建的具有相同方法名，但是参数不同的方法。方法过载中的方法由调用时的实参决定调用的方法是哪个。\n\n数量不同\n数量相同，但是对应的类型不同\n\n类的构造方法每一类都有自己的构造方法，或者称为类的构造器。构造方法是用来创建一个类的实例的。\n构造方法使用类名作构造方法名，构造方法具有有参数和语句体，但没有返回类型的声明。如果有返回类型声明，则此方法就再不是构造方法，而成为一个一般的成员方法。构造方法不是类的成员方法，所以不能用对象调用它。构造方法的调用是由new运算符实现。\n\n\n\n\n\n\n\n\n\n\n构造方法返回的是这个类的实例的引用\n\n构造方法中的语句实现对成员变量的初始化\n\n构造方法的方法过载。一个类可以有多个构造方法\n\n构造方法之间通过this()形式相互调用\n\n\n默认构造方法：指不带参数的构造方法，该方法可以有语句，也可以没有语句\n非默认构造方法：指带参数的构造方法\n类创建时没有创建构造器，则在编译时编译器自动为该类添加一个默认构造器，即没有创建构造器的类可以直接使用默认构造器。\n类创建时如果有任何构造器被创建，则在编译时编译器不再为该类创建默认构造器。即创建了构造方法的类，不自动有一个默认的构造方法，或者说默认构造器失效，除非也创建一个不带参数的构造器。\n类成员和实例成员类成员见另一篇文章 ’static的用法‘。\n实例成员：通过创建实例才能访问和使用的成员，创建对象，由对象访问，如p.x=10。实例成员不能用类名直接访问，比如Point.x访问是不合法的。\n对象创建和使用对象：是一个变量，它的存储开销是一个地址存储单元。\n实例：是在存储空间分配的存储堆。是垃圾回收的目标。\n引用：对象通过它存储的实例的起始地址对实例实现访问。\n对象的生命周期:创建、使用和销毁三个阶段。\n创建:分两步。\n\n声明:\nPoint p;\n\n实例化:通过new运算符调用构造器，通过赋值=对这个实例引用。\np = new Point();\n\n对象使用：\n通过对象名对成员的访问，注意这里是对象名不是类名：\np.x=100;\nint temp = p.getData();\n\n销毁：\n垃圾回收:实例开销的回收。\n由JVM自动完成。\n调用finalize()方法处理。\nJava程序运行时系统通过垃圾收集，周期性地释放不再被对象引用所占用的内存，完成对象的清除.\nfinalize方法：\nJava在对象作为垃圾被收集前，自动调用对象从Object类继承来的finalize()方法，清除自己所占用的资源。该方法声明的格式:\nprotected void finalize() throws throwable &#123;\n//clean up code for this class\n    super.finalize();\n&#125;\n\n\nclass Point &#123;\n    int x,y;\n    Point(int a, int b) &#123;\n        x = a;\n        y = b;\n    &#125;\n    Point() &#123; \n        this(0.0);\n    &#125;\n    void setData(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n        &#125;\n&#125;\n","slug":"Java类和对象","date":"2023-09-05T06:23:22.000Z","categories_index":"编程,java","tags_index":"","author_index":"C4IN"},{"id":"ee304ea14cdfef400724bb1ab6bff757","title":"java异常处理","content":"Java异常处理在Java中，异常处理是一种机制，用于处理程序运行时可能出现的错误或异常情况，以便程序能够优雅地处理这些问题而不会崩溃。\n\ntry-catchtry 用于包装可能会引发异常的代码块，而 catch 用于捕获并处理异常。在 try 块中放置的代码如果发生异常，程序将跳转到匹配的 catch 块来处理异常。可以使用多个 catch 块来捕获不同类型的异常，以便根据异常类型采取不同的处理措施。\nfinally 块用于包装一些无论是否发生异常都必须执行的代码。通常在这里执行资源的释放或清理操作。\n throw 关键字用于手动抛出异常，通常在自定义异常类中使用。\ntry &#123;\n    // 可能引发异常的代码\n&#125; catch (ExceptionType e) &#123;\n    // 处理异常的代码\n&#125; finally &#123;\n    // 是否发生异常都必须执行的代码\n&#125;\n异常类（Exception）异常是由Java提供的预定义异常类或自定义的异常类表示的。例如，ArithmeticException 表示数学运算异常，IOException 表示输入输出异常等。\n我们也可以自定义异常类：\npublic class CustomException extends Exception &#123;\n    public CustomException(String message) &#123;\n        super(message);\n    &#125;\n&#125;\n示例代码这是一次java作业的代码：\n\n\n","slug":"java异常处理","date":"2023-09-03T02:32:19.000Z","categories_index":"编程,java","tags_index":"","author_index":"C4IN"},{"id":"af5b7b140c3f656ff60a269d72084da5","title":"java流程控制和数组","content":"Java语言中的流程控制语句提供了控制程序执行顺序的手段。流程控制是程序代码的重要部分。流程控制语句分为：分支语句、循环语句、异常处理语句和跳转语句。\n\n\n分支语句if-else\nif (condition1) &#123;\n    // 如果 condition1 为真，执行这里的代码块\n&#125; else if (condition2) &#123;\n    // 如果 condition2 为真，执行这里的代码块\n&#125; else if (condition3) &#123;\n    // 如果 condition3 为真，执行这里的代码块\n&#125; else &#123;\n    // 如果以上条件都不满足，执行这里的代码块\n&#125;\nswitchswitch (intexpression)&#123;\ncase int1:\n    &lt;statement or block (1)&gt;\n    break;\ncase int2:\n    &lt;statement or block (2)&gt;\n    break;\ndefault:\n    &lt;statement or block(d)&gt;\n    break;\n&#125;\n循环语句whilewhile (expressBool)&#123;\n    statements;\n    [iteration;]\n&#125;\ndo-whiledo &#123;\n    statements;\n    [iteration;]\n&#125;while (expressBool);\n执行顺序是：\n\n执行初始化initalization(如果有);执行循环体statements\n先执行迭代部分iteration(如果有)，再计算表达式expressBool的值\n若expressBool值为true，则返回到2\n若expressBool值为false，则终止do-while循环\n\nforfor(initalize; condit; iterat) &#123;\n    statements;\n&#125;\nbreak, continuebreak语句用于循环结构中，当程序执行break语句时，程序流程就结束循环break语句也可以带语句标记，它的作用是结束该语句标记的语句块。break语句使用格式如下:\nbreak [outerLabel];\ncontinue语句用于循环结构中，当程序执行contiune语句时，程序流程就结束本次循环，充当了循环体的最后一条语句作用。continue语句也可以带语句标记，它的作用是结束该语句标记的外层循环的本次循环。continue语句使用格式如下:\ncontinue [outerLabel];\n\n使用标签 outerLoop 跳出外层循环，从而结束整个循环的执行。\nouterLoop:\nfor (int i = 0; i &lt; 5; i++) &#123;\n    innerLoop:\n    for (int j = 0; j &lt; 5; j++) &#123;\n        if (i * j &gt; 6) &#123;\n            break outerLoop; // 使用标签跳出外层循环\n        &#125;\n        System.out.println(i + &quot; * &quot; + j + &quot; = &quot; + (i * j));\n    &#125;\n&#125;\n\n数组在Java中，数组是引用类型。数组类型是一种有序数据的集合，数组中在每一维上的元素具有相同的数据类型。数组通过数组名和它的下标对数组元素访问，数组元素的下标不能越界。数组是一个对象，数组声明不能创建对象本身，而创建一个引用。数组元素由new语句或数组初始化软件动态分配。\n数组声明Java的数组声明采用与C语言类似的形式。数组可分为一维数组和多维数组。它们的声明的形式为:\ntype arrayName[][].….[];\n或另一等价形式:\ntype[][..][] arrayName;\ne.g.\nint count[];            //  一维整型数组count\nchar ch[][];            //  二维字符型数组ch\nfloat[] fNum;            //  一维浮点型数组fNum\n数组实例化在Java语言中，数组的声明是不能确定数组大小。数组的实例化即存储单元的分配是由new运算符实现。\narrayName = new type [arraySize1][][]…[];\n数组通过数组名和它的下标对数组元素访问，数组元素的下标不能越界。数组实例化示例:\nint[]a = new int[3];\n数组a有元素：a[0], a[1], a[2]，三个元素的值都为0。\n数组在创建时，也可显式初始化。例: \nint[]a = &#123;1,2,3&#125;;\n数组a的三个元素的值分别为1，2，3。\n数组实例化后就有了确定的元素,每个数组有一个属性length,其值就是这个数组的元素的数量。例: a.length的值为3。\n多维数组Java编程语言没有提供多维数组。它是通过创建数组的数组(和数组的数组的数组)。数组通过数组名和它的下标对数组元素访问，数组元素的下标不能越界。数组是一个对象，数组声明不能创建对象本身，而创建一个引用。数组元素由new语句或数组初始化软件动态分配。\n虽然在声明数组的格式中，允许方括号在数组名的左边或者石边，但这种方式不适合数组句法的其它部分，必须首先将低位维初始化，再能对它后面的各位依次初始化。利用对每维元素的分步初始化，可以创建非知矩形数组的数组。\n// 声明一个三维整数数组\nint[][][] threeDArray = new int[2][3][4];\n\n// 初始化三维数组\nthreeDArray[0][0][0] = 1;\nthreeDArray[0][0][1] = 2;\n// ...\n\n// 声明并初始化三维数组\nint[][][] anotherThreeDArray = &#123;&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;, &#123;&#123;5, 6&#125;, &#123;7, 8&#125;&#125;&#125;;\n\n// 访问三维数组\nint value = threeDArray[1][2][3]; // 访问第二维度的第三行第四列的元素\n字符串字符串是一串字符组成的数据，并用&quot;&quot;包括起来。字符串常量是String类型的对象，类String是Java语言的基础数据类型，它具有一定的特殊性。Java编译器在对字符串数据与其它类型数据使用“+”运算符连接操作编译时，总是首先将其它类型数据转换为字符串类型，然后再进行字符串连接。\n&quot;Age: &quot;+18 == &quot;Age: 18&quot;\n相关方法char charAt(int where)\nvoid getChars(int sourceStart, int sourceEnd, char target[], int targetstart)byte[] getBytes()\nchar[] tocharArray( )boolean equals(Object str)\nboolean equalslgnorecase(String str)boolean startsWith(String str)\nboolean endsWith(String str)int indexof(int ch)\nint lastindexOf(int ch)\nstring substring(int startIndex)\nstring substring(int startIndex, int endIndex)\n字符串与基本数据的转化：\nString to lnteger\npublic static int parselnt(String s)\nlnteger to String\npublic static String valueOf(int n)\nStringBuffer在Java中，StringBuffer 是一个用于操作可变字符串的类。与 String 不同，StringBuffer 允许你修改字符串的内容，而不必创建新的字符串对象。这对于需要频繁修改字符串的情况非常有用，因为 String 对象是不可变的，每次修改都会创建一个新的字符串对象。\n以下是 StringBuffer 类的基本用法和一些常用方法：\n创建 StringBuffer 对象：\njavaCopy code\nStringBuffer sb = new StringBuffer();\n或者使用初始字符串创建 StringBuffer 对象：\njavaCopy code\nStringBuffer sb = new StringBuffer(&quot;Hello&quot;);\n常用方法：\n\nappend(String str)： 将指定的字符串追加到 StringBuffer 的末尾。\n\njavaCopy code\nsb.append(&quot;World&quot;);\n\ninsert(int offset, String str)： 在指定位置插入字符串。\n\njavaCopy code\nsb.insert(5, &quot;Java&quot;);\n\ndelete(int start, int end)： 删除指定范围内的字符。\n\njavaCopy code\nsb.delete(0, 5); // 删除前五个字符\n\ndeleteCharAt(int index)： 删除指定位置的字符。\n\njavaCopy code\nsb.deleteCharAt(5); // 删除第六个字符\n\nreplace(int start, int end, String str)： 用新的字符串替换指定范围内的字符。\n\njavaCopy code\nsb.replace(0, 5, &quot;Hola&quot;); // 将前五个字符替换为 &quot;Hola&quot;\n\nlength()： 返回当前字符串的长度。\n\njavaCopy code\nint len = sb.length();\n\ntoString()： 将 StringBuffer 对象转换为 String 对象。\n\njavaCopy code\nString result = sb.toString();\n","slug":"java流程控制和数组","date":"2023-09-01T12:49:52.000Z","categories_index":"编程,java","tags_index":"java","author_index":"C4IN"},{"id":"a8aa18bf0cb5c42542c071a3bedb754a","title":"java语言基础","content":"我超，java\n\nJava程序的基本结构Java语言的源程序是一个或多个以.java为扩展名的文件，Java源程序中可包含三个基本部分:\n\n一个包声明package语句(可选)\npackage database;\n\n包是类和接口的集合，即为类库\n用类库管理类，方便对类和接口管理，减少类名、接口名之间的重名问题\nJava的类都包含在类库中,package语句为类、接口(或者说是字节码文件)来指定所属的类库(包)。\n在一个源程序中，只能有一个包声明语句，且是程序的第一条语句。\n\n\n任意数量的引入import语句(可选)\nimport java.applet.Applet;\n\n源程序中可以有任意条import引入语句\n\n当源程序在编译时，会将需要的在引入语句中的类引入到程序中\n\nimport语句在包语句后，所有类或接口之前import语句有两种形式:\n import &lt;packagename&gt;.&lt;classname&gt;        // 引入&lt;classname&gt;\n import &lt;packagename&gt;.*                    // 引入所有类\n\n\n\n类和接口声明\nclass Hello&#123; ... &#125;\ninterface DataCollect&#123; ...&#125;\n\n类和接口是程序的基本组成单元\n类是由成员变量和成员方法等组成，表示了对象的基本属性和行为\n接口表现了对象所具有的行为规范\n源程序中至少有一个类或接口创建\n\n\n\n在一个源程序中，只能有一个包声明语句，而源程序中可以有任意个import引入语句。当源程序在编译时,对不需要引入的类不会引入。类的体是由成员变量和成员方法等组成的，在一个Java源程序中，只能有一个类可以被声明为public(公共)类。若某个类中有main()方法，则声明该类为public类。若想创建多个public类，应该为每一类单独地创建一个源程序。应该用public修饰的类，即公共类作为源程序的文件名，并需要注意的是文件名要和该类名的大小写保持一致。\n在应用程序Application中，main()方法是程序运行的入口：\npublic static void main(String args[])\n比如九九乘法表：\npublic class MultiplicationTable &#123;\n    public static void main(String[] args) &#123;\n        for (int i = 1; i &lt;= 9; i++) &#123;\n            for (int j = 1; j &lt;= i; j++) &#123;\n                System.out.print(j + &quot; * &quot; + i + &quot; = &quot; + (i * j) + &quot;\\t&quot;);\n            &#125;\n            System.out.println();\n        &#125;\n    &#125;\n&#125;\n\nJava中的注释和C/C++一样，但在javadoc多了一种注释：\n/** */\nJava字符集符号集符号是构成程序的基本单位。Java采用的是Unicode码，又称统一码字符集，使用16位存储空间，支持多种语言，更具有国际化特性。当Unicode中的高8位为0时，则低8位的编码与ASCII码相同。ASCII码是用8位存储空间。\n关键字\n48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。\n2个保留字（现在没用以后可能用到作为关键字）：goto、const。\n3个特殊直接量：true、false、null。 \n\n\n\n\n\n关键字\n意思\n备注，常用\n\n\n\n\npublic\n公有的\n可跨包，（默认选择）\n\n\nprotected\n受保护的\n当前包内可用\n\n\nprivate\n私有的\n当前类可用\n\n\nclass\n类\npublic class A()&#123;&#125; 花括号里有已实现方法体，类名需要与文件名相同\n\n\ninterface\n接口\npublic interface B()&#123;&#125; 花括号里有方法体，但没有实现，方法体句子后面是英文分号“:”结尾\n\n\nabstract\n声明抽象\npublic abstract class C()&#123;&#125; 介于类与接口中间，可以有也可以没有已经实现的方法体\n\n\nimplements\n实现\n用于类或接口实现接口public class A interface B()&#123;&#125;\n\n\nextends\n继承\n用于类继承类 public class A extends D()&#123;&#125;\n\n\nnew\n创建新对象\nA a=new A(); A表示一个类\n\n\nimport\n引入包的关键字\n当使用某个包的一些类时，仅需类名 然后使用ctrl+shift+o或者选定类名（类或属性或方法）按住ctrl+单击 即可自动插入类所在的包。如：JFrame 快捷键之后自动加入import javax.swing.JFrame;\n\n\npackage\n定义包的关键字\n将所有有关的类放在一个包类以便查找修改等。如：package javake.flycat.draw002;\n\n\nbyte\n字节型\n8bit\n\n\nchar\n字符型\n16bit\n\n\nboolean\n布尔型\n—（注意，这里的值只能为true和false，不能是0和1）\n\n\nshort\n短整型\n16bit\n\n\nint\n整型\n32bit\n\n\nfloat\n浮点型\n32bit\n\n\nlong\n长整型\n64bit\n\n\ndouble\n双精度\n64bit\n\n\nvoid\n无返回\npublic void A(){}  其他需要返回的经常与return连用\n\n\nnull\n空值\n\n\n\ntrue\n真\n\n\n\nfalse\n假\n\n\n\nif\n如果\nif(){} 如果小括号里面怎么怎么样 花括号就怎么怎么样\n\n\nelse\n否则，或者\n常与if连用，用法相同\n\n\nwhile\n当什么的时候\nwhile 怎么样就do什么  while(){}\n\n\nfor\n满足三个条件时\nfor ( ; ; ){}\n\n\nswitch\n开关\nswitch(表达式) { case 常量表达式1:语句1; …. case 常量表达式2:语句2; default:语句; }\n\n\ncase\n返回开关里的结果\n\n\n\ndefault\n默认\n\n\n\ndo\n运行\n长与while连用\n\n\nbreak\n跳出循环\n\n\n\ncontinue\n继续\n中断本次循环，并开始下一次\n\n\nreturn\n返回\nreturn 一个返回值类型\n\n\ninstanceof\n实例\n一个二元操作符，和==，&gt;，&lt;是同一类的。测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据\n\n\nstatic\n静态的\n属性和方法都可以用static修饰，直接使用类名.属性和方法名。 只有内部类可以使用static关键字修饰，调用直接使用类名.内部类类名进行调用。  static可以独立存在。静态块\n\n\nfinal\n最终的不可被改变的\n方法和类都可以用final来修饰  final修饰的类是不能被继承的  final修饰的方法是不能被子类重写。常量的定义：final修饰的属性就是常量。\n\n\nsuper\n调用父类的方法\n常见public void paint(Graphics g)&#123;super.paint(g); ··· &#125;\n\n\nthis\n当前类的父类的对象\n调用当前类中的方法（表示调用这个方法的对象）this.addActionListener(al):等等\n\n\nnative\n本地\n用于表示一个方法是由本地代码（通常是由其他编程语言如C或C++编写的）实现的，使用本地方法可以在Java程序中调用底层操作系统或其他外部库中的功能。这在需要与底层系统交互或利用现有C/C++库的情况下很有用。\n\n\nstrictfp\n严格,精准\n\n\n\nsynchronized\n线程,同步\n用于同步代码块\n\n\ntransient\n短暂\n表明该变量在对象的序列化过程中应该被忽略，不会被持久化保存被 transient 修饰的变量不会被写入到输出流，因此在反序列化时也不会恢复该变量的值。\n\n\nvolatile\n易失\n用于修饰变量以保证线程可见性\n\n\ncatch\n处理异常\n1.try+catch 程序的流程是：运行到try块中，如果有异常抛出，则转到catch块去处理。然后执行catch块后面的语句2.try+catch+finally程序的流程是：运行到try块中，如果有异常抛出，则转到catch块,catch块执行完毕后，执行finally块的代码，再执行finally块后面的代码。如果没有异常抛出，执行完try块，也要去执行finally块的代码。然后执行finally块后面的语句3.try+finally程序的流程是：运行到try块中,如果有异常抛出的话，程序转向执行finally块的代码。那末finally块后面的代码还会被执行吗？不会！因为你没有处理异常，所以遇到异常后，执行完finally后，方法就已抛出异常的方式退出了。这种方式中要注意的是，由于你没有捕获异常，所以要在方法后面声明抛出异常\n\n\ntry\n捕获异常\n\n\n\nfinally\n有没有异常都执行\n\n\n\nthrow\n抛出一个异常对象\n一些可以导致程序出问题的因素,比如书写错误,逻辑错误或者是api的应用错误等等. 为了防止程序的崩溃就要预先检测这些因素,所以java 使用了异常这个机制.在java中异常是靠 “抛出” 也就是英语的”throw” 来使用的,意思是如果发现到什么异常的时候就把错误信息 “抛出”\n\n\nthrows\n声明一个异常可能被抛出\n用于指定该方法可能抛出的异常类型。当一个方法可能引发异常，但实际的异常处理将由调用该方法的代码处理\n\n\nenum\n枚举，列举型别\n\n\n\nassert\n断言\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrue, false和null为小写,不能大写。严格地讲，它们不是关键字，而是一种值。但是仍然把它们作为关键字使用。sizeof不是关键字goto、const不是关键字，是保留字关键字不能作为一般的标识符使用，即一般的标识符(变量名、类名、方法名等)不能与其同名。\n标识符\n取名规则\n必须由字母、下划线或美元符开头的\n并由字母、数字、下划线和美元符组成的\n不能与关键字同名\n\n\n\nJava数据类型\n简单数据类型\nJava语言数据中的数值类型都是有符号(正负号)的，在贮存数值类型的数据时，其最高位用来表示数据的正负号。简单类型的变量被声明时，存储空间也同时被分配。该贮存空间只占用一个单一贮存单元。对简单类型变量访问则直接可以得到它的数据。\n引用数据类型引用类型(数组、class或interface)声明变量时，是不会为变量(即对象)分配存储空间。它们声明的变量不是数据本身，而是数据的引用(reference)，需用new运算符来为引用类型的变量分配贮存空间;引用：类似C/C++中的指针，但又不同于C/C++中的指针，它的引用必须由Java的虚拟机创建和管理。Java语言本身不支持指针;引用类型变量的值是一个数据的引用(即地址)。它是对占有由多个贮存单元构成的贮存空间的引用。引用类型的变量通过点””运算符访问它的成员。\n常量与变量常量常量是指直接用于放入程序中的固定不变的值。它的表现形式有两种:数值和字符。\n\n整数型常量\nJava整数类型常量有三种形式:十进制、八进制、十六进制。\n十进制整数是由不以0开头，0~9数字组成数据:12;\n八进制整数是由以0开头，0~7数字组成的数据：012;\n十六进制整数是由以0x或0X开头，0～9数字及A～F的字母组成的数据:0x12AB。\n整型数常量均为int类型，除非在其后有字母“L”来表示是长整型long的值。\n\n浮点型常量\n浮点数类型有float单精度浮点数,double双精度浮点数。在数字后面带有字母F或f (float) 、D或d (double)分别表示单/双精度的浮点数值。在数值后面不带有任何大小写字母f或d时，表示为double数值。\n\n\n\n\n\n\n\n\n\n例如:如下形式表示的单/双精度型数值3.12E20 一个带指数的大浮点数值1.567F                                                一个单精度浮点数值42.314E+307D                                  一个带指数的双精度浮点数值。\n\n字符型常量\n由单引号”包括的单个Unicode字符例: ‘A’, 9’,’@’16位无符号在字符型常量中，也有用带””来表示的特殊字符，是其中的一些不可显示或有特殊意义的字符。例:’\\n’, ‘\\t’\n\n\n布尔型常量\n布尔型关键字是boolean，它有两个常量false和true,以表示“假”和“真”两种状态。要注意的是在整型类型和boolean类型之间不能相互转换。\n\n\n变量变量是语言编程中用来标识存储地址的名称，程序通过变量名访问所标识贮存空间的数据。变量必须显式地声明变量的类型。遵循“先声明、后使用”原则。\n变量的分类及作用域依变量创建所在处可分为：\n\n成员变量\n方法的变量(包含参数)\n语句块的变量\n异常处理的变量\n\n依变量作用域可分为：\n\n全局变量:成员变量\n\n全局变量 (Global Variables):\n在Java中，通常没有严格意义上的全局变量。Java中的成员变量（Instance Variables 和 Static Variables）是与类或对象关联的变量，它们在类级别声明，但在对象级别使用。\n\n作用域（Scope）： 成员变量的作用域在整个类内，实例变量对于每个类的对象实例是独立的，而静态变量对于整个类是共享的。\n生命周期： 成员变量的生命周期与类或对象的生命周期相关联。实例变量的生命周期与对象的生命周期相同，而静态变量的生命周期与类的生命周期相同。\n可见性： 成员变量可以被类内的所有方法访问，它们对于整个类的代码都是可见的。实例变量对于每个对象的方法都是可见的，静态变量对于整个类的所有对象和方法都是可见的。\n\n\n\n\n局部变量:方法的变量(包含参数)\n\n局部变量 (Local Variables):\n作用域（Scope）： 局部变量的作用域仅限于声明它们的代码块、方法、或构造方法内部。它们只能在这些地方被访问和使用，超出这些范围就无法访问。\n生命周期： 局部变量的生命周期仅限于包含它们的代码块的执行期间。一旦代码块执行完毕，局部变量就会被销毁，其内存被释放。\n可见性： 局部变量通常用于保存临时数据或方法内部的中间结果。它们对于方法外的其他代码块是不可见的，因此具有良好的封装性。\n\n\n\n\n\n\n运算符和表达式运算符单目(一元)运算符：有一个操作数\ni++\n双目(二元)运算符：有两个操作数\na + b\n三目(三元)运算符：有三个操作数\nx &gt; y ? a : b\n\n位运算符\n\ne.g.\n右移：\n左移：执行一个左移位。移位的结果是第一个操作数乘以2的幂，而这个幂的指数就是第二个操作数。左移位时，高位被截去，低位填充0。\n\n\n\n\n\n\n\n\n\n\n布尔运算符优化\n&amp;&amp;运算符：opB18&amp;opB2如果opB1值为false，则运算式的值就是false，无论opB2的值是什么。程序不会访问opB2;如果opB1值为true，则需要opB2的值才能确定运算式的值，程序需要访问opB2。||运算符：opB1||opB2如果opB1值为true，则运算式的值就是true，无论opB2的值是什么。程序不会访问opB2;如果opB1值为false，则需要opB2的值才能确定运算式的值，程序需要访问opB2。\n赋值运算符赋值运算符“=”的作用是将数据写入到变量的贮存单元中。在“=”运算符的左边是变量，右边则是待写入的数据值。赋值操作必须注意:\n\n必须是将右边的数值赋给左边的变量\n\n右边的数值类型要与左边的变量类型一致或相容\n\n当它们的类型相同时，才能将右边的数值写入变量的贮存单元\n\n\n\n类型转换“拓宽类型”是指把值范围小类型的数据转换成值范围大类型的数据；“缩窄类型”是指把值范围大类型的数据转换成值范围小类型的数据。\n\n自动转换：\nint a = 10; long b = a;\n\n强制转换：\nlong b = 10; int a = (int)b;\n\n\n三目运算符expreBool?expression1:expression2\nexpreBool表达式是boolean类型，expression1和expression2表达式是相同类型。当expreBool为true时，取expression1的值；当expreBool为false时，取expression2的值。\n表达式表达式是变量、常量、运算符、方法等按照一定的运算规则组成的序列，并返回一个值。表达式是运算符运算的表述，它返回值不仅与表达式中的操作数有关，而且还是运算符操作顺序有关。\n\n\n\n\n\n\n\n\n\n表达式有时也称为运算式。\n\n","slug":"java语言基础","date":"2023-09-01T02:01:41.000Z","categories_index":"编程,java","tags_index":"java","author_index":"C4IN"},{"id":"ac1892c7e69c5d72eb21bb4d76af07c9","title":"java概述","content":"JAVA\nJava 技术的多功能性、有效性、平台的可移植性以及安全性已经使它成为网络计算领域最完美的技术。\n\nJAVA语言特点平台无关性\n编译器所生成的可执行代码是基于抽象处理器─Java虚拟机(JVM：Java Virtual Machine)来实现。\n\nJava虚拟机就是虚拟运行Java代码的假想计算机，其定义为：运行经过编译的Java目标代码的计算机的实现。\n\n编译生成的代码不针对任何具体的硬件体系结构和软件平台的代码—“字节码”。\n\n\n简洁性\n由C++衍生而来，其语言风格与C++类似，但进行了很大的简化和改进。\n抛弃了C++中一些不是绝对必要的东西，如头文件、指针、结构、联合、隐式的类型转换和操作符重载等。\njava支持单重继承，接口（interface）实现多继承，没有多继承混乱、复杂的问题。\n\n安全性\n对内存访问是通过对象实例变量实现的，防止在网络系统或分布系统环境下特洛伊木马等手段访问对象的私有成员。\n不支持指针，避免指针的安全隐患。\nJava语言提供的内存管理机制,有自动搜集“内存垃圾”程序。\n\n动态性\n分布式系统中动态地维护应用程序和对支持类库间一致性，就可避免像类库升级问题。\n在类库中可以自由地加入新的方法和实例变量而不会影响用户程序的执行。\n\n高性能\nJava字节码格式设计中充分考虑到它的机器码执行效率，很容易直接转换成对应于特定处理器的高性能机器码。\n\n多线程\n自身的多线程利用系统的空闲执行一些常规处理等。\n提供对多线程的语言级支持，提高程序执行效率。\n\n分布式\nJava是一个适用于网络的语言，它的设计使分布式计算变得容易起来。\n提供的类库支持对TCP/IP协议处理，可以通过URL地址访问网络上其它的对象。\nJava支持WWW的C/S和B/S的计算机网络模型，它可以支持分布式的数据分布和操作分布。\n\n面向对象（OOP，Object Oriented Programming）\n\n\n\n\n\n\n\n\n 计算机程序是由单个能够起到子程序作用的单元或对象组合而成。\n\n比如一辆车就可以表示为对象：\nclass Car &#123;\n    int color;  \n    int number;\n    int speed;\n\n    void brake() &#123; … &#125;\n    void speedUp() &#123;…&#125;;\n    void slowDown() &#123; …  &#125;\n&#125;\n\n类是Java语言的最基本概念，是组成Java程序的基本要素\n类是Java的执行单位，Java运行的就是Java类本身类封装了该类对象的变量和方法\n对象是类的实例化，对象的创建是通过对象构造方法来实现的\n我们可以生成多个对象，通过消息传递来进行交互，最终完成复杂的任务\n\nJava语言具有真正的面向对象语言的特点，除了数值、布尔和字符三种基本的数据类型外，其它类型都是对象，支持封装、多态和继承。\n\n\n\n\n\n\n\n\n\n\n封装就是将对象内的数据和代码联编起来，形成一个对象;\n多态性是指一个接口，有多个内在实现形式表示;\n继承是指某一对象直接使用另一对象的所有属性和方法的过程,\n\nJava程序基本结构\nJava源程序是以.java为扩展名的文件\n这些文件就是Java编译器javac的编译单元，组成为：\n最多有一条package语句\n任意条import语句\n至少有一个类class声明或接口interface声明构成\n\n\n\n// 源程序：&lt;name&gt;.java\npackage &lt;packagename&gt;;\nimport &lt;otherClassName&gt;;\nclass ClassName &#123;\npublic static void main (string args[]) &#123;\n    /*code*/\n    &#125;\n&#125;\nJava程序类型Application：Java应用程序\n\n\n\n\n\n\n\n\n由Java解释器控制执行的，它可以在任何装有JVM的计算机上运行。\n\nApplication是可独立运行的Java程序，它由一个或多个类组成,其中必须有一个类中定义了main()方法，main()方法是Application运行的起始点实现Application编程需要三个步骤:\n\n使用字符编辑器上输入并保存Java源程序代码;\n\n使用编译器javac对源程序(.java)进行编译，生成对应的字节代码程序(.class);\n\n使用解释器java对Java字节码程序(.class)解释执行。\n\napplet：java小应用程序\n\n\n\n\n\n\n\n\n嵌入到Web页面中，由Java兼容浏览器控制执行是一种“寄生”运行方式，它要依赖HTML文件以及Web浏览器。\nApplet程序是在Java兼容浏览器上执行。实现Applet编程需要四步：\n\n前两步同Application:&gt;使用字符编辑器上输入并保存Java源程序代码\n使用编译器javac对源程序(.java)进行编译，生成对应的字节代码程序(.class)\n将Applet的字节码嵌入到HTML文件中\n使用Web浏览器(支持Java)或appletviewer观察器来对Java字节码程序(.class)解释执行\n\n\nApplication&amp;Applet\n\n运行方式不同\nJava Applet程序不能单独运行，它必须依附于一个用HTML语言编写的网页并嵌入其中\n\n运行工具不同Java Application程序被编译以后，用普通的Java解释器就可以使其边解释边执行，而Java Applet必须通过网络浏览器或者Applet观察器才能执行程序\n\n结构不同每个Java Application程序必定含有一个并且只有一个main方法;Applet没有含main方法的主类\n\n受到的限制不同Java Application程序可以设计成能进行各种操作的程序，包括读/写文件的操作\n\n\nJava虚拟机解释器在JVM字节码运行中，分三个阶段:\n\n代码的装入，是由类装载器(class loader)完成\n\n代码的校验，用于发现各种可能出现的错误\n\n代码的运行，在代码校验后就可以执行\n\n\n代码的运行有两种执行方式：\n\n即时编译方式:由代码生成器先将字节码转换成机器码，再全速执行该机器码\n\n解释执行方式:由解释器通过每次翻译并执行一小段代码来完成字节码程序的所有操作。\n\n\n\n\n","slug":"java概述","date":"2023-08-31T10:07:29.000Z","categories_index":"编程,java","tags_index":"java","author_index":"C4IN"},{"id":"02610888fe553149eda2045d277295dd","title":"多方安全计算介绍","content":"多方安全计算安全多方计算(MPC)已经从20世纪80年代的一种理论发展成为今天构建真实系统的工具。在过去的十年中，MPC已经成为理论和应用密码学中最活跃的研究领域之一。\n安全多方计算(MPC)的目标是使一组互不信任的独立数据所有者或任何公共第三方能够联合计算依赖于他们所有私人输入的函数。MPC与外包计算的不同之处在于，所有协议参与者都是参与执行协议的数据所有者。\n\nMPC支持保护隐私的应用程序，其中多个互不信任的数据所有者合作计算一个函数。在分布式的多方安全计算（Secure Multi-Party Computation , SMPC）环境中,含有隐私输入的两方或者多方参与者希望协作和交互式地计算一个目标函数f\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right)=\\left(y_{1}, y_{2}, \\ldots, y_{n}\\right)，一旦计算完成，每一个参与者应该能够获取与之相对应的且不包含其他信息的输出。多方安全计算目的是构建一个安全协议，这个安全协议能允许多个互不信任的参与者在自己隐私输入上联合计算目标函数，同时确保输出的准确，甚至在面对不诚实行为时，能够保护和管控自己的隐私输入。\n\n\n\n\n\n\n\n\n\n\n\n姚氏百万富翁问题\n姚(1982)简单地介绍道:“两个百万富翁想知道谁更富有；然而，他们不希望无意中发现任何关于彼此财富的额外信息。”也就是说，目标是计算的布尔结果，其中是第一方的私有输入，是第二方的私有输入。\n\n拍卖安全问题\n在一次拍卖中，学习到的唯一出价信息是出价最高者的出价，显然可以得出所有其他出价都低于中标价，但无法得到其它竞标失败的出价。\n\n\n研究领域理论研究包括安全模型、可行性和复杂性等方面的研究。理论研究的目的是将来自理论研究的优雅的理论想法转化成解决现实世界安全问题的具体的SMPC协议。实用的多方安全协议注重于效率问题。SMPC理论协议涉及的研究和方法主要从计算成本、通信成本和交互轮数方面提高通用和特定协议的效率。\n面向应用的SMPC包括隐私集合计算、隐私保护机器学习、数据挖掘和安全基因组计算等领域的研究。\n所有这些协议都涉及到基本的构造块，如不经意传输、秘密共享、投币、同态加密、承诺方案、零知识证明等。这些构造块为理论和实用的SMPC奠定了基础。\nMPC的可行性在存在恶意的情况下依然可以安全地计算任何分布式计算任务。现在我们简要说明这些结果中最重要的部分，假设表示参与方的数量，表示可能被腐坏的计算方的数量的界限 (其中被腐坏方的身份未知)：\n\n对于 (即，当不到三分之一的参与方可能被腐坏时)，任何具有计算安全性的函数都可以实现具有公平性和有保证的输出的安全多方协议，假设一个具有认证信道的同步点到点网络，在信息论安全的前提下，假设信道也是私有的。\n对于 (即，在保证诚实多数的情况下)，对于任何具有计算和信息论安全性的函数，都可以实现具有公平性和保证输出的安全多方协议，假设各方也可以访问广播信道。\n对于(即当腐坏方的数量不受限制时)，可以实现安全的多方协议 (没有公平性或保证输出)。\n\n","slug":"多方安全计算基础","date":"2023-08-20T02:47:19.000Z","categories_index":"Crypto,多方安全计算","tags_index":"Crypto,MPC","author_index":"C4IN"},{"id":"745fa9d0dd7564f8475d86a8b9ad72f3","title":"java","content":"\n反射Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。通过反射，Java 代码可以发现有关已加载类的字段，方法和构造函数的信息，并可以在安全限制内对这些字段，方法和构造函数进行操作。\n反射机制的相关类与Java反射相关的类如下：\n\n\n\n\n类名\n用途\n\n\n\n\nClass类\n代表类的实体，在运行的Java应用程序中表示类和接口\n\n\nField类\n代表类的成员变量（成员变量也称为类的属性）\n\n\nMethod类\n代表类的方法\n\n\nConstructor类\n代表类的构造方法\n\n\n\n\nclass\n获得类相关的方法\n\n\n\n\n\n方法\n用途\n\n\n\n\nasSubclass(Class clazz)\n把传递的类的对象转换成代表其子类的对象\n\n\nCast\n把对象转换成代表类或是接口的对象\n\n\ngetClassLoader()\n获得类的加载器\n\n\ngetClasses()\n返回一个数组，数组中包含该类中所有公共类和接口类的对象\n\n\ngetDeclaredClasses()\n返回一个数组，数组中包含该类中所有类和接口类的对象\n\n\nforName(String className)\n根据类名返回类的对象\n\n\ngetName()\n获得类的完整路径名字\n\n\nnewInstance()\n创建类的实例\n\n\ngetPackage()\n获得类的包\n\n\ngetSimpleName()\n获得类的名字\n\n\ngetSuperclass()\n获得当前类继承的父类的名字\n\n\ngetInterfaces()\n获得当前类实现的类或是接口\n\n\n\n\n\n获得类中属性相关的方法\n\n\n\n\n\n方法\n用途\n\n\n\n\ngetField(String name)\n获得某个公有的属性对象\n\n\ngetFields()\n获得所有公有的属性对象\n\n\ngetDeclaredField(String name)\n获得某个属性对象\n\n\ngetDeclaredFields()\n获得所有属性对象\n\n\n\n\n\n获得类中注解相关的方法\n\n\n\n\n\n方法\n用途\n\n\n\n\ngetAnnotation(Class annotationClass)\n返回该类中与参数类型匹配的公有注解对象\n\n\ngetAnnotations()\n返回该类所有的公有注解对象\n\n\ngetDeclaredAnnotation(Class annotationClass)\n返回该类中与参数类型匹配的所有注解对象\n\n\ngetDeclaredAnnotations()\n返回该类所有的注解对象\n\n\n\n\n","slug":"java反射","date":"2023-08-02T01:19:09.000Z","categories_index":"编程,java","tags_index":"java","author_index":"C4IN"},{"id":"49195eb2df2edd82dc60ba6a843fc68d","title":"php-Basic","content":"PHP编程\n\n\n\n\n\n\n\n\nphp是世界上最好的编程语言！\nPHP 是服务器端脚本语言。\n\nPHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。\nPHP 脚本在服务器上执行。\nPHP 可免费下载使用。\n\nPHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码\n\nPHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器\nPHP 文件的默认文件扩展名是 “.php”\n\nPHP 可以生成动态页面内容\n\nPHP 可以创建、打开、读取、写入、关闭服务器上的文件\nPHP 可以收集表单数据\nPHP 可以发送和接收 cookies\nPHP 可以添加、删除、修改您的数据库中的数据\nPHP 可以限制用户访问您的网站上的一些页面\nPHP 可以加密数据\n\n通过 PHP，您不再限于输出 HTML。您可以输出图像、PDF 文件，甚至 Flash 电影。您还可以输出任意的文本，比如 XHTML 和 XML。\n\nPHP语法PHP 脚本可以放在文档中的任何位置。\nPHP 脚本以 \\&lt;?php  开始，以 ?>  结束：\n&lt;?php\n// PHP 代码\n?&gt;\n\nPHP 文件的默认文件扩展名是 “.php”。\nPHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。\n一个简单的例子：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;h1&gt;My first PHP page&lt;/h1&gt;\n\n&lt;?php\necho &quot;Hello World!&quot;;\n?&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\nPHP变量&lt;?php\n\n$x=5;\n$y=6;\n$z=$x+$y;\necho &quot;x + y = $z&quot;\n\n?&gt;\n\n与代数类似，可以给 PHP 变量赋予某个值（x=5）或者表达式（z=x+y）。\nPHP 变量规则：\n\n变量以 $ 符号开始，后面跟着变量的名称\n变量名必须以字母或者下划线字符开始\n变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）\n变量名不能包含空格\n变量名是区分大小写的（$y 和$Y是两个不同的变量）\n\n\n\n\n\n\n\n\n\n\nPHP 语句和 PHP 变量都是区分大小写的。\nPHP 变量作用域变量的作用域是脚本中变量可被引用/使用的部分。\nPHP 有四种不同的变量作用域：\n\nlocal\nglobal\nstatic\nparameter\n\nPHP echo 和 print 语句echo和 print区别:\n\necho - 可以输出一个或多个字符串，是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。\nprint - 只允许输出一个字符串，返回值总为 1，同样是一个语言结构，可以使用括号，也可以不使用括号：print 或 print()。\n\n\n\n\n\n\n\n\n\n\necho 输出的速度比 print 快， echo 没有返回值，print有返回值1。\n使用 echo, print 命令输出字符串可以包含 HTML 标签。\nPHP EOF(heredoc) 使用说明PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法。\n使用概述：\n\n必须后接分号，否则编译通不过。\nEOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。\n结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。\n开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。\n当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。\n\n&lt;?php\n$name=&quot;C4IN&quot;;\n$a=&lt;&lt;&lt;EOF\n        name: &quot;$name&quot;\n         , hello\n    EOF;\necho $a\n?&gt;\n\n\n\n\n\n\n\n\n\n注意：\n1.以&lt;&lt;&lt;EOF 开始标记开始，以 EOF 结束标记结束，结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号 。\n2.开始标记和结束标记相同，比如常用大写的 EOT、EOD、EOF 来表示，但是不只限于那几个(也可以用：JSON、HTML等)，只要保证开始标记和结束标记不在正文中出现即可。\n3.位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。在 heredoc 中，变量不需要用连接符 . 或 , 来拼接。\nPHP 数据类型PHP 变量存储不同的类型的数据，不同的数据类型可以做不一样的事情。\nPHP 支持以下几种数据类型:\n\nString（字符串）\nInteger（整型）\nFloat（浮点型）\nBoolean（布尔型）\nArray（数组）\nObject（对象）\nNULL（空值）\nResource（资源类型）\n\nPHP 资源类型PHP 资源 resource 是一种特殊变量，保存了到外部资源的一个引用。\n常见资源数据类型有打开文件、数据库连接、图形画布区域等。\n由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。\n使用 get_resource_type() 函数可以返回资源（resource）类型：\nget_resource_type(resource $handle): string\n此函数返回一个字符串，用于表示传递给它的 resource 的类型。如果参数不是合法的 resource，将产生错误。\n&lt;?php\n$c = mysql_connect();\necho get_resource_type($c).&quot;\\n&quot;;\n// 打印：mysql link\n\n$fp = fopen(&quot;foo&quot;,&quot;w&quot;);\necho get_resource_type($fp).&quot;\\n&quot;;\n// 打印：file\n\n$doc = new_xmldoc(&quot;1.0&quot;);\necho get_resource_type($doc-&gt;doc).&quot;\\n&quot;;\n// 打印：domxml document\n?&gt;\nPHP 类型比较虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。\n\n松散比较：使用两个等号 == 比较，只比较值，不比较类型。\n严格比较：用三个等号 === 比较，除了比较值，也比较类型。\n\nPHP 常量常量是一个简单值的标识符。该值在脚本中不能改变。\n一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。\n注意： 常量在整个脚本中都可以使用。\n设置 PHP 常量设置常量，使用define()函数，函数语法如下：\nbool define ( string $name , mixed $value [, bool $case_insensitive = false ] )\n该函数有三个参数:\n\nname： 必选参数，常量名称，即标志符。\n\nvalue： 必选参数，常量的值。\n\ncase_insensitive  ：可选参数，如果设置为 TRUE，该常量则大小写不敏感，默认是大小写敏感的。\n注意：自 PHP 7.3.0 开始，定义不区分大小写的常量已被弃用。从 PHP 8.0.0 开始，只有 false 是可接受的值，传递 true 将产生一个警告。\n\n\n&lt;?php\ndefine(&#39;NAME&#39;,&#39;C4IN&#39;);\necho NAME;\necho C4IN;   // 输出，但会报常量未定义\n?&gt;\nPHP字符串PHP 并置运算符在 PHP 中，只有一个字符串运算符。\n并置运算符 (.) 用于把两个字符串值连接起来。\n下面的实例演示了如何将两个字符串变量连接在一起：\n&lt;?php\n$str1=&#39;name:&#39;;\n$str2=&#39;C4IN&#39;;\n$str3=$str1.&#39; &#39;.$str2;\necho $str3;\n?&gt;\nPHP strlen()strlen()函数返回字符串的长度（字节数）。\nPHP strpos()strpos() 函数用于在字符串内查找一个字符或一段指定的文本。\n如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。\n&lt;?php\necho strpos(&quot;Hello world!&quot;,&quot;world&quot;);\n?&gt;\nPHP运算符PHP 算术运算符\n\n\n\n运算符\n名称\n描述\n实例\n结果\n\n\n\n\nx + y\n加\nx 和 y 的和\n2 + 2\n4\n\n\nx - y\n减\nx 和 y 的差\n5 - 2\n3\n\n\nx * y\n乘\nx 和 y 的积\n5 * 2\n10\n\n\nx / y\n除\nx 和 y 的商\n15 / 5\n3\n\n\nx % y\n模（除法的余数）\nx 除以 y 的余数\n5 % 2 10 % 8 10 % 2\n1 2 0\n\n\n-x\n设置负数\n取 x 的相反符号\n&lt;?php $x = 2; echo -$x; ?&gt;\n-2\n\n\n~x\n取反\nx 取反，按二进制位进行”取反”运算。运算规则：~1=-2;    ~0=-1;\n&lt;?php $x = 2; echo ~$x; ?&gt;\n-3\n\n\na . b\n并置\n连接两个字符串\n“Hi” . “Ha”\nHiHa\n\n\n\n\n\nPHP7+ 版本新增整除运算符 intdiv()，该函数返回值为第一个参数除于第二个参数的值并取整（向下取整）。\n&lt;?php\nvar_dump(intdiv(10, 3));\n?&gt;\nint(3)\n\nPHP 赋值运算符在 PHP 中，基本的赋值运算符是 =。它意味着左操作数被设置为右侧表达式的值。也就是说，$x = 5 的值是 5。\n\n\n\n\n运算符\n等同于\n描述\n\n\n\n\nx = y\nx = y\n左操作数被设置为右侧表达式的值\n\n\nx += y\nx = x + y\n加\n\n\nx -= y\nx = x - y\n减\n\n\nx *= y\nx = x * y\n乘\n\n\nx /= y\nx = x / y\n除\n\n\nx %= y\nx = x % y\n模（除法的余数）\n\n\na .= b\na = a . b\n连接两个字符串\n\n\n\n\nPHP 递增/递减运算符\n\n\n\n运算符\n名称\n描述\n\n\n\n\n++ x\n预递增\nx 加 1，然后返回 x\n\n\nx ++\n后递增\n返回 x，然后 x 加 1\n\n\n— x\n预递减\nx 减 1，然后返回 x\n\n\nx —\n后递减\n返回 x，然后 x 减 1\n\n\n\n\nPHP 比较运算符比较操作符可以让您比较两个值：\n\n\n\n\n运算符\n名称\n描述\n实例\n\n\n\n\nx == y\n等于\n如果 x 等于 y，则返回 true\n5==8 返回 false\n\n\nx === y\n绝对等于\n如果 x 等于 y，且它们类型相同，则返回 true\n5===”5” 返回 false\n\n\nx != y\n不等于\n如果 x 不等于 y，则返回 true\n5!=8 返回 true\n\n\nx &lt;&gt; y\n不等于\n如果 x 不等于 y，则返回 true\n5&lt;&gt;8 返回 true\n\n\nx !== y\n不绝对等于\n如果 x 不等于 y，或它们类型不相同，则返回 true\n5!==”5” 返回 true\n\n\nx &gt; y\n大于\n如果 x 大于 y，则返回 true\n5&gt;8 返回 false\n\n\nx &lt; y\n小于\n如果 x 小于 y，则返回 true\n5&lt;8 返回 true\n\n\nx &gt;= y\n大于等于\n如果 x 大于或者等于 y，则返回 true\n5&gt;=8 返回 false\n\n\nx &lt;= y\n小于等于\n如果 x 小于或者等于 y，则返回 true\n5&lt;=8 返回 true\n\n\n\n\nPHP 逻辑运算符\n\n\n\n运算符\n名称\n描述\n实例\n\n\n\n\nx and y\n与\n如果 x 和 y 都为 true，则返回 true\nx=6 y=3 (x &lt; 10 and y &gt; 1) 返回 true\n\n\nx or y\n或\n如果 x 和 y 至少有一个为 true，则返回 true\nx=6 y=3 (x\\==6 or y\\==5) 返回 true\n\n\nx xor y\n异或\n如果 x 和 y 有且仅有一个为 true，则返回 true\nx=6 y=3 (x\\==6 xor y==3) 返回 false\n\n\nx &amp;&amp; y\n与\n如果 x 和 y 都为 true，则返回 true\nx=6 y=3 (x &lt; 10 &amp;&amp; y &gt; 1) 返回 true\n\n\nx \\\n\\\ny\n或\n如果 x 和 y 至少有一个为 true，则返回 true\nx=6 y=3 (x\\==5 \\\n\\\ny==5) 返回 false\n\n\n!x\n非\n如果 x 不为 true，则返回 true\nx=6 y=3, !(x==y) 返回 true\n\n\n\n\nPHP 数组运算符\n\n\n\n运算符\n名称\n描述\n\n\n\n\nx + y\n集合\nx 和 y 的集合\n\n\nx == y\n相等\n如果 x 和 y 具有相同的键/值对，则返回 true\n\n\nx === y\n恒等\n如果 x 和 y 具有相同的键/值对，且顺序相同类型相同，则返回 true\n\n\nx != y\n不相等\n如果 x 不等于 y，则返回 true\n\n\nx &lt;&gt; y\n不相等\n如果 x 不等于 y，则返回 true\n\n\nx !== y\n不恒等\n如果 x 不等于 y，则返回 true\n\n\n\n\nPHP 条件语句在 PHP 中，提供了下列条件语句：\n\nif 语句 - 在条件成立时执行代码\nif…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码\nif…elseif….else 语句 - 在若干条件之一成立时执行一个代码块\nswitch 语句 - 在若干条件之一成立时执行一个代码块\n\nPHP数组在 PHP 中创建数组在 PHP 中，array()函数用于创建数组：\narray();\n在 PHP 中，有三种类型的数组：\n\n数值数组 - 带有数字 ID 键的数组\n关联数组 - 带有指定的键的数组，每个键关联一个值\n多维数组 - 包含一个或多个数组的数组\n\nPHP 数值数组这里有两种创建数值数组的方法：\n自动分配 ID 键（ID 键总是从 0 开始）：\n$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n人工分配 ID 键：\n$cars[0]=&quot;Volvo&quot;;\n$cars[1]=&quot;BMW&quot;;\n$cars[2]=&quot;Toyota&quot;;\n&lt;?php\n$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\ncount()函数count()函数用于返回数组的长度（元素的数量）。\nPHP 关联数组关联数组是使用分配给数组的指定的键的数组。\n这里有两种创建关联数组的方法：\n$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);\nor:\n$age[&#39;Peter&#39;]=&quot;35&quot;;\n$age[&#39;Ben&#39;]=&quot;37&quot;;\n$age[&#39;Joe&#39;]=&quot;43&quot;;\n随后可以在脚本中使用指定的键：\n&lt;?php\n$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);\necho &quot;Peter is &quot; . $age[&#39;Peter&#39;] . &quot; years old.&quot;;\n?&gt;\n遍历关联数组遍历并打印关联数组中的所有值，可以使用 foreach 循环，如下所示：\n&lt;?php\n$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);\n\nforeach($age as $x=&gt;$x_value)\n&#123;\n    echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value;\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\nPHP - 数组排序函数·\nsort()- 对数组进行升序排列\nrsort() - 对数组进行降序排列\nasort()- 根据关联数组的值，对数组进行升序排列\nksort()- 根据关联数组的键，对数组进行升序排列\narsort()- 根据关联数组的值，对数组进行降序排列\nkrsort()- 根据关联数组的键，对数组进行降序排列\n\nPHP 超级全局变量PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。\nPHP 超级全局变量列表:\n\n$GLOBALS\n&lt;?php \n$x = 75; \n$y = 25;\n\nfunction addition() \n&#123; \n    $GLOBALS[&#39;z&#39;] = $GLOBALS[&#39;x&#39;] + $GLOBALS[&#39;y&#39;]; \n&#125;\n\naddition(); \necho $z; \n?&gt;\nz 是一个$GLOBALS数组中的超级全局变量，该变量同样可以在函数外访问。\n\n$_SERVER\n$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。\n以下实例中展示了如何使用$_SERVER中的元素：\n&lt;?php \necho $_SERVER[&#39;PHP_SELF&#39;];\necho &quot;&lt;br&gt;&quot;;\necho $_SERVER[&#39;SERVER_NAME&#39;];\necho &quot;&lt;br&gt;&quot;;\necho $_SERVER[&#39;HTTP_HOST&#39;];\necho &quot;&lt;br&gt;&quot;;\necho $_SERVER[&#39;HTTP_REFERER&#39;];\necho &quot;&lt;br&gt;&quot;;\necho $_SERVER[&#39;HTTP_USER_AGENT&#39;];\necho &quot;&lt;br&gt;&quot;;\necho $_SERVER[&#39;SCRIPT_NAME&#39;];\n?&gt;\n| 元素/代码                       | 描述                                                         || :——————————————— | :—————————————————————————————- || $_SERVER[‘PHP_SELF’]            | 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER[‘PHP_SELF’] 将得到 /test.php/foo.bar。FILE 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 || $_SERVER[‘GATEWAY_INTERFACE’]   | 服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。               || $_SERVER[‘SERVER_ADDR’]         | 当前运行脚本所在的服务器的 IP 地址。                         || $_SERVER[‘SERVER_NAME’]         | 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) || $_SERVER[‘SERVER_SOFTWARE’]     | 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24) || $_SERVER[‘SERVER_PROTOCOL’]     | 请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。           || $_SERVER[‘REQUEST_METHOD’]      | 访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。 || $_SERVER[‘REQUEST_TIME’]        | 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)   || $_SERVER[‘QUERY_STRING’]        | query string（查询字符串），如果有的话，通过它进行页面访问。 || $_SERVER[‘HTTP_ACCEPT’]         | 当前请求头中 Accept: 项的内容，如果存在的话。                || $_SERVER[‘HTTP_ACCEPT_CHARSET’] | 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。 || $_SERVER[‘HTTP_HOST’]           | 当前请求头中 Host: 项的内容，如果存在的话。                  || $_SERVER[‘HTTP_REFERER’]        | 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) || $_SERVER[‘HTTPS’]               | 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。      || $_SERVER[‘REMOTE_ADDR’]         | 浏览当前页面的用户的 IP 地址。                               || $_SERVER[‘REMOTE_HOST’]         | 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 || $_SERVER[‘REMOTE_PORT’]         | 用户机器上连接到 Web 服务器所使用的端口号。                  || $_SERVER[‘SCRIPT_FILENAME’]     | 当前执行脚本的绝对路径。                                     || $_SERVER[‘SERVER_ADMIN’]        | 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：someone@runoob.com) || $_SERVER[‘SERVER_PORT’]         | Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 || $_SERVER[‘SERVER_SIGNATURE’]    | 包含了服务器版本和虚拟主机名的字符串。                       || $_SERVER[‘PATH_TRANSLATED’]     | 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 || $_SERVER[‘SCRIPT_NAME’]         | 包含当前脚本的路径。这在页面需要指向自己时非常有用。FILE 常量包含当前脚本(例如包含文件)的完整路径和文件名。 || $_SERVER[‘SCRIPT_URI’]          | URI 用来指定要访问的页面。例如 “/index.html”。               |\n\n$_REQUEST\n $_REQUEST用于收集HTML表单提交的数据。\n以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至&lt;form&gt;标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;\nName: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;\n&lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n\n&lt;?php \n$name = $_REQUEST[&#39;fname&#39;]; \necho $name; \n?&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n$_POST\n $_POST被广泛应用于收集表单数据，在HTML form标签的指定该属性：&quot;method=&quot;post&quot;。\n以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至&lt;form&gt;标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_POST 来收集表单中的 input 字段数据：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;\nName: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;\n&lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n\n&lt;?php \n$name = $_POST[&#39;fname&#39;]; \necho $name; \n?&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n$_GET\n$_GET同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：&quot;method=&quot;get&quot;。\n$_GET 也可以收集URL中发送的数据。\n假定我们有一个包含参数的超链接HTML页面：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;a href=&quot;test_get.php?subject=PHP&amp;web=runoob.com&quot;&gt;Test $GET&lt;/a&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n当用户点击链接 “Test $GET”, 参数 “subject” 和 “web” 将发送至”test_get.php”,你可以在 “test_get.php” 文件中使用 $_GET 变量来获取这些数据。\n\n$_FILES\n\n$_ENV\n\n$_COOKIE\n\n$_SESSION\n\n\nPHP 函数创建 PHP 函数函数是通过调用函数来执行的。\n&lt;?php\nfunction functionName()\n&#123;\n    // 要执行的代码\n&#125;\n?&gt;\nPHP 函数准则：\n\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\n添加参数为了给函数添加更多的功能，我们可以添加参数，参数类似变量。\n参数就在函数名称后面的一个括号内指定。\n&lt;?php\nfunction writeName($fname)\n&#123;\n    echo $fname . &quot; Refsnes.&lt;br&gt;&quot;;\n&#125;\n\necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Stale&quot;);\n?&gt;\n返回值使用 return 语句。\n&lt;?php\nfunction add($x,$y)\n&#123;\n    $total=$x+$y;\n    return $total;\n&#125;\n\necho &quot;1 + 16 = &quot; . add(1,16);\n?&gt;\nPHP 魔术常量PHP 向它运行的任何脚本提供了大量的预定义常量。\n不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。\n有八个魔术常量它们的值随着它们在代码中的位置改变而改变。\n__LINE__文件中的当前行号。\n&lt;?php\necho &#39;这是第 &quot; &#39;  . __LINE__ . &#39; &quot; 行&#39;;\n?&gt;\n__FILE__文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。\n自 PHP 4.0.2 起，FILE 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。\n&lt;?php\necho &#39;该文件位于 &quot; &#39;  . __FILE__ . &#39; &quot; &#39;;\n?&gt;\n__DIR__文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。\n它等价于 dirname(FILE)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）\n&lt;?php\necho &#39;该文件位于 &quot; &#39;  . __DIR__ . &#39; &quot; &#39;;\n?&gt;\n__FUNCTION__函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。\n&lt;?php\nfunction test() &#123;\n    echo  &#39;函数名为：&#39; . __FUNCTION__ ;\n&#125;\ntest();\n?&gt;\n__CLASS__类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。\n在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\\Bar）。注意自 PHP 5.4 起 CLASS 对 trait 也起作用。当用在 trait 方法中时，CLASS 是调用 trait 方法的类的名字。\n&lt;?php\nclass test &#123;\n    function _print() &#123;\n        echo &#39;类名为：&#39;  . __CLASS__ . &quot;&lt;br&gt;&quot;;\n        echo  &#39;函数名为：&#39; . __FUNCTION__ ;\n    &#125;\n&#125;\n$t = new test();\n$t-&gt;_print();\n?&gt;\n__TRAIT__Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。\nTrait 名包括其被声明的作用区域（例如 Foo\\Bar）。\n从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。\n&lt;?php\nclass Base &#123;\n    public function sayHello() &#123;\n        echo &#39;Hello &#39;;\n    &#125;\n&#125;\n\ntrait SayWorld &#123;\n    public function sayHello() &#123;\n        parent::sayHello();\n        echo &#39;World!&#39;;\n    &#125;\n&#125;\n\nclass MyHelloWorld extends Base &#123;\n    use SayWorld;\n&#125;\n\n$o = new MyHelloWorld();\n$o-&gt;sayHello();\n?&gt;\n__METHOD__类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。\n&lt;?php\nfunction test() &#123;\n    echo  &#39;函数名为：&#39; . __METHOD__ ;\n&#125;\ntest();\n?&gt;\n__NAMESPACE__当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。\n一些文章https://www.runoob.com/php/php-intro.html\n","slug":"php","date":"2023-08-02T01:18:49.000Z","categories_index":"编程,php","tags_index":"","author_index":"C4IN"},{"id":"2cbb891df5dd9e9d79cc9907faec0ead","title":"安洁莉卡&罗兰","content":"\n安洁莉卡最喜欢的诗\n\n痛苦啊，你便是我的唯一除了你，我皆无欲求痛苦啊，你忠实的陪伴我，直至现在也没有一丝改变当我的灵魂徘徊于深渊之底唯有你相伴在我身旁，守护着我我又怎能埋怨你呢痛苦啊，你绝不会从我身旁遁走我终于能表达对你的尊敬现在也认识到你的存在而你只是存于世，便那么美丽痛苦啊，你就像那从未离开我那贫苦的心之火炉旁的人一样比我那身为至爱的恋人还要多情我知道在我迈向死亡的那一天你会走进我内心的深处与我并排躺下\n\n小时候的罗兰，只有奶奶相伴。在奶奶的指导下，成为了都市里的一名收尾人。在千疮百孔的都市中，凭着“奇点”技术，人们克服了疾病，征服了大自然，却逐渐患上了心病，不再追求曾经炫目的梦想，任由自己的思想为”翼“所指导。在”翼“的庇佑下，巢中的羽过着安全、稳定的生活，而在巢之外的后巷，人们只为了活下去而活下去，人的生命根本不值一提，人们渴望着有朝一日能进入”翼“，能从眼前的地狱中解放。都市脆弱的秩序由收尾人来维持。这些收尾人或许受雇于巢，或许受雇于后巷势力，接手各种各样的工作，从送货到杀人，再到处理大型事件。在都市中，收尾人的工作机遇与危险并存，最忌讳的就是在收尾时产生情感。罗兰在查尔斯事务所中遇到了安洁莉卡。他来自后巷，而她来自翼的实验室。在一次次的生死中，两人相爱，并结了婚。罗兰兢兢业业干了那么多年，好不容易有了爱他的人，他们一定会很幸福不是……吗？\n\n\n\n\n\n\n\n\n\n“闯进我世界之人，最后成了我的全世界”\n“一码，归一码”\n早些年罗兰参加了烟霾战争，翼曾向他承诺，会优先安排巢的易居权。但，这是都市。翼玩了一次文字游戏，罗兰移居巢的梦想彻底破灭，只得住在相对安全的音之巷内。妻子怀孕了有了孩子，罗兰更加自责，害怕自己的妻子和孩子的安全会受到威胁。虽然没有住在巢中，安洁莉卡没有说什么，安洁莉卡非常爱罗兰，她看的透罗兰，她知道一旦出事罗兰便会怪自己。\n\n\n\n\n\n\n\n\n\n“说起来，那里的葱饼味道还不错？，回来的时候麻烦捎一个吧”“非常乐意为您效劳，在下去去就回”\n罗兰的老友奥利维耶打来通讯，说一个委托急缺人手，他便去帮忙了。等他带着妻子爱吃的葱饼回到家中时——只有坍塌的房子。一切都没了，他的妻子，与他的孩子，就这么没了。\n罗兰彻底崩溃了。\n\n\n\n\n\n\n\n\n\n“为什么，我那来之不易的幸福却能如此轻易地从我手中溜走……”\n“全都是我的错……”\n罗兰的世界破碎了。他开始调查实验室，屠杀了手指，向都市发起他最恶毒的诅咒。\n\n\n\n\n\n\n\n\n\n“越是沿往昔之路，尸山越发高耸。层峦叠嶂，不见前路”\n“不见前路。我仅是回首遥望。”\n墙对面传来的欢笑声，其中或许有属于我的风景，我遗落的风景。成团的漆黑独守空房。\n罗兰的故事，总给我一种触动。\n","slug":"Ruina","date":"2023-07-28T13:40:40.000Z","categories_index":"这都是些什么啊,Library of Ruina","tags_index":"闲","author_index":"C4IN"}]