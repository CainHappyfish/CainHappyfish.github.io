[{"id":"879a8462604fcb11b1eac81677e70525","title":"概率论公式整理-3","content":"🚗第七章 参数估计参数估计是对已知分布类型的总体，利用样本对其未知参数作出估计\n参数的点估计设总体$X $的分布函数$F( x ;θ )$类型已知，$ θ $是未知参数，$θ $的取值范围$Ω $称为参数空间\n点估计思想：按一定的优化原则建立一个统计量，将其统计值作为参数$θ $的估计值\n设总体$  X  $的分布函数$  F(x ; \\theta)  $中的参数$  \\theta  $未知，$\\theta \\in \\Omega $。由样本$  X_{1} ,  X_{2}, \\ldots, X_{n}  $建立统计量$  T\\left(X_{1}, X_{2}, \\ldots, X_{n}\\right) $，若将其统计值\n$t=T\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right)$\n作为$  \\theta  $的估计值，称\n$\\hat{\\theta}=T\\left(X_{1}, X_{2} \\cdots, X_{n}\\right)$\n为$  \\theta  $的点估计量。\n总体X的分布函数中可有多个不同未知参数。\n矩估计法矩是最简单的数字特征。\n设总体$  X  $的$  k  $阶矩$  E\\left(X^{k}\\right)  $存在,  $X_{1}, X_{2}, \\ldots, X_{n} $是总体$  X  $的样本，有\n$E\\left(A_{k}\\right)=E\\left(\\frac{1}{n} \\sum_{i=1}^{n} X_{i}^{k}\\right)=\\frac{1}{n} \\sum_{i=1}^{n} E\\left(X_{i}^{k}\\right)=E\\left(X^{k}\\right)$\n另一方面，根据辛钦大数定律知\n$A_{k}=\\frac{1}{n} \\sum_{i=1}^{n} X_{i}^{k} \\stackrel{P}{\\rightarrow} E\\left(X^{k}\\right), \\quad \\text { as } n \\rightarrow \\infty$\n样本矩在一定程度反映了总体矩的特性。\n矩估计法的思想简单直观：替换原则\n\n用样本矩去替换相应的总体矩\n用样本矩的函数替换相应的总体矩的同一函数\n\n设总体$  X  $的分布函数\n$F\\left(x ; \\theta_{1}, \\theta_{2}, \\ldots, \\theta_{l}\\right)$\n中含有  l  个未知参数, 假定  X  的  l  阶原点矩存在,记\n$\\gamma_{k}\\left(\\theta_{1}, \\theta_{2}, \\cdots, \\theta_{l}\\right)=E\\left(X^{k}\\right), \\quad(k=1,2, \\cdots, l)$\n由方程组\n$\\frac{1}{n} \\sum_{i=1}^{n} X_{i}^{k}=\\hat{\\gamma}_{k}\\left(\\theta_{1}, \\theta_{2}, \\cdots, \\theta_{l}\\right), \\quad k=1,2, \\cdots, l .$\n解得$  \\hat{\\theta}_{k}=\\hat{\\theta}_{k}\\left(X_{1}, X_{2}, \\cdots, X_{n}\\right), k=1,2, \\cdots, l ,称  \\hat{\\theta}_{k}  为  \\theta_{k}  $的矩法估计量.\n若$  \\hat{\\theta}  $为$  \\theta  $的矩法估计量,  $g(\\theta)  $是关于$  \\theta  $的连续函数，称$  g(\\hat{\\theta})  $为$  g(\\theta)  $的矩法估计量。\n注意，样本矩是随机变量，而总体矩是数值。\n极大似然估计法求参数的估计值，使似然函数达到极大值。\n极大似然估计法基本思想：按照最大可能性准则进行推断。\n若总体$  X  $的概率密度函数为\n$  f(x, \\theta)  (  \\theta  可以是向量),  X_{1}, X_{2}, \\cdots, X_{n}  为来自  X 的一个样本,  n  维随机变量  \\left(X_{1}, X_{2}, \\cdots, X_{n}\\right)  $\n的联合概率密度函数记为\n$L\\left(x_{1}, x_{2}, \\ldots, x_{n} ; \\theta\\right)=\\prod_{i=1}^{n} f\\left(x_{i} ; \\theta\\right)$\n称为参数$  \\theta  $的似然函数。\n对于离散型样本，其似然函数为其联合分布律。\n若\n$\\begin{array}{l}L\\left(x_{1}, x_{2}, \\ldots, x_{n} ; \\hat{\\theta}_{1}, \\hat{\\theta}_{2}, \\ldots, \\hat{\\theta}_{l}\\right) \\\\=\\max _{\\left(\\theta_{1}, \\theta_{2}, \\ldots, \\theta_{l}\\right) \\in \\Omega} L\\left(x_{1}, x_{2}, \\ldots, x_{n} ; \\theta_{1}, \\theta_{2}, \\ldots, \\theta_{l}\\right)\\end{array}$\n称$  \\left(\\hat{\\theta}_{1}, \\hat{\\theta}_{2}, \\ldots, \\hat{\\theta}_{l}\\right)  为  \\left(\\theta_{1}, \\theta_{2}, \\ldots, \\theta_{l}\\right)  $的极大似然估计值.\n相应的估计量  \\hat{\\theta}_{k}=\\hat{\\theta}_{k}\\left(X_{1}, X_{2}, \\ldots, X_{n}\\right), k=1,2, \\cdots, l 称为参数  \\theta_{k}  的极大似然估计量.\n\n\n\n\n\n\n\n\n\n$ \\ln x  $是$  x $的严格单增函数,  $\\ln L  $与$  L  $有相同的极大值点，一般只需求$  \\ln L  $的极大值点\n称\n$\\frac{\\partial \\ln L\\left(\\theta_{1}, \\theta_{2}, \\cdots, \\theta_{l}\\right)}{\\partial \\theta_{k}}=0, k=1,2, \\cdots, l$\n为似然方程组\n求极大似然估计量的一般步骤：\n\n写出似然函数\n\n​    $L\\left(x_{1}, x_{2}, \\ldots, x_{n} ; \\theta_{1}, \\theta_{2}, \\ldots, \\theta_{l}\\right)=\\prod_{i=1}^{n} f\\left(x_{i} ; \\theta_{1}, \\theta_{2}, \\ldots, \\theta_{l}\\right)$\n\n对似然函数取对数\n\n​    $\\ln L=\\sum_{i=1}^{n} \\ln f\\left(x_{i} ; \\theta_{1}, \\theta_{2}, \\ldots, \\theta_{l}\\right)$\n\n对$  \\theta_{j}(j=1, \\ldots, l  )$分别求偏导，建立似然方程(组)\n\n​    $\\frac{\\partial \\ln L}{\\partial \\theta_{j}}=0, \\quad(j=1,2, \\ldots, l)$\n​    解得$  \\hat{\\theta}_{1}, \\ldots, \\hat{\\theta}_{l}  $分别为$  \\theta_{1}, \\ldots, \\theta_{l}  $的极大似然估计值\n\n写出$  \\theta_{1}, \\ldots, \\theta_{l}  $的极大似然估计量.\n\n估计量的优良性准则三个常用准则：无偏性、有效性、相合性\n无偏性若参数$  \\theta  $的估计量$  \\hat{\\theta}=T\\left(X_{1}, X_{2}, \\ldots, X_{n}\\right) $对一切$  n  $及$  \\theta \\in \\Omega  $，有\n$E\\left(\\hat{\\theta}_{n}\\right)=E\\left[T\\left(X_{1}, X_{2}, \\ldots, X_{n}\\right)\\right]=\\theta$\n称$  \\hat{\\theta}_{n}  $为$  \\theta  $的无偏估计量。若\n$\\lim _{n \\rightarrow \\infty} b_{n}=\\lim _{n \\rightarrow \\infty}\\left[E\\left(\\hat{\\theta}_{n}\\right)-\\theta\\right]=0$\n则称$  \\hat{\\theta}_{n}  $为$  \\theta  $的渐进无偏估计量.\n若$  \\theta  $的实函数$  g(\\theta)  $的无偏估计量存在，称$  g(\\theta)  $是可估计函数。\n\n\n\n\n\n\n\n\n\n注 当$  \\hat{\\theta}  $是$  \\theta  $的无偏估计量，$g(\\hat{\\theta})  $不一定是$  g(\\theta) $的无偏估计量.\n样本均值是总体均值$E(X)$的无偏估计量。样本的$k$阶原点矩是总体的k阶原点矩的无偏估计量.\n$ M_{2}=\\frac{1}{n} \\sum_{i=1}^{n}\\left(X_{i}-\\bar{X}\\right)^{2}  $不是$  \\sigma^{2}  $的无偏估计\n$\\begin{aligned}\\because M_{2} &amp; =\\frac{1}{n} \\sum_{i=1}^{n}\\left(X_{i}-\\bar{X}\\right)^{2}=\\frac{n-1}{n} S^{2} \\\\&amp; \\Rightarrow E\\left(M_{2}\\right)=\\frac{n-1}{n} \\sigma^{2}\\end{aligned}$\n知$  E(X)=\\mu  时, \\frac{1}{n} \\sum_{i=1}^{n}\\left(X_{i}-\\mu\\right)^{2}  $是$  \\sigma^{2}  $的无偏估计\n有效性希望$  \\hat{\\theta}  $的取值在$  \\theta  $及其附近越密集越好，其方差应尽量小。\n设$  \\hat{\\theta}_{1}\\left(X_{1}, X_{2}, \\ldots, X_{n}\\right)  和  \\hat{\\theta}_{2}\\left(X_{1}, X_{2}, \\ldots, X_{n}\\right) $都是未知参数$  \\theta  $的无偏估计量，若\n$D\\left(\\hat{\\theta}_{1}\\right) \\leq D\\left(\\hat{\\theta}_{2}\\right), \\quad \\forall \\theta \\in \\Omega$\n称$  \\hat{\\theta}_{1}  $比$  \\hat{\\theta}_{2}  $有效 (优效)。\n设$  \\hat{\\theta}_{0}  $是$  \\theta  $的无偏估计，如果对$  \\theta  $的任何一个无偏估计量$  \\hat{\\boldsymbol{\\theta}}  $都有\n$D\\left(\\hat{\\theta}_{0}\\right) \\leq D(\\hat{\\theta}), \\quad \\theta \\in \\Omega$\n称$  \\hat{\\theta}  $为$  \\theta  $的最小方差无偏估计量。$\\bar{X} $和$ S^{2}$分别是$ \\mu$和$ \\sigma^{2}$的最小方差无偏估计。\n相合性设$  \\hat{\\theta}_{n}=\\hat{\\theta}\\left(X_{1}, X_{2}, \\ldots, X_{n}\\right)  $是未知参数$  \\theta  $的估计量，若对任意的$  \\varepsilon&gt;0  $，有\n$\\lim _{n \\rightarrow \\infty} P\\left\\{\\left|\\hat{\\theta}_{n}-\\theta\\right|&lt;\\varepsilon\\right\\}=1$\n则称$  \\hat{\\theta}  $为$  \\theta  $的相合估计量。\n\n$ \\bar{X}  $是$  \\mu  $的相合估计量\n$  S^{2}  $和$  M_{2}  $都是$  \\sigma^{2}  $的相合估计量\n$ \\bar{X}  $和$  S^{2}  $分别是$  \\mu  $和$  \\sigma^{2}  $的相合、无偏估计 \n$ \\bar{X}  $和$  S^{2} $分别是$  \\mu  $和$  \\sigma^{2}  $的最小方差无偏估计\n\n区间估计设总体的末知参数为$  \\theta $，由样本$  X_{1} ， \\ldots, X_{n}  $确定两个统计量\n$\\hat{\\theta}_{1}=\\hat{\\theta}_{1}\\left(X_{1}, \\ldots, X_{n}\\right), \\quad \\hat{\\theta}_{2}=\\hat{\\theta}_{2}\\left(X_{1}, \\ldots, X_{n}\\right)$\n对于给定的实数$  \\alpha(0&lt;\\alpha&lt;1) $ ，满足\n$P\\left\\{\\hat{\\theta}_{1}\\left(X_{1}, \\ldots, X_{n}\\right) \\leq \\theta \\leq \\hat{\\theta}_{2}\\left(X_{1}, \\ldots, X_{n}\\right)\\right\\}=1-\\alpha$\n称随机区间$  \\left[\\hat{\\boldsymbol{\\theta}}_{1}, \\hat{\\boldsymbol{\\theta}}_{2}\\right]  $为$  \\theta  $的置信度为$  1-\\alpha $的区间估计（置信区间）。\n$ 1-\\alpha  $又称置信水平或置信概率$  \\alpha  $称显著性水平，通常取值为$  0.1,0.05 $。\n\n随机区间$  \\left[\\hat{\\theta}_{1}, \\hat{\\theta}_{2}\\right]  $以$  1-\\alpha  $的概率包含着待估参数$  \\theta $，$1-\\alpha$反映区间估计的可靠程度\n随机区间$  \\left[\\hat{\\theta}_{1}, \\hat{\\theta}_{2}\\right]  $的长度$  \\hat{\\theta}_{2}-\\hat{\\theta}_{1}  $是随机变量，反映了区间估计的精确程度\n\n置信区间的枢轴变量法\n选取待估参数$  \\theta  $的估计量；\n\n​    原则：优良性准则​    常用:  $\\bar{X} \\rightarrow \\mu, \\quad S^{2} \\rightarrow \\sigma^{2} $\n\n建立枢轴变量\n\n​    对选定的$  \\theta  $的估计量，构造关于待估参数$  \\theta $和样本的函数\n​    $W\\left(X_{1}, X_{2}, \\ldots, X_{n}, \\theta\\right)$\n​    其中$  W  $不含任何其他未知参数.\n\n确定$  W  $的分布\n在一定条件下，$ W  $通常具有经典分布(主要有正态、$  \\chi^{2}$ 、$ T $、$ F  $分布)；\n\n根据$  W  $的分布，对置信水平$  1-\\alpha  $查上侧分位数, 使\n\n\n​    $P\\left\\{w_{1-\\alpha / 2} \\leq W \\leq w_{\\alpha / 2}\\right\\}=1-\\alpha$\n​    或类似的概率式成立。\n\n改写不等式得\n$P\\{A \\leq \\theta \\leq B\\}=1-\\alpha$\n其中$  A $、$ B  $是不含末知参数的统计量（以较大概率包含待估参数）\n\n\n上面过程的关键是构造枢轴变量$  W $，并以它为轴心，由$  a \\leq W \\leq b  $旋转出所需不等式\n$A \\leq \\theta \\leq B $\n正态总体（单个正态总体$X\\sim N(\\mu,\\sigma^2)$）的区间估计\n$\\mu  $的估计\n\n已知 $\\sigma=\\sigma_{0}$\n$\\begin{array}{c}\n U=\\frac&#123;\\bar&#123;X&#125;-\\mu&#125;&#123;\\sigma_&#123;0&#125; / \\sqrt&#123;n&#125;&#125; \\sim N(0,1) \\\\\nP\\left\\&#123;-u_&#123;\\alpha / 2&#125; \\leq \\frac&#123;\\bar&#123;X&#125;-\\mu&#125;&#123;\\sigma_&#123;0&#125; /         \\sqrt&#123;n&#125;&#125; \\leq                         u_&#123;\\alpha / 2&#125;\\right\\&#125;=1-\\alpha \\\\\n&#123;\\left[\\bar&#123;X&#125;-\\frac&#123;\\sigma_&#123;0&#125;&#125;&#123;\\sqrt&#123;n&#125;&#125;     \\boldsymbol&#123;u&#125;_&#123;\\alpha / 2&#125;, \\bar&#123;X&#125;+\\frac&#123;\\sigma_&#123;0&#125;&#125;&#123;\\sqrt&#123;n&#125;&#125;     u_&#123;\\alpha / 2&#125;\\right]&#125;\n\\end&#123;array&#125;$    \n\n$\\sigma^2$未知：$T=\\frac{\\bar{X}-\\mu}{S / \\sqrt{n}} \\sim t(n-1)$\n$\\begin{array}{l}P\\left\\{-t_{\\alpha / 2}(n-1) \\leq \\frac{\\bar{X}-\\mu}{S / \\sqrt{n}} \\leq t_{\\alpha / 2}(n-1)\\right\\}=1-\\alpha \\\\{\\left[\\bar{X}-t_{\\alpha / 2}(n-1) \\frac{S}{\\sqrt{n}}, \\quad \\bar{X}+t_{\\alpha / 2}(n-1) \\frac{S}{\\sqrt{n}}\\right]}\\end{array}$\n\n\n\n$\\sigma^2$的估计\n$ \\sigma^{2}  $的优良估计量为$  S^{2} $，当$  \\mu  $未知时，由抽样分布定理可知，应选枢轴变量:\n$\\frac{n-1}{\\sigma^{2}} S^{2} \\sim \\chi^{2}(n-1)$\n\n\n  当$  \\mu  $已知时, 应选枢轴变量:\n  $\\sum_{i=1}^{n}\\left(\\frac{X_{i}-\\mu_{0}}{\\sigma}\\right)^{2}=\\frac{1}{\\sigma^{2}} \\sum_{i=1}^{n}\\left(X_{i}-\\mu_{0}\\right)^{2} \\sim \\chi^{2}(n)$\n\n已知$\\mu_0$\n$\\begin{array}{c}\\chi^{2}=\\sum_{i=1}^{n}\\left(\\frac{X_{i}-\\mu_{0}}{\\sigma}\\right)^{2}=\\frac{1}{\\sigma^{2}} \\sum_{i=1}^{n}\\left(X_{i}-\\mu_{0}\\right)^{2} \\sim \\chi^{2}(n) \\\\P\\left\\{\\chi_{1-\\alpha / 2}^{2}(n) \\leq \\frac{1}{\\sigma^{2}} \\sum_{i=1}^{n}\\left(X_{i}-\\mu_{0}\\right)^{2} \\leq \\chi_{\\alpha / 2}^{2}(n)\\right\\}=1-\\alpha \\\\{\\left[\\frac{\\sum_{i=1}^{n}\\left(X_{i}-\\mu_{0}\\right)^{2}}{\\chi_{\\alpha / 2}^{2}(n)}, \\quad \\frac{\\sum_{i=1}^{n}\\left(X_{i}-\\mu_{0}\\right)^{2}}{\\chi_{1-\\alpha / 2}^{2}(n)}\\right]}\\end{array}$\n\n未知$\\mu$：$\\chi^{2}=\\frac{n-1}{\\sigma^{2}} S^{2} \\sim \\chi^{2}(n-1)$\n$\\begin{array}{c}P\\left\\{\\chi_{1-\\alpha / 2}^{2}(n-1) \\leq \\frac{n-1}{\\sigma^{2}} S^{2} \\leq \\chi_{\\alpha / 2}^{2}(n-1)\\right\\}=1-\\alpha \\\\{\\left[(n-1) S^{2} / \\chi_{\\alpha / 2}^{2}(n-1),(n-1) S^{2} / \\chi_{1-\\alpha / 2}^{2}(n-1)\\right]}\\end{array}$\n\n\n两个正态总体$ X \\sim N\\left(\\mu_{1}, \\sigma_{1}^{2}\\right), Y \\sim N\\left(\\mu_{2}, \\sigma_{2}^{2}\\right)$，$X  $与$  Y  $相互独立\n\n$\\mu_{1}-\\mu_{2}  $的估计\n\n已知$  \\sigma_{1}{ }^{2}  $和$  \\sigma_{2}{ }^{2} $\n枢轴变量取\n$U=\\frac{(\\bar{X}-\\bar{Y})-\\left(\\mu_{1}-\\mu_{2}\\right)}{\\sqrt{\\frac{\\sigma_{1}^{2}}{n_{1}}+\\frac{\\sigma_{2}^{2}}{n_{2}}}} \\sim N(\\mathbf{0}, \\mathbf{1})$\n$\\begin{array}{c}P\\left\\{-u_{\\frac{\\alpha}{2}} \\leq \\frac{(\\bar{X}-\\bar{Y})-\\left(\\mu_{1}-\\mu_{2}\\right)}{\\sqrt{\\frac{\\sigma_{1}^{2}}{n_{1}}+\\frac{\\sigma_{2}^{2}}{n_{2}}}} \\leq u_{\\frac{\\alpha}{2}}\\right\\}=1-\\alpha \\\\{\\left[\\bar{X}-\\bar{Y}-u_{\\frac{\\alpha}{2}} \\sqrt{\\frac{\\sigma_{1}^{2}}{n_{1}}+\\frac{\\sigma_{2}^{2}}{n_{2}}}, \\quad \\bar{X}-\\bar{Y}+u_{\\frac{\\alpha}{2}} \\sqrt{\\frac{\\sigma_{1}^{2}}{n_{1}}+\\frac{\\sigma_{2}^{2}}{n_{2}}}\\right]}\\end{array}$\n\n$\\sigma_1^2$和$\\sigma_2^2$未知，但$\\sigma_1^2=\\sigma_2^2=\\sigma^2$\n$T=\\frac{(\\bar{X}-\\bar{Y})-\\left(\\mu_{1}-\\mu_{2}\\right)}{S_{w} \\sqrt{\\frac{1}{n_{1}}+\\frac{1}{n_{2}}}} \\sim t\\left(n_{1}+n_{2}-2\\right)$\n$\\begin{aligned}{\\left[\\bar{X}-\\bar{Y}-t_{\\frac{\\alpha}{2}}\\left(n_{1}+n_{2}-2\\right) S_{\\mathrm{w}} \\sqrt{\\frac{1}{n_{1}}+\\frac{1}{n_{2}}}\\right.}, \\\\\\left.\\bar{X}-\\bar{Y}+t_{\\frac{\\alpha}{2}}\\left(n_{1}+n_{2}-2\\right) S_{\\mathrm{w}} \\sqrt{\\frac{1}{n_{1}}+\\frac{1}{n_{2}}}\\right]\\end{aligned}$\n\n当$n_1=n_2$时\n$\\begin{array}{c}\\text { 记 } Z_{i}=X_{i}-Y_{i}, \\quad i=1,2, \\cdots, n ; \\\\\\text { 则 } \\quad \\bar{Z}=\\frac{1}{n} \\sum_{i=1}^{n} Z_{i}=\\bar{X}-\\bar{Y}, \\\\S_{Z}^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(Z_{i}-\\bar{Z}\\right)^{2}\\end{array}$\n因$  Z_{1}, Z_{2}, \\cdots, Z_{n}  $相互独立，且\n$Z_{i} \\sim N\\left(\\mu_{1}-\\mu_{2}, 2 \\sigma^{2}\\right)$\n\n\n\n\n根据抽样定理知，可选枢轴变量\n\n$T=\\frac&#123;\\bar&#123;Z&#125;-\\left(\\mu_&#123;1&#125;-\\mu_&#123;2&#125;\\right)&#125;&#123;S_&#123;Z&#125; / \\sqrt&#123;n&#125;&#125; \\sim t(n-1)$\n\n$\\frac{\\sigma_{2}^{2}}{\\sigma_{1}^{2}}$的区间估计\n\n未知$\\mu_1,\\mu_2$\n$\\begin{array}{l}F=\\frac{S_{1}^{2} / \\sigma_{1}^{2}}{S_{2}^{2} / \\sigma_{2}^{2}}=\\frac{\\sigma_{2}^{2}}{\\sigma_{1}^{2}} \\cdot \\frac{S_{1}^{2}}{S_{2}^{2}} \\sim F\\left(n_{1}-1, n_{2}-1\\right) \\\\P\\left\\{F_{1-\\frac{\\alpha}{2}}\\left(n_{1}-1, n_{2}-1\\right) \\leq \\frac{\\sigma_{2}^{2}}{\\sigma_{1}^{2}} \\cdot \\frac{S_{1}^{2}}{S_{2}^{2}} \\leq F_{\\frac{\\alpha}{2}}\\left(n_{1}-1, n_{2}-1\\right)\\right\\}=1-\\alpha \\\\{\\left[\\frac{S_{2}^{2}}{S_{1}^{2}} \\cdot F_{1-\\frac{\\alpha}{2}}\\left(n_{1}-1, n_{2}-1\\right), \\frac{S_{2}^{2}}{S_{1}^{2}} \\cdot F_{\\frac{\\alpha}{2}}\\left(n_{1}-1, n_{2}-1\\right)\\right]}\\end{array}$\n\n已知$\\mu_1,\\mu_2$\n$F=\\frac{\\frac{1}{n_{1}}}{\\frac{1}{n_{2}}} \\cdot \\frac{\\sum_{i=1}^{n_{1}}\\left(\\frac{X_{i}-\\mu_{1}}{\\sigma_{1}}\\right)^{2}}{\\sum_{j=1}^{n_{2}}\\left(\\frac{Y_{j}-\\mu_{2}}{\\sigma_{2}}\\right)^{2}} \\sim F\\left(n_{1}, n_{2}\\right)$\n\n\n\n\n🚓第八章 假设检验假设检验的基本思想与步骤假设检验基本思想：提出统计假设, 根据小概率事件原理对其进行检验。\n基本概念\n参数与分布的假设检验\n\n关于总体参数的假设检验，如$H_0=\\mu=\\mu_0$\n关于总体分布的假设检验，如$H_{0}: F(x)=\\Psi\\left(x ; \\mu, \\sigma^{2}\\right)$\n\n\n原假设与备择假设\n根据问题的需要提出的一对对立的假设，记$  \\mathrm{H}_{0}  $为原假设或零假设\n与原假设$  H_{0}$ 相对立的假设称为备选假设，记为$  H_{1} $\n相对于原假设, 可考虑不同的备选假设, 如\n$\\begin{array}{l}H_{0}: \\mu=\\mu_{0}, \\quad H_{1}: \\mu \\neq \\mu_{0} ; \\\\H_{0}: \\mu \\leq \\mu_{0}, \\quad H_{1}: \\mu&gt;\\mu_{0} ; \\\\H_{0}: \\mu \\geq \\mu_{0}, \\quad H_{1}: \\mu&lt;\\mu_{0} ;\\end{array}$\n\n检验统计量\n用做检验统计推断的统计量\n\n假设检验的接受域和拒绝域\n根据假设检验目的， 由样本去推断是否接受原假设$H_0$\n接受域：使$  H_{0}  $得以接受的检验统计量取值的区域$  A $\n否定域：使$  H_{0}  $被否定的检验统计量取值的区域$  R $\n\n\n假设检验的基本步骤\n提出原假设\n根据实际问题提出原假设$  H_{0}  $和备选假设$  H_{1}  $\n\n建立检验统计量\n寻找参数的一个良好估计量，据此建立一个不带任何未知参数的统计量$  U  $作为检验统计量，并在$  H_{0}  $成立的条件下，确定$  U  $的分布(或近似分布)\n\n确定$H_0$的否定域\n根据实际问题选定显著性水平$  \\alpha  $，依据检验统计量的分布与$  H_{0}  $的内容，确定$  H_{0}  $的否定域\n\n对$H_0$作判断\n根据样本值算出检验统计量的统计值$  u  $，判断$  u  $是否落在拒绝域，以确定拒绝或接受$  H_{0} $\n\n\n对原假设$  H_{0}  $做出判断，称为对$  H_{0}  $做显著性检验，$1-  \\alpha  $称为置信水平。\n\n\n\n\n\n\n\n\n\n\n对不同的显著性水平  \\alpha  ，有不同的否定域，从而可能有不同的判断结论\n在确定$  H_{0}  $的拒绝域时应遵循有利准则:将检验统计量对$  H_{0}  $有利的取值区域确定为接受域，对$  H_{1}  $成立有利的区域作为拒绝域\n\n两类错误\n假设检验的主要依据是 “小概率事件原理”，而小概率事件并非绝对不发生\n假设检验方法是依据样本去推断总体，样本只是总体的一个局部，不能完全反映整体特性\n\n第一类错误(弃真)：在$  H_{0}  $成立的情况下，错误地否定了$  H_{0}  $\n第二类错误(纳伪)：在$  H_{0}  $不成立的情况下错误地接受了$  H_{0} $\n减小一类错误，必然使另一错误增大。\n正态总体的参数检验均值$\\mu$的检验U检验法\n单样本U检验法\n$ X_{1}, \\ldots, X_{\\mathrm{n}}  $是从正态总体$  N\\left(\\mu, \\sigma_{0}^{2}\\right)  $中抽取的简单随机样本\n已知$  \\sigma_0^{2} $，检验\n$H_{0}: \\mu=\\mu_{0}, \\quad H_{1}: \\mu \\neq \\mu_{0}$\n原假设成立时，$U=\\frac{\\bar{X}-\\mu_{0}}{\\sigma_{0} / \\sqrt{n}} \\sim N(\\mathbf{0}, 1) $\n拒绝域为：$|\\boldsymbol{u}|&gt;\\boldsymbol{u}_{\\frac{\\alpha}{2}}$\n\n双样本U检验法\n$X_{1}, X_{2}, \\cdots, X_{n_{1}}  $来自正态总体$  N\\left(\\mu 1, \\sigma 1^{2}\\right)   $\n$Y_{1}, Y_{2}, \\cdots, Y_{n_{2}}  $来自正态总体$  N\\left(\\mu 2, \\sigma_{2}^{2}\\right) $\n已知$  \\sigma 1^{2}  $与$  \\sigma 2^{2}$，检验\n$\\begin{array}{l}\\mathrm{H}_{0}: \\mu 1=\\mu 2 \\quad(\\text { 或 } \\mu 1-\\mu 2=0) \\\\\\mathrm{H}_{1}: \\mu 1 \\neq \\mu_{2}\\end{array}$\n原假设$  \\mathrm{H}_{0}  $成立时，\n$\\begin{aligned}U &amp; =\\frac{(\\bar{X}-\\bar{Y})-\\left(\\mu_{1}-\\mu_{2}\\right)}{\\sqrt{\\frac{\\sigma_{1}^{2}}{n_{1}}}+\\frac{\\sigma_{2}^{2}}{n_{2}}} \\\\&amp; =\\frac{\\bar{X}-\\bar{Y}}{\\sqrt{\\frac{\\sigma_{1}^{2}}{n_{1}}+\\frac{\\sigma_{2}^{2}}{n_{2}}}} \\sim N(\\mathbf{0}, \\mathbf{1})\\end{aligned}$\n拒绝域为$|\\mu|&gt;\\mu_{\\frac \\alpha 2}$\n\n\nU检验法的要点\n\n构造服从标准正态分布的统计量U 作为检验统计量\n为进行标准化，必须已知总体的方差。\n\nt检验法\n单样本t检验法\n$ X_{1}, \\ldots, X_{\\mathrm{n}}  $是来自正态总体$  N\\left(\\mu, \\sigma^{2}\\right) $的样本，$  \\mu, \\sigma^{2}  $未知，检验\n$H_{0}: \\mu=\\mu_{0}, \\quad \\mathbf{H}_{1}: \\mu \\neq \\mu_{0}$\n原假设成立时，$T=\\frac{\\bar{X}-\\mu_{0}}{S / \\sqrt{n}} \\sim t(n-1) $拒绝域为：$|\\boldsymbol{t}|&gt;\\boldsymbol{t}_{\\frac{\\alpha}{2}}(n-1) $\n\n双样本t检验法\n$ X_{1}, X_{2}, \\cdots, X_{n_{1}}  $来自正态总体$  N\\left(\\mu 1, \\sigma^{2}\\right)$\n$   Y_{1}, Y_{2}, \\cdots, Y_{n_{2}}  $来自正态总体$  N\\left(\\mu 2, \\sigma^{2}\\right) $\n检验：$  \\quad H_{0}: \\mu_{1}=\\mu_{2}, H_{1}: \\mu_{1} \\neq \\mu_{2} $\n未知$  \\sigma_{1}^{2}, \\sigma_{2}^{2} $，但有$  \\sigma_{1}^{2}=\\sigma_{2}^{2}=\\sigma^{2} $\n原假设成立时，检验统计量\n$T=\\frac{(\\bar{X}-\\bar{Y})-\\left(\\mu_{1}-\\mu_{2}\\right)}{S_{w} \\sqrt{\\frac{1}{n_{1}}+\\frac{1}{n_{2}}}}=\\frac{\\bar{X}-\\bar{Y}}{S_{w} \\sqrt{\\frac{1}{n_{1}}+\\frac{1}{n_{2}}}} \\sim t\\left(n_{1}+n_{2}-2\\right)$\n拒绝域为：$\\quad|t|&gt;t_{\\frac{\\alpha}{2}}\\left(n_{1}+n_{2}-2\\right) $\n其中\n$\\begin{aligned}\\mathrm{S}_{\\mathrm{w}}^{2} &amp; =\\frac{1}{n_{1}+n_{2}-2}\\left[\\left(n_{1}-1\\right) S_{1}^{2}+\\left(n_{2}-1\\right) S_{2}^{2}\\right] \\\\&amp; =\\frac{1}{n_{1}+n_{2}-2}\\left[\\sum_{i=1}^{\\mathrm{n}_{1}}\\left(X_{i}-\\overline{\\mathrm{X}}\\right)^{2}+\\sum_{j=1}^{\\mathrm{n}_{2}}\\left(Y_{j}-\\bar{Y}\\right)^{2}\\right]\\end{aligned}$\n\n\n方差$\\sigma^2$的检验$\\chi^2$检验法$ X_{1}, \\ldots, X_{\\mathrm{n}}  $是来自正态总体$  N\\left(\\mu, \\sigma^{2}\\right)  $的样本，检验\n$H_{0}: \\sigma^{2}=\\sigma_{0}{ }^{2} ; \\quad \\sigma^{2} \\neq \\sigma_{0}{ }^{2}$\n\n已知$\\mu$\n原假设成立时，$ \\chi^{2}=\\sum_{i=1}^{n}\\left(\\frac{X_{i}-\\mu}{\\sigma_{0}}\\right)^{2} \\sim \\chi^{2}(n)$\n拒绝域为：\n$\\chi^{2}&gt;\\chi_{\\frac{\\alpha}{2}}^{2}(n) \\text { 或 } \\chi^{2}&lt;\\chi_{1-\\frac{\\alpha}{2}}^{2}(n)$\n\n未知$\\mu$\n$ X_{1}, \\ldots, X_{n}  $是从正态总体$  N\\left(\\mu, \\sigma^{2}\\right)  $中抽取的样本，检验\n$H_{0}: \\sigma^{2}=\\sigma_{0}{ }^{2} ; \\quad \\mathrm{H}_{1}: \\quad \\sigma^{2} \\neq \\sigma_{0}{ }^{2}$\n原假设成立时，$ \\chi^{2}=(n-1) \\frac{\\mathrm{S}^{2}}{\\sigma_{0}{ }^{2}} \\sim \\chi^{2}(n-1) $\n拒绝域为:\n$\\chi^{2}&gt;\\chi_{\\frac{\\alpha}{2}}^{2}(n-1) \\text { 或 } \\chi^{2}&lt;\\chi_{1-\\frac{\\alpha}{2}}^{2}(n-1)$\n\n\nF检验法$ X_{1}, \\ldots, X_{\\mathrm{n}_{1}}  $是从正态总体$  N\\left(\\mu_{1}, \\sigma_{1}^{2}\\right)  $中抽取的样本\n$ Y_{1}, \\ldots, Y_{\\mathrm{n}_{2}}  $是从正态总体$  N\\left(\\mu_{2}, \\sigma_{2}{ }^{2}\\right)  $中抽取的样本\n检验\n$H_{0}: \\sigma_{1}^{2}=\\sigma_{2}^{2} ; \\quad H_{1}: \\sigma_{1}^{2} \\neq \\sigma_{2}^{2}$\n\n已知$\\mu_1,\\mu_2$\n原假设成立时，\n$F=\\frac{n_{2} \\sum_{i=1}^{n_{1}}\\left(X_{i}-\\mu_{1}\\right)^{2}}{n_{1} \\sum_{j=1}^{n_{2}}\\left(Y_{j}-\\mu_{2}\\right)^{2}} \\sim F\\left(n_{1}, n_{2}\\right)$\n拒绝域为：\n$f&gt;F_{\\frac{\\alpha}{2}}\\left(n_{1}, n_{2}\\right) \\text { 或 } f&lt;F_{1-\\frac{\\alpha}{2}}\\left(n_{1}, n_{2}\\right)$\n\n未知$\\mu_1,\\mu_2$\n原假设成立时，$ \\quad F=\\frac{S_{1}^{2} / \\sigma_{1}^{2}}{S_{2}^{2} / \\sigma_{2}^{2}}=\\frac{S_{1}^{2}}{S_{2}^{2}} \\sim F\\left(n_{1}-1, n_{2}-1\\right)$\n拒绝域为：\n$f&gt;F_{\\frac{\\alpha}{2}}\\left(n_{1}-1, n_{2}-1\\right) \\text { 或 } \\quad f&lt;F_{1-\\frac{\\alpha}{2}}\\left(n_{1}-1, n_{2}-1\\right)$\n\n\n🚕第九章 回归分析相关关系与回归分析相关关系与回归函数在现实世界中存在大量的变量, 它们有相互依存、相互制约的关系，一般分为两类：确定性关系与非确定性关系。\n将作为考察目标的变量称为因变量（记为$  Y$），而将影响它的各个变量称为自变量或可控变量，记为$\\left(X_{1}, X_{2}, \\cdots X_{k}\\right)$\n\n确定性的函数关系\n\n​    用第三章方法可求随机变量函数的分布\n\n非确定性的相关关系\n构造某种函数来描述输入和输出之间的非确定关系。\n\n\n考虑单个因变量$  Y  $与单个自变量$  X  $的情形。在 “$  X=x  $” 时，$  Y $（连续型）的条件数学期望为\n$\\mu(x)=E(Y \\mid X=x)=\\int_{-\\infty}^{+\\infty} y f_{Y \\mid X}(y \\mid x) d y$\n1)  $\\mu(x)  $可理解为在 “$  X=x  $” 的条件下，随机变量$  Y  $取值的集中点1)  方程$  y=\\mu(x)  $描述了$  Y  $与$  X  $间非确定性的关系\n将可控变量$  X_{1}, X_{2}, \\cdots X_{k}  $的取值记为$  x_{1} ,  x_{2,}, \\ldots, x_{k} $，若条件数学期望:\n$\\mu\\left(x_{1}, x_{2}, \\cdots, x_{k}\\right)=E\\left(Y \\mid X_{1}=x_{1}, X_{2}=x_{2}, \\cdots X_{k}=x_{k}\\right)$\n存在，称$  Y  $与$  X_{1}, X_{2}, \\cdots X_{k}  $具有相关关系。相关关系是一种非确定性关系\n称\n$\\mu\\left(x_{1}, x_{2}, \\cdots, x_{k}\\right)=E\\left(Y \\mid X_{1}=x_{1}, X_{2}=x_{2}, \\cdots X_{k}=x_{k}\\right)$\n为$  Y  $关于$  X_{1}, X_{2}, \\cdots X_{k}  $的回归函数，方程\n$y=\\mu\\left(x_{1}, x_{2}, \\cdots, x_{k}\\right)$\n称为$  Y  $对$  X_{1}, X_{2}, \\cdots X_{k}  $的回归方程。\n\n\n\n\n\n\n\n\n\n 注 回归函数是确定性的函数\n回归分析是从回归函数出发处理相关关系的方法.\n回归模型的引进若$  Y  $关于$  X_{1}, X_{2}, \\cdots X_{k}  $的回归函数为\n$y=\\mu\\left(x_{1}, x_{2}, \\cdots, x_{k}\\right)$\n设想：$Y=\\mu\\left(x_{1}, x_{2}, \\cdots, x_{k}\\right)+ $随机误差（其它末知的、未考虑的因素以及随机因素的影响所产生）\n得数学模型:\n$\\begin{array}{l}Y=\\mu\\left(x_{1}, x_{2}, \\cdots, x_{k}\\right)+\\varepsilon \\\\\\varepsilon=Y-\\mu\\left(x_{1}, x_{2}, \\cdots, x_{k}\\right)\\end{array}$\n可视为随机误差，通常要求：\n1)  $E(\\varepsilon)=0 $2)  $D(\\varepsilon)=E\\left(\\varepsilon^{2}\\right)=\\sigma^{2}  $尽可能小.\n注意到$  \\sigma^{2}=E\\left[Y-\\mu\\left(x_{1}, x_{2}, \\cdots, x_{n}\\right)\\right]^{2}   \\sigma^{2}  $是用回归函数近似因变量$  Y  $产生的均方误差。\n回归函数类型的估计确定本节仅讨论最简单的情形：可控变量$Y $关于单个因变量$X $的回归函数存在$\\mu(x)=E(Y \\mid X=x)$\n为估计回归函数，可依据问题的背景，确定或假定回归函数的形式. 称\n$y=\\hat{\\mu}(x)=S(x)$\n为$  Y  $关于$  X  $的经验回归方程。\n一元回归分析一元线性回归模型若回归函数是线性函数\n$\\mu\\left(x_{1}, x_{2}, \\cdots, x_{k}\\right)=b_{0}+b_{1} x_{1}+b_{2} x_{2}+\\cdots+b_{k} x_{k}$\n其中$  b_{0}, b_{1}, \\ldots, b_{\\mathrm{k}}  $是未知常数，称为线性回归问题。\n若  Y  关于  X  的回归函数为\n\\mu(x)=E(Y \\mid X=x)=a+b x\n有一元线性回归模型:\n$Y=a+b x+\\varepsilon, \\quad \\varepsilon \\sim N\\left(0, \\sigma^{2}\\right)$\n其中$  a 、 b 、 \\sigma^{2}  $为未知参数，且\n$ a  $：回归常数（又称截距）\n$ b$：回归系数（又称斜率）\n$ \\varepsilon  $：随机误差（随机扰动项）\n若随机误差$  \\varepsilon \\sim N\\left(0, \\sigma^{2}\\right) $，称为一元线性正态回归模型。\n$ \\varepsilon_{i}  $是第$  i  $次观察时的随机误差，有\n$ \\left\\{\\begin{array}{l}\\text { 1) } E\\left(\\varepsilon_{i}\\right)=0, \\quad D\\left(\\varepsilon_{i}\\right)=\\sigma^{2}, i=1,2, \\ldots, n ; \\\\ \\text { 2) } \\varepsilon_{1}, \\ldots, \\quad \\varepsilon_{n} \\text { 相互独立. } \\quad \\end{array}\\right. $\n称为回归假定。\n一元线性回归模型的参数估计$ \\left\\{\\begin{array}{l}\\text { 用观察值 }\\left(x_{\\mathrm{i}}, \\mathrm{y}_{\\mathrm{j}}\\right) a 、 b 、 \\sigma^{2} \\text { 进行估计. } \\\\ \\text { 对所假定的回归模型进行检验 (回归系数 } \\mathrm{b})\\end{array}\\right. $\n对自变量$  X  $的一组值$  x_{1}, x_{2}, \\ldots, x_{n}  $做$  n  $次独立试验，得独立观察值$  y_{1}, y_{2}, \\ldots, y_{n} $。\n记$  y_{i} $的估计值为$  \\hat{y}_{i}=\\hat{a}+\\hat{b} x_{i} $称为回归值。\n应选$  a $、$ b  $的估计使离差(误差)平方和：\n$Q=\\sum_{i=1}^{n}\\left(y_{i}-\\hat{y}_{i}\\right)^{2}=\\sum_{i=1}^{n}\\left(y_{i}-\\hat{a}-\\hat{b} x_{i}\\right)^{2}$\n达最小。\n令$Q(a, b)=\\sum_{i=1}^{n}\\left(y_{i}-a-b x_{i}\\right)^{2}$\n应用最小二乘法，建立方程组\n$\\left\\{\\begin{array}{l}\\sum_{i=1}^{n}\\left(y_{i}-a-b x_{i}\\right)=0 \\\\\\sum_{i=1}^{n}\\left(y_{i}-a-b x_{i}\\right) x_{i}=0\\end{array}\\right.$\n得\n$\\left\\{\\begin{array}{l}\\hat{b}=\\frac{l_{x y}}{l_{x x}} \\\\\\hat{a}=\\bar{y}-\\hat{b} \\bar{x}\\end{array}\\right.$\n其中\n$\\begin{array}{l}\\bar{x}=\\frac{1}{n} \\sum_{i=1}^{n} x_{i}, \\quad \\bar{y}=\\frac{1}{n} \\sum_{i=1}^{n} y_{i} \\\\l_{x y}=\\sum_{i=1}^{n}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right)=\\sum_{i=1}^{n} x_{i} y_{i}-n \\bar{x} \\bar{y} \\\\l_{x x}=\\sum_{i=1}^{n}\\left(x_{i}-\\bar{x}\\right)^{2}=\\sum_{i=1}^{n} x_{i}^{2}-n \\bar{x}^{2}\\end{array}$\n由回归假定\n$E\\left(\\varepsilon_{i}\\right)=0, \\quad D\\left(\\varepsilon_{i}\\right)=\\sigma^{2}, i=1,2, \\ldots, n ;$\n有$  \\sigma^{2}=D(\\varepsilon)=E\\left(\\varepsilon^{2}\\right)  $，故\n$\\frac{1}{n} \\sum_{i=1}^{n} \\varepsilon_{i}^{2}$\n是$  \\sigma^{2}  $的矩估计量.\n可证明$  \\sigma^{2}  $的无偏估计量为\n$\\begin{gathered}{}\\hat{\\sigma}^{2}=\\frac{1}{n-2}\\sum_{i=1}^{n}\\left(y_{i}-\\hat{y}_{i}\\right)^{2} \\\\\\textbf{代入 }\\hat{y}_i=\\hat{a}+\\hat{b}x_i\\text{,得} \\\\\\hat{\\sigma}^{2}=\\frac{1}{n-2}\\sum_{i=1}^{n}(l_{yy}-\\hat{b}^{2}l_{xx}) \\\\l_{yy}=\\sum_{i=1}^{n}(y_{i}-\\overline{y})^{2}=\\sum_{i=1}^{n}y_{i}^{2}-n\\overline{y}^{2}\\end{gathered}$\n","slug":"概率论公式整理-3","date":"2023-12-27T03:48:56.000Z","categories_index":"","tags_index":"概率论","author_index":"C4IN"},{"id":"1de931479310830774321eb838e73515","title":"计组复习提纲Q&A","content":"第一章 概论基本概念及应用冯.诺依曼体制？存储程序方式？冯诺依曼体制\n采用二进制形式表示数据和指令\n采用存储程序方式工作（核心)\n由五大部分组成计算机系统的硬件，并规定了这五部分的基本功能\n运算器\n控制器\n存储器\n输入设备\n输出设备（包括总线、接口）\n\n\n\n存储程序方式计算机采取：\n\n事先编制程序\n存储程序\n自动连续运行程序\n\n的工作方式。\n控制流？数据流？控制流：控制计算机工作的信息，即指令、命令\n数据流：计算机加工处理的对象，即数值型数据、非数值型数据\n两条基本线索是：\n\n信息的表示\n信息的传送及传送中的控制\n\n模拟信号？数字信号？数字信号有哪两种？在计算机中，信息是通过电信号表示的。\n模拟信号：是一种随时间连续变化的电信号\n数字信号：是一种在时间或空间上断续变化的电信号，有两种：\n\n电平（位）：并行传送\n脉冲：串行传送\n\n总线及其组成？总线：能为多个部件分时共享的一组信息传送线路及相应的控制逻辑。\n\n模型机系统结构\n\n内总线： 16位单向数据传送线，实现ALU和寄存器间的数据交换，寄存器间数据传送必须通过ALU，不能直接传送\n系统总线：单总线结构。CPU，主存，I/O设备都直接挂接系统总线，包括地址总线，数据总线，控制总线。同步控制。\nCPU通过MAR（地址寄存器）向地址总线提供数据，选择外部设备，外部设备也可以向地址总线发送地址码。\nCPU通过MDR向数据总线发送或接收数据，通过R/W控制命令决定传送方向及MDR与数据总线的通断。\n\n\n控制总线：CPU和外部设备向控制总线发出或接收控制信号，主存通常只接收控制信号并提供回答信号。\n\n接口的概念？部件与部件（指硬件或软件）之间的交接部分称为接口；主机系统总线与I/O设备之间的交接部分称为I/O接口。\n类型按传送格式： 串行接口、并行接口 \n按时序控制： 同步接口、异步接口\n按信息传送控制方式：中断接口、DMA接口\n基本字长？一般是指参加一次定点运算的操作数的位数，如：8、16、32、64位，它影响计算精度、指令功能。\nCPU主频？时钟频率？\nCPU主频\n\n​    是计算机的振荡器输出的脉冲序列的频率，是计算机中一切操作所依据的时间基准信号，其高低决定了计算机工作速度的快慢。\n\n时钟频率\n\n​    是主频脉冲经分频后所形成的时钟脉冲序列的频率，两个相邻时钟脉冲之间的间隔时间是一个时钟周期时间，也称为节拍。\n数据通路宽度？数据传输率？\n数据通路宽度\n\n​    指数据总线一次能并行传送的数据位数。\n\n数据传输率\n\n​    指数据总线每秒传送的数据量，也称为数据总线的带宽。\n​    公式：$\\text { 总线带宽 }=\\frac{\\text { 总线数据通路宽度 } \\times \\text { 总线时钟频率 }}{8}(\\mathrm{BPS})$\n第二章 计算机中的信息表示基本概念及应用一个数值型数据的完整表示需三个方面？\n数的组合规则：进位计数制\n小数点的位置确定：数的定点表示和浮点表示\n符号的选择：带符号数的代码表示\n\n权、基数？基数：每个数位中所允许的最大数码值+1或每个数位中所允许的最多数码个数。\n权：是一个与所在数位相关的常数。\n真值？机器数的定义？分类？真值：数据真实的值\n机器数是将符号数字化的数，是数字在计算机中的二进制表示形式\n分类：原码补码反码\n数的定点表示与浮点表示？定点表示：分为定点整数、定点小数、不定点整数\n浮点表示：IEEE754的标准，数符（S），阶码（E），尾数（M）\n指令？指令系统？指令：按某种规律有序排列的、能被CPU识别并执行的二进制代码\n指令系统：一台计算机能执行的所有指令的集合\n地址码？寻址方式？地址结构？地址码地址码包括指令中给出操作数或操作数的地址、存放运算结果的地址、下一条指令的地址。\n寻址方式：将产生操作数有效地址的方式称为寻址方式。\n大致可将众多的寻址方式归纳为以下四大类，其它的寻址方式则是它们的变型或组合。\n\n立即寻址。在读取指令时也就从指令之中获得了操作数，即操作数包含在指令中。\n\n直接寻址类。直接给出主存地址或寄存器编号，从CPU内或主存单元内读取操作数。\n\n间接寻址类。先从某寄存器中或主存中读取地址，再按这个地址访问主存以读取操作数。\n变址类。指令给出的是形式地址（不是最终地址），经过某种变换（例如相加、相减、高低位地址拼接等），才获得有效地址，据此访问主存储器以读取操作数。\n\n直接寻址与寄存器寻址方式的比较\n直接寻址是访问一次主存才能读取所需操作数\n\n寄存器寻址是从CPU的寄存器中读取操作数，不需访问主存，所需时间大约是从主存中读数时间的几分之一到几十分之一，因而寄存器寻址比直接寻址快得多。\n\n\n\n\n\n\n\n\n\n注意：减少指令中地址数目与减少一个地址的位数是两个不同的概念。\n采用隐地址可以减少指令中地址的数目；\n采用寄存器寻址方式、寄存器间址方式可以使指令中为给出一个地址所需的位数减少。\n其实，均减少了指令长度。\n\n\n地址结构\n显地址：在指令代码中明确给出了主存储器单元地址码或者寄存器号\n隐地址：如果地址是以隐含的方式约定，则在指令中并不给出地址码\n\n何谓隐式I/O指令？其主要特点是什么？若将外围设备接口中的寄存器与主存单元统一编址，由同样的总线地址访问。这样，外设便可看作是总线地址所覆盖的存储空间的一部分，因而主机可以通过传送指令用相同的方式访问存储器和外围设备。对存储器的各种寻址方式同样适合于对外设的寻址，使编制程序灵活方便。这种I/O指令是隐含在传送指令之中的，所以又称为隐式I/O指令。\n特点地址码本身可区分存储单元地址和IO端口地址，无需其他操作，采用通用的数据传送指令即可\n主机调用外围设备，外设编制可采用那几种方式？单独编址：\n为每个寄存器（IO端口）分配独立的端口地址，IO指令中给出端口地址，在处理器的指令集中，需要有专门的IO指令来读写端口\n统一编址：\nIO端口占用CPU提供的地址空间的一部分，比如CPU提供的全部地址空间的低地址部分用于主存单元、高地址部分分配给IO端口以示区分。地址码本身即可区分存储单元和IO端口\n计算题扩展操作码：根据条件计算指令条数？\n设地址长度为n，上一层留出m种状态，下一层便可扩展出$m\\times 2^n$种状态。\n根据寻址方式寻找操作数？立即寻址指令中在操作码字段后面的部分是操作数本身，也就是在取出指令的同时也就取出了可以立即使用的操作数。\n\n立即寻址：绝对地址\n由指令直接给出操作数地址，根据该地址可读取或写入操作数，这种方式称为直接寻址方式。\n\n直接寻址：主存直接寻址\n若指令中给出的地址码是主存的某个单元号，操作数存放在该指定的主存单元中，这种寻址方式称为直接寻址或主存直接寻址方式。\n\n\n直接寻址：寄存器直接寻址\n\n若指令中给出的地址码是寄存器编号，操作数存放在该指定的寄存器中，这种寻址方式称为寄存器寻址或寄存器直接寻址方式。\n\n\n\n间接寻址\n主存间接寻址\n若指令中地址给出的是间址单元地址（即操作数地址的地址，而不是操作数地址，且在主存），从中读取操作数地址，按照操作数地址再次访问主存，从相应单元中读写操作数，这种寻址方式称为间接寻址或主存间接寻址方式。\n\n\n\n寄存器间接寻址\n若指令中给出的地址码是寄存器编码，被指定的寄存器中存放的是操作数地址，按照该地址访问某主存单元，该单元的内容为操作数，这种寻址方式称为寄存器间接寻址。\n\n\n\n\n间接寻址的变形\n自减型寄存器间址\n若指令中给出寄存器号，被指定的寄存器内容先减1后作为操作数地址，按照该地址访问主存储器，相应的主存单元内容为操作数，自减型寄存器间址方式常用助记符-(R)表示。 \n\n\n\n堆栈寻址\n堆栈寻址方式是指操作数在堆栈中，指令隐含约定由堆栈指针SP寄存器提供栈顶单元地址（SP也可以编码形式出现在指令中），进行读出或写入的一种寻址方式。 \n\n\n压栈：寄存器号$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数地址 = (SP) - 1 $~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数\n操作数与寄存器SP的关系为：S = ((SP - 1))\n\n出栈：寄存器号$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数地址$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数\n操作数与寄存器SP的关系为：S = ((SP))，弹出后修改堆栈指针：(SP) + 1 $\\rightarrow$ SP\n\n\n\n\n变址寻址若指令中给出变址寄存器号和一个形式地址，变址寄存器的内容(称为变址量)与形式地址相加，得到操作数有效地址(即操作数实际地址)，按照有效地址访问某主存单元，该单元的内容即为操作数，这种寻址方式称为变址寻址方式。变址方式常用助记符X(R）表示。\n\n\n\n基址寻址\n若指令中给出基址寄存器号和一个形式地址，基址寄存器内容（作为基准地址）与形式地址（作为位移量）相加，其和为操作数有效地址(即操作数实际地址)，按照该地址访问主存储器，该单元的内容即为操作数，这种寻址方式称为基址寻址。\n\n\n\n相对寻址\n若指令中选定程序计数器PC作为变址寄存器，或是隐含地指定PC，指令中给出的形式地址作为位移量（可正、可负），二者相加后形成操作数的有效地址。这种寻址方式实际上就是以当前指令位置为基准，相对它进行位移定位（往前或往后），所以称为相对寻址。\n程序计数器PC的内容为现行指令地址A，按地址A从主存中读取指令;\n指令中形式地址段给出位移量d，它是从现行指令位置到操作数S所在单元之间的距离（单元数）;\n\n\n==特别注意==\n对于转移指令JMP A，当CU从存储器中取出一个字节时，会自动执行PC++。若转移指令的地址X占用两个字节，那么取出该指令后，PC会加2，即（PC） = X + 2。因此执行完该指令要跳到的指令位置是：X+2+A，不是X+1+A。\n\n页面寻址\n将PC内容的高位段与位移量相拼接,相对寻址就演变成页面寻址。\n程序计数器PC的内容为A，指令中形式地址段给出位移量d。\n\n\n\nIEEE754短浮点数格式表示？\n\n短浮点数（或称短实数、单精度浮点数，32位）\n\n长浮点数（或称长实数、双精度浮点数，64位）\n\n临时浮点数（或称临时实数、扩展精度浮点数，80位）\n\n\n\n根据浮点数的尾数规格化，我们省略了一位数字$2^0$，所以实际上尾数数值应该有24位。\n十进制真值转换为浮点数：\n\n先将十进制转换为二进制\n规格化二进制数（隐藏尾数最高位1，还原为真值时需要加回来）\n计算移码表示的阶码，表示为二进制（偏置值+阶码真值）\n以短浮点数格式存储该数\n\n例题\n\n\n\nIEEE754转为十进制真值单精度浮点计算公式\n$(-1)^{S} \\times 1 . M \\times 2^{E-127}\\left\\{\\begin{array}{l}S: \\text { 符号位 (1为负, } 0 \\text { 为 正) } \\\\M: \\text { 尾数, 表示小数 } \\\\E: \\text { 阶码 }\\end{array}\\right.$\n其他精度只需更换对应的偏置值即可。\n\n第三章 中央处理器基本概率及应用CPU内部各寄存器的功能？通用寄存器组一组可编程访问的寄存器，可以提供操作数、运算结果、地址指针、计数器等多种功能。\n在指令系统中为这些R分配了编号，有：R0~R3，PC，SP，PSW。\n模型机中：R0、R1、R2、R3\n8086微机中：AX、BX、CX、DX、SP、BP、SI、DI\n暂存器用户不能直接访问的R，用来暂存信息，在指令系统中没有为它们分配编号，有C、D。\n暂存器C：从主存中读取源操作数或源操作数地址时，使用它。\n暂存器D：从主存中读取目的作数或目的操作数地址时，或中间运算结果时，使用它。\n指令寄存器IR用来存放现行运行指令，它的输出是产生微操作命令序列的主要逻辑依据。\n程序计数器PCPC提供后继指令地址，并送往与主存器相连接的地址寄存器（MAR）。\n后继指令地址=PC+n，模型机中为了简化起见，令n=1，1为单位指令长度\n程序状态字寄存器PSW（Program Status Word）PSW的内容就是表现的现行程序的状态。\n包括：\n\n特征位：进位C、溢出V、零Z、负N，允许中断I等； \n\n编程设定位。\n\n\nCPU访问主存时，首先送出地址码，然后送出/接收数据，需：\n\n当作用在MAR上的微命令EMAR为低电平时，MAR输出呈高阻态，与地址总线断开\n当作用在MAR上的微命令EMAR为高电平时，MAR输出其内容（地址信息）送往地址总线；\n\n地址寄存器MAR存放被访问单元的地址。读取指令/存取操作数/操作数地址时，CPU先将地址信息送入MAR，再由MAR经地址总线送往主存M，找到相应的主存单元。\n数据寄存器MBR（MDR）存放CPU与主存之间交换的数据。无论是从主存读出的数据还是写入的数据都要经过MBR（MDR）。由控制命令R/W决定传送方向。\nR：由主存单元$~\\rightarrow~$数据总线$~\\rightarrow~$MDR\nW：由MDR$~\\rightarrow~$数据总线$~\\rightarrow~$数据单元\n数据通路结构？\n各个寻址方式及数据传送的数据通路看计组复习-2  \n何谓同步控制方式，何谓异步控制？有何主要特征？应用场合？同步控制各项操作与统一的时序信号同步称为同步控制。\n\n特点\n\n时钟周期时间固定\n各步操作的衔接、各部件之间的数据传送受严格同步时钟定时控制，一般采用由CPU提供的统一时序信号来控制部件间信息的传送。\n\n\n应用\n用于CPU内部，设备内部、系统内部。\n\n\n异步控制异步控制是指各项操作按其需要选择不同的时间，不受统一的时钟周期的约束；各操作之间的衔接与各部件之间的信息交换采取应答方式。\n\n特点：\n没有统一的节拍划分与同步定时脉冲。\n\n应用\n用于异步总线操作（各挂接部件速度差异大、传送时间不确定、传送距离较远等）。\n\n\n何谓主从设备，试举例说明申请使用总线，并获得批准后掌管总线控制权的设备，称为主设备，否则为从设备。\n\n主设备：申请并掌握总线权的设备。\n从设备： 响应主设备请求的设备。\n\n同步控制中如何引入异步应答的，试举例说明以固定时钟周期作为时序基础，引入应答思想。\n\n微程序控制思想的基本要点是什么？\n将控制器所需的微命令，以代码（微码）形式编成微指令，存入一个ROM构成的控制存储器中。……将存储逻辑引入CPU。\n\n将各种机器指令的操作分解为若干微操作序列。  \n……将程序技术引入CPU的构成级。\n\n\n上面从两个角度阐明了微程序控制的基本概念：\n\n微命令的产生方式\n微程序与机器指令之间的对应关系\n\n判断下面叙述是否正确，说明理由：串行加法器中的进位链是串行进位链，并行加法器中的进位链只有并行进位链。错，并行加法器中的进位链可以并行串行结合\n常用的加法器进位链结构有哪几种？\n串行进位链\n并行进位链\n\n组合逻辑控制器、微程序控制器有何区别？控制器：控制部件的主要功能是负责对指令进行译码，并且发出为完成每条指令所要执行的各种操作的控制信号（微命令）\n\n组合逻辑控制方式：综合化简产生微命令的方式，形成逻辑式，由组合逻辑电路产生微命令；\n优缺点：产生微命令的速度较快、设计不规整，设计效率低、不易修改、扩展指令系统功能。\n应用场合：用于高速计算机，或小规模计算机\n\n微程序控制方式 ：设计CPU时，根据指令系统事先编制好微程序，并存入控制存储器（CM\n\n\n组合逻辑控制器、微程序控制器的时序系统是如何划分的？采用三级时序系统：工作周期、时钟周期、工作脉冲\n\n工作周期：FT、ST、DT、ET、DMAT、IT\n\n时钟周期（节拍）：以访存时间作为一步操作时间\n\n工作脉冲：同步定时脉冲控制定时操作，每个时钟周期结束时设置一个脉冲\n\n\n微命令、微操作、微指令、微指令周期、微程序？\n微命令：构成控制信号序列的最小单位，又称微信号，指那些直接作用于部件或控制门电路的命令。\n\n​    如：打开或关闭某传送通路的电信命令，或对触发器或R进行同步打入，置位、复位等的控制脉冲。\n\n微操作：由微命令控制实现的最基本的操作称为微操作，如：开门、关门、选择。\n\n微周期：从控制存储器中读取一条微指令并执行相应的一步操作所需的时间，称为一个微周期或微指令周期。通常一个时钟周期为一个微周期。\n\n微指令：每个微周期的操作所需的微命令组成一条微指令。从控制存储器的组织角度讲，每个单元存放一条微指令。\n微程序：一系列微指令的有序集合称为微程序，用来解释执行一条机器指令。\n\n1位全加器的结构及关系表达式。\n$\\begin{array}{l}\\Sigma_{i}=\\left(A_{i} \\oplus B_{i}\\right) \\oplus C_{i-1} \\\\C_{i}=A_{i} B_{i}+\\left(A_{i} \\oplus B_{i}\\right) C_{i-1}\\end{array}$\n时序信号？时序系统？\n时序信号：计算机操作的时间标志\n时序系统：即时序信号与操作的关系，用于规定各项操作所需的时间和时机\n\n计算题$C_{i}=A_{i} B_{i}+\\left(A_{i} \\oplus B_{i}\\right) C_{i-1}$\n令\n$G_{i}=A_{i} B_{i}$进位产生函数（ 本地进位 ）\n$P_{i}=A_{i} \\oplus B_{i}$进位传递函数（传递进位）\n并行加法器中的串行进位链结构：$C_n = G_n + P_nC_{n-1}$各级进位信号直接依赖于低一级的进位信号。\n关系式：\n$\\begin{array}{l}\\mathrm{C}_{1}=\\mathrm{G}_{1}+\\mathrm{P}_{1} \\mathrm{C}_{0} \\\\\\mathrm{C}_{2}=\\mathrm{G}_{2}+\\mathrm{P}_{2} \\mathrm{C}_{1} \\\\\\cdots \\cdots \\\\\\mathrm{C}_{\\mathrm{n}}=\\mathrm{G}_{\\mathrm{n}}+\\mathrm{P}_{\\mathrm{n}} \\mathrm{C}_{\\mathrm{n}-1}\\end{array}$\n\n结构简单，运算较慢\n并行进位链结构：$C_n = G_n + P_nG_{n-1}+ … + P_n…P_1C_0$各级进位信号是并行（同时）形成的。\n关系式：\n$\\begin{array}{l}C_{1}=G_{1}+P_{1} C_{0} \\\\C_{2}=G_{2}+P_{2} G_{1}+P_{2} P_{1} C_{0} \\\\\\cdots \\cdots \\\\C_{n}=G_{n}+P_{n} G_{n-1}+\\cdots+P_{n} \\cdots P_{1} C_{0}\\end{array}$\n\n结构复杂，运算快\n原码一位乘法（要求运算过程）取两个操作数的绝对值相乘，每步处理一位乘法，符号位单独处理。\n运算规则\n寄存器分配与初始值：ABC三个寄存器\n\nA存放部分积累加和，初始值为0（双符号位00表示）\nB存放被乘数X（绝对值），此时，符号位为双符号位00（在乘的过程中，B中的值一直保持不变）\nC存放乘数Y（绝对值），将符号位去掉；C寄存器的初始值是乘数Y的尾数（有效位数），以后每乘一次，将已处理的低位乘数右移舍去，同时将A寄存器的末位移入C寄存器的高位。\n\n\n符号位：A，B均设置双符号位\n\n基本操作\nC存放乘数Y（绝对值），将符号位去掉\nC寄存器的初始值是乘数Y的尾数（有效位数），以后每乘一次，将已处理的低位乘数右移舍去，同时将A寄存器的末位移入C寄存器的高位。\n\n\n\n在原码一位乘中，每步只处理一位乘数，即位于C寄存器末位的乘数，也称之为判断位Cn：\n\n若$C_n=1$，则部分积为B，执行A+B操作，然后将累加和右移一位，用“→”表示\n若$C_n=0$，则部分积为0，执行A+0操作，然后右移。或直接让A右移一位。 \n\n右移时，A的末位移入C的高位，A的第二符号位移入尾数最高位，第一符号位移入第二符号位，而第 一符号位本身则补0。\n\n操作步骤：\nN次累加与n次移位（最后一次累加后要移位）\n\n加符号位\n\n微命令设置\n$\\begin{array}{l}C_{n}=1, \\text { 即 } A+B:+A 、+B 、(A+B), \\Sigma / 2 \\rightarrow A 、 \\vec{C}, C P_{A} 、 C P_{C} \\\\C_{n}=0, \\text { 即 } A+0:+A 、(A), \\Sigma / 2 \\rightarrow A, \\vec{C}, C_{A} 、 C P_{C}\\end{array}$\n\n\n\n设计题CPU的逻辑组成及工作机制\nCPU的逻辑组成（模型机框图）\nCPU的逻辑组成→模型机框图\n\n\n\n\n\n\n\n\n\n见第三章数据通路结构\n\nCPU内每个寄存器的作用\n\n\n\n\n\n\n\n\n\n见第三章CPU内各寄存器的功能\n\n总线的分类及定义\n\n\n\n\n\n\n\n\n\n见第一章总线及其组成\n\n控制器的分类及区别\n\n\n\n\n\n\n\n\n\n见第三章组合逻辑控制器、微程序控制器\n\n\nCPU的指令流程\n指令类型：MOV指令、双操作数算数逻辑运算指令、单操作数算数逻辑运算指令、转移/返回指令、转子指令；（主要以MOV指令、双操作数算数逻辑运算指令为主）\n\n\n\n\n\n\n\n\n核心是寻址方式：立即寻址、R、(R)、-(R)、(R)+、@(R)+、X(R)\n\n\n\n操作时间表的安排（微命令的安排）：\nCPU数据通路操作：按照数据的流向分成四段\n\n​    ALU输入选择→AUL功能选择→移位器功能选择→分配脉冲（打入到寄存器中的脉冲）；\n\n与访问主存有关的微命令。\n不同工作周期切换时：例如从ST切换到DT则有微命令1→DT, CPT, CPFT, CPST, CPDT, CPET\n相同工作周期内时钟周期的切换：例如ST0到ST1有微命令1→T, CPT\n数据读取相关操作：EMAR, R, EMDR\n数据写入相关操作：EMAR, W\n写入操作通常在ET发生\n都经过MAR的原因是MAR的功能\n\n\n\nFT：在FT中完成的操作是公共性操作\n\n\n\n\n指令流程\n操作时间表\n\n\n\n\nM→IR\nEMAR、R、SIR\n\n\nPC+1→PC\nPC→A、A+1、DM、CPPC、1→ST\n\n\n\nCPT（P）、CPFT（P）、\n\n\n\nCPST（P）、CPDT（P）、CPET（P)\n\n\n\n\nST：如果需要从主存中读取源操作数（非寄存器寻址），则进入ST\nDT：如果需要从主存中读取目的地址或目的操作数（非寄存器寻址），则进入DT\nET：取得操作数后，CPU进入E，这也是各类指令都需经历的最后一个工作阶段\n\n\n\n\n指令流程\n操作时间表\n\n\n\n\nC→MDR\nC→A、输出A、DM、CPMDR、T+1、CPT（P）\n\n\nMDR→M\nEMAR、W、T+1、CPT（P），\n\n\nPC→MAR\nPC→A、输出A、DM、CPMAR、1→FT\n\n\n\nCPT（P）、CPFT（P）、 CPST（P）、CPDT（P）、CPET（P）\n\n\n\n\n(R)\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nRi→MAR\nRi→A/B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\n1→DT？\nCPDT？\n\n\n\n\n1→ET？\nCPET？\n\n\n\n\n-(R)\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nRi-1→Ri，MAR\nRi→A/B\n\n\n\n\n\n在ALU中A-1\n\n\n\n\n\nDM\nCPMAR,CPR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\n1→DT?\nCPDT?\n\n\n\n\n1→ET?\nCPET?\n\n\n\n\n(R)+\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nRi→MAR\nRi→A/B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\nT+1\nCPT\n\n\nST2\nRi+1→Ri\nRi→A/B\n\n\n\n\n\n在ALU中A+1\n\n\n\n\n\nDM\nCPRi\n\n\n\n\n1→DT？\nCPDT？\n\n\n\n\n1→ET？\nCPET？\n\n\n\n\n@(R)+\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nRi→MAR\nRi→A/B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\nT+1\nCPT\n\n\nST2\nRi+1→Ri\nRi→A/B\n\n\n\n\n\n在ALU中A+1\n\n\n\n\n\nDM\nCPRi\n\n\n\n\nT+1\nCPT\n\n\nST3\nC→MAR\nC→A/B\n\n\n\n\n\n在ALU中传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST4\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\n1→DT?\nCPDT?\n\n\n\n\nX(R)\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nPC→MAR\nPC→A\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\nT+1\nCPT\n\n\nST2\nPC+1→PC\nPC→A\n\n\n\n\n\n在ALU中A+1\n\n\n\n\n\nDM\nCPPC\n\n\n\n\nT+1\nCPT\n\n\nST3\nRi+C→MAR\nRi→A/B,C→B/A\n\n\n\n\n\n在ALU中A+B\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST4\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\n1→DT？\nCPDT？\n\n\n\n\n1→ET？\nCPET？\n\n\n\n\n第四章 存储子系统基本概念及应用主存、缓存、外存？存储系统层次结构（典型结构）：三级存储体系结构\n\nCache：容量小、速度高\n主存：容量较大、速度较高\n外存：容量大、速度慢\n\n主存储器能由CPU直接编程访问的存储器，它存放当前CPU需要执行的程序与需要处理的数据。\n特点：存取速度快，容量有限\n为满足CPU编程直接访问的需要，对主存储器的基本要求有三条：\n\n随机访问\n工作速度快\n具有一定的存储容量\n\n外存储器用来存放需要联机保存但暂不使用的大量程序与数据。\n特定：存取速度较慢，容量很大\n程序与数据只有进入主存才能真正运行，而外存储器是作为后援的。 \n高速缓存（Cache）高速缓存中存放的是最近要使用的程序与数据，作为主存中当前活跃信息的副本。\n特点：存取速度很快，容量很小\n高速缓存Cache用来存放什么内容？设置它的主要目的是什么？\n用来存放当前活跃的数据与程序，作为主存活跃区的副本\n设置它，是为了解决cpu与主存的速度匹配\n\n存储介质？\n磁芯存储器\n半导体存储器\n磁表面存储器\n光盘存储器\n\n何谓随机存取？何谓顺序存取？何谓直接存取？请各试举一例。随机存取（RAM）\n可按地址随机地访问任一存储单元\n访问各存储单元所需的读/写时间相同\n\n应用：主存、高速缓存\n\n\n顺序存取（SAM）顺序存取存储器的信息是按记录块组织、顺序存放的，访问时间与信息存放位置有关。\n磁带是采取顺序存取方式的存储器。\n直接存取（DAM）访问时读/写部件先直接指向一个小区域，再在该区域内顺序查找。访问时间与数据位置有关。\n例如磁盘、光盘。\n静态存储器SRAM、动态存储器DRAM存储原理？\n静态存储器：利用双稳态触发器存储信息\n\n动态存储器：利用电容存储的电荷存储信息\n\n\n动态刷新分为哪几种情况，各有什么特点？动态MOS存储单元：\n四管单元：保持原状态需要定期向电容补充电荷。读出是非破坏性读出，读出过程即实现刷新\n单管单元： 单管单元是破坏性读出，读出后需重写\n最大刷新间隔：2ms，必须对所有动态单元刷新一遍\n刷新方法：\n\n单管动态存储器，读出时能自动重写补充电荷\n各动态芯片可同时刷新，片内按行刷新\n\n刷新周期（存取周期）：刷新一行需要的时间\n刷新周期数：刷新一片芯片所需的周期数由芯片矩阵的行数决定\n对主存的访问：\n\nCPU访存：由CPU提供行列地址随机访问\n芯片刷新：由刷新地址计数器提供地址定时刷新\n\n刷新周期的安排方式：\n\n集中刷新：2ms内集中安排所有刷新周期。用于实时要求不高的场合\n分散刷新：各刷新周期分散安排在存取周期中。造成主存利用率降低，用在低速系统中\n异步刷新：刷新周期分散安排在2ms内。\n\n刷新、重写的区别？刷新：非破坏性读出的动态M，需补充电荷以保持原来的信息。\n重写：破坏性读出后重写，以恢复原来的信息。\n全地址译码方式？部分地址译码方式？全地址移码方式==将除了与芯片连接的地址以外的所有高位地址用于译码产生片选信号==\n就是构成存储器时要使用全部地址总线信号，即所有的高位地址信号都用来作为译码器的输入，低位地址信号接存储芯片的地址输入线，从而使存储器芯片上的每一个单元在整个内存空间中具有唯一的地址。\n部分地址译码==将除了与芯片连接的地址外的部分高位地址用于译码产生片选信号（易出现地址重叠）==\n就是仅把地址总线的一部分地址信号线与存储器连接，通常是用高位地址信号的一部分（而不是全部）作为片选译码信号；低位地址信号接存储芯片的地址输入线。\n设计题半导体存储器逻辑设计：(地址分配、片选逻辑、逻辑框图)，片选逻辑采用全/部分译码方式。\n半导体的组织\n\n\n第五章 I/O系统基本概念及应用系统总线上一般包含哪三组信息？分为地址、数据、控制线，包含对应的三组信息。\n\n数据总线：传输数据信息，决定总线宽度\n地址总线：传输地址信息，决定寻址能力\n控制总线：传输控制信息和状态信息\n\n中断方式定义、实质、特点？\n定义：\nCPU暂时中止现行程序的执行，转去执行为某个随机事态服务的中断处理程序。处理完毕后自动恢复原程序的执行。\n\n实质：程序切换\n\n方法：保存断点、保护现场、恢复现场、返回断点\n时间：一条指令结束时切换，保证程序的完整性\n\n\n特点：随机性\n\n随机发生的事态（按键，故障等）\n有意调用，随机请求与处理的事态（调用打印机）\n随机插入的事态（软中断指令插入程序任何位置）\n\n\n\n中断向量、中断向量表、向量地址？\n中断类型码：每个中断源对应的编号\n中断向量：中断服务程序入口地址\n中断向量表：存放各中断服务程序的入口地址的单元\n向量地址：访问中断向量表的地址码，可通过计算中断类型码得到\n模型机中：向量地址=中断号+2\nIBM PC向量表：向量地址 = 中断号 * 4\n\n\n\n何谓向量中断？何谓非向量中断？各有何优点和缺点？非向量中断：由软件查询提供服务程序入口地址\n\n优点：依靠硬件操作，响应快速\n缺点：逻辑复杂，调整优先级较麻烦\n\n向量中断：由硬件直接提供服务程序入口地址\n\n优点：硬件逻辑简洁，调整优先级方便\n缺点：响应速度慢\n\n单级中断、多重中断？\n单级中断：\nCPU响应后只处理一个中断源的请求，处理完毕后才能响应新的请求。\n\n多级中断\n在某次中断服务过程中，允许响应处理更高级别的中断请求。\n允许多重中断的处理方式：\n\n\n流程\n\n\n\n中断控制器8259A的工作原理？IRR 中断请求寄存器（Interrupt Request Register）：8位，可存放8个中断请求信号，作为向CPU申请与判优、编码的依据。\nPR 优先级裁决器（Priority Resolver）：即中断源的优先级排队逻辑，选择优先级最高的中断申请者。\nISR 中断服务寄存器（Interrupt Service Register）：8位，用来存放或记录正在服务中的所有中断请求优先级（如在多重嵌套时），每一位对应一个中断优先级。\nIMR 中断屏蔽寄存器（Interrupt Mask Register）：8位，其内容可由CPU预置。这就是前面提到的集中屏蔽方式，各接口可以提出自己的中断请求信号，在8259A中再与屏蔽字比较。对应位（IMRi）若为1，则该请求（IRRi）被屏蔽，不会被送往CPU。\n\n当一个中断请求从IRQ0到IRQ7中的某根线到达 IMR时， IMR首先判断此IR是否被屏蔽，如果被屏蔽，则此中断请求被丢弃；否则，则将其放入IRR中。\n8259比较ISR和IRR中的优先级，若IRR有优先级高的外部中断请求，则通过发送一个 INT信号给 CPU，通知CPU有一个中断到达。\nCPU收到这个信号后，会暂停执行下一条指令，然后发送一个INTA信号给 8259。\n8259收到这个信号后， 将中断号送到数据总线上 。\nCPU从数据总线读取中断号，形成中断服务程序的入口地址（中断周期）。转入中断服务程序。\n\n转子与中断调用的相似、区别？相同点：程序切换\n不同：\n\n转子子程序的执行是由程序员事先安排好的，而中断服务程序的执行则是由随机的中断事件引起的调用。\n\n转子子程序的执行受到主程序或上层子程序的控制，而中断服务程序一般与被中断的现行程序没有关系。\n\n不存在同时调用多个转子子程序的情况，而可能发生多个外设同时请求CPU为自己服务的情况。\n\n\nDMA方式定义、实质、特点？依靠硬件直接在主存与外围设备之间进行数据传送，在传送过程中不需要CPU的干预，传送结束后通常通过中断方式通知 CPU 。\n\n特点\n响应随机请求\n不影响CPU 程序的执行，仅占用总线、无程序切换\n大批量数据的简单传送\n\n\n应用：\n主存和高速IO设备之间的简单数据传送\n大批量数据采集系统\n动态存储器DRAM的自动刷新\n\n\nDMA传送过程\n\n程序准备：主程序实现初始化（对DMA控制器和接口\n\n传送请求\n\nDMA传送：存储器—直传—IO（硬件实现）\n善后处理：执行中断处理程序\n\n\n\n程序直传方式，中断方式，DMA方式之间的区别？直接程序传送：依靠CPU 直接执行相关的 IO 程序来实现数据的输入和输出控制 。\n中断方式：设备提出中断请求，主机响应后与设备交换信息，接口中包含中断控制请求。\nDMA方式：直接依靠硬件系统来控制主存和设备之间的数据传送，传送期间无需 CPU 干预，传送结束后通常通过中断方式通知 CPU, 支持高速外设与主存之间进行 DMA 方式交换数据。\n计算题在8259A中，如何通过IRR、IMR、ISR的值，判断中断接口是否向CPU发INT信号。\n如何根据中断类型码（或中断号）生成向量地址。\n模型机中：向量地址=中断号+2\nIBM PC向量表：向量地址 = 中断号 * 4\n\n","slug":"计组复习提纲Q-A","date":"2023-12-22T15:35:21.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"231c4a8897ba629b993d7680d474099c","title":"概率论公式整理-2","content":"🎈第四章 随机变量的数字特征数学期望设$  X  $是离散型随机变量,其分布律为\n$P\\left\\{X=x_{i}\\right\\}=p_{i}, \\quad i=1,2,3 \\ldots .$\n若$  \\sum_{i=1}^{+\\infty}\\left|\\boldsymbol{x}_{\\boldsymbol{i}}\\right| \\boldsymbol{p}_{\\boldsymbol{i}}&lt;+\\infty  $则称\n$  E(X)=\\sum_{i=1}^{+\\infty} x_{i} p_{i}  $为$  X  $的数学期望（均值）。\n设连续型随机变量$  X  $的概率密度为$  f(x)  $，若 \n$ \\int_{-\\infty}^{+\\infty}|x| f(x) d x&lt;+\\infty $\n称$ E(X)=\\int_{-\\infty}^{+\\infty} x f(x) d x $为$  X  $的数学期望(均值)。\n\n\n\n\n\n\n\n\n\n随机变量的数学期望是它所有可能取值的加权平均值，是一个数。\n部分随机变量$  X  $的数学期望不存在。定义中要求条件无穷级数\n$\\sum_{i=1}^{\\infty} x_{i} p_{i}$\n绝对收敛, 保证数学期望有唯一的数值。如果绝对收敛不能得到满足, 称随机变量的数学期望不存在。\n常用期望\n两点分布：$E(X)=p$\n$X\\sim B(n,p)$：$E(X)=np$\n$X\\sim P(\\lambda)$：$E(X)=\\lambda$\n均匀分布：$E(X)=(a+b)/2$\n指数分布：$E(X)=\\lambda^{-1}$\n正态分布：$E(X)=\\mu$\n\n随机变量的函数的数学期望（本章核心）设$  Y  $是随机变量$  X  $的函数$  Y=g(X) ,  g(x)  $为连续函数\n\n$X  $是离散型随机变量，分布律为\n$\\boldsymbol{P}\\left\\{X=\\boldsymbol{x}_{i}\\right\\}=\\boldsymbol{p}_{i}, \\quad \\boldsymbol{i}=1,2,3 \\ldots .$\n\n\n​    若$  \\sum_{i=1}^{+\\infty} g\\left(x_{i}\\right) p_{i}  $绝对收敛，则有\n​    $E(Y)=E[g(X)]=\\sum_{i=1}^{+\\infty} g\\left(x_{i}\\right) p_{i}$\n\n$X  $是连续型随机变量，其概率密度为$  f_{X}(x) $。\n若$  \\int_{-\\infty}^{+\\infty} g(x) \\mid f(x)&lt;+\\infty  $\n则$  E(Y)=E[g(X)]=\\int_{-\\infty}^{+\\infty} g(x) f_{X}(x) d x $\n\n\n设$  (X, Y)  $是二维随机变量, 如果$  Z=G(X, Y)  $也是同类型随机变量并且数学期望存在, 则有\n\n当$  (X, Y)  $是离散型随机变量时 \n\n​    $E(Z)=\\sum_{i=1}^{\\infty} \\sum_{j=1}^{\\infty} G\\left(x_{i}, y_{j}\\right) p_{i j}$\n\n当$  (X, Y)  $是连续型随机变量时\n\n​    $E(Z)=\\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} G(x, y) f(x, y) d x d y$\n随机变量的数学期望的性质设$X,X_1,X_2,\\cdots,X_n$是随机变量，$c,b$是常数\n\n$E(c)=c$\n\n$E(cX)=cE(X)$\n\n$E(cX+b)=cE(X)+b$\n\n\n$E\\left(\\sum_{i=1}^{n} X_{i}\\right)=\\sum_{i=1}^{n} E\\left(X_{i}\\right)$\n\n若$  X_{1}, X_{2}, \\ldots ., X_{n}  $相互独立，则\n$E\\left(\\prod_{i=1}^{n} X_{i}\\right)=\\prod_{i=1}^{n} E\\left(X_{i}\\right)$\n\n\n方差设$  X  $是随机变量，若$  E\\left\\{[X-E(X)]^{2}\\right\\} $存在，称\n$D(X)=E\\left\\{[X-E(X)]^{2}\\right\\}$\n为$  X  $的方差。$ \\sigma(X)=\\sqrt{D(X)}  $称为$  X  $的标准差或均方差.\n\n\n\n\n\n\n\n\n\n\n$D(X) \\geq 0 $\n\n$D(X)  $是随机变量$  X  $的函数的数学期望；当$  X  为$离散型或连续型时，分别有\n$D(X)=\\sum_{i=1}^{+\\infty}\\left[x_{i}-E(X)\\right]^{2} P\\left\\{X=x_{i}\\right\\},$\n$D(X)=\\int_{-\\infty}^{+\\infty}[x-E(X)]^{2} f_{X}(x) d x$\n\n\n常用计算公式：\n$D(X)=E\\left(X^{2}\\right)-[E(X)]^{2}$\n常用方差\n$X\\sim B(n,p)$\n$E(X)=np$\n$D(X)=np(1-p)$\n\n\n$X\\sim P(\\lambda)$\n$E(X)=\\lambda$\n$D(X)=\\lambda$\n\n\n$X\\sim N(\\mu,\\sigma^2)$\n$E(X)=\\mu$\n$D(X)=\\sigma^2$\n\n\n均匀分布\n$E(X)=(a+b)/2$\n$D(X)=(b-a)^2/12$\n\n\n指数分布\n$E(X)=\\sqrt{D(X)}=\\frac 1\\lambda$\n$D(X)=\\frac 1{\\lambda^2}$\n\n\n$X\\sim N(\\mu,\\sigma^2)$\n$E(X)=\\mu$\n$D(X)=\\sigma^2$\n\n\n\n随机变量方差的性质设$X,X_1,X_2,\\cdots,X_n$是随机变量，$c,b$是常数\n\n$E(c)=c,D(c)=0$\n\n$E(cX)=cE(X),D(cX)=c^2D(X)$\n\n$E(\\sum_{i=1}^n)=\\sum_{i=1}^nE(X_i)$\n$D\\left(\\sum_{i=1}^{n} X_{i}\\right)=\\sum_{i=1}^{n} D\\left(X_{i}\\right)+2 \\sum_{\\substack{i=1 \\\\ j&gt;i}}^{n} E\\left\\{\\left[X_{i}-E\\left(X_{i}\\right)\\right]\\left[X_{j}-E\\left(X_{j}\\right)\\right]\\right\\}$\n\n\n​    若$X_1,X_2,\\cdots,X_n$相互独立，则\n​    $\\begin{array}{l}E\\left(\\prod_{i=1}^{n} X_{i}\\right)=\\prod_{i=1}^{n} E\\left(X_{i}\\right) \\\\D\\left(\\sum_{i=1}^{n} X_{i}\\right)=\\sum_{i=1}^{n} D\\left(X_{i}\\right)\\end{array}$\n\n$D(X)=0\\longleftrightarrow P\\{X=E(X)\\}=1$\n\n方差刻划了随机变量$ X $围绕其数学期望的偏离程度\n\n方差是随机变量$ X $关于任何值的偏离程度的最小值\n\n协方差&amp;相关系数&amp;矩协方差若$  E\\{[X-E(X)][Y-E(Y)]\\}  $存在，称\n$\\operatorname{Cov}(X, Y)=E\\{[X-E(X)][Y-E(Y)]\\}$\n为随机变量$  (X, Y)  $的协方差.\n$D(X \\pm Y)=D(X)+D(Y) \\pm 2 \\operatorname{Cov}(X, Y)$\n性质\n$D(X)=\\operatorname{Cov}(X, X) $\n$\\operatorname{Cov}(X, Y)=\\operatorname{Cov}(Y, X) $\n$\\operatorname{Cov}(a X, b Y)=a b \\operatorname{Cov}(X, Y), a, b  $是常数;\n\n$\\operatorname{Cov}(X, a)=0 $\n\n$\\operatorname{Cov}\\left(X_{1}+X_{2}, Y\\right)=\\operatorname{Cov}\\left(X_{1}, Y\\right)+\\operatorname{Cov}\\left(X_{2}, Y\\right) $\n$X, Y  $相互独立，$ \\operatorname{Cov}(X, Y)=0 $\n\n常用计算公式：$Cov(X,Y)=E(XY)-E(X)E(Y)$\n相关系数设二维随机变量$  X, Y  $的$  D(X)&gt;0 ,  D(Y)&gt;0 $，称\n$\\rho_{X Y}=\\frac{\\operatorname{Cov}(X, Y)}{\\sqrt{D(X)} \\sqrt{D(Y)}}$\n为随机变量  X  与  Y  的相关系数.\n\n$\\rho_{X Y} $是一无量纲的量\n\n标准化随机变量的协方差：\n$\\begin{aligned}\\rho_{X Y} &amp; =E\\left[\\frac{X-E(X)}{\\sqrt{D(X)}} \\cdot \\frac{Y-E(Y)}{\\sqrt{D(Y)}}\\right] \\\\&amp; =E\\left[X^{} Y^{}\\right]=\\operatorname{Cov}\\left(X^{}, Y^{}\\right)\\end{aligned}$\n\n\n性质设随机变量$X,Y$的相关系数$\\rho$存在，则\n\n$|\\rho|\\leq1$\n\n$|\\rho|=1\\longleftrightarrow X$与$Y$以概率为1线性相关，即\n存在$  \\alpha, \\beta,(\\alpha \\neq 0) $,\n$P\\{Y=\\alpha X+\\beta\\}=1$\n\n若$  \\xi=a_{1} X+b_{1}, \\eta=a_{2} Y+b_{2}  $则\n$  \\rho_{\\xi \\eta}=\\frac{a_{1} a_{2}}{\\left|a_{1} a_{2}\\right|} \\rho_{X Y} $\n\n\n相关系数是衡量两个随机变量之间线性相关程度的数字特征。\n\n若随机变量$  X, Y  $的相关系数$  \\rho_{X Y}  $存在,\n1) 若$  \\rho_{X Y}=1, P\\{Y=\\alpha X+\\beta\\}=1 $中的$  \\alpha&gt;0$，称$  X, Y  $正相关\n2)  $\\rho_{X Y}=-1 $，则$  \\alpha&lt;0  $称$  X, Y  $负相关2)  $\\rho_{X Y}=0$ ，称$  X, Y  $不相关\n\n\n\n$\\rho_{X Y}=0  $仅说明$  X, Y  $之间没有线性关系，但可以有其他非线性关系\n\n协方差矩阵设$  n  $维随机变量$  \\left(X_{1}, X_{2}, \\ldots, X_{n}\\right)  $的协方差\n$C_{i j}=\\operatorname{Cov}\\left(X_{i}, X_{j}\\right)$\n均存在，称矩阵$  C=\\left(c_{i j}\\right)  $为$  \\left(X_{1}, X_{2}, \\ldots, X_{n}\\right) $的协方差矩阵.\n$C=\\left[\\begin{array}{cccc}c_{11} &amp; c_{12} &amp; \\ldots &amp; c_{1 n} \\\\c_{21} &amp; c_{22} &amp; \\ldots &amp; c_{2 n} \\\\. &amp; . &amp; \\ldots &amp; . \\\\c_{n 1} &amp; c_{n 2} &amp; \\ldots &amp; c_{n n}\\end{array}\\right]$\n性质1)  $c_{i i}=D\\left(X_{i}\\right), \\quad i=1,2, \\ldots, n $2)  $c_{i j}=c_{j i}\\quad{i, j=1,2, \\ldots, n \\text {; }} $:，即对称阵3)  $C  $是非负定矩阵4)  $c_{i j}^{2} \\leq c_{i i} \\cdot c_{i j}, \\quad i, j=1,2, \\ldots, n $\n矩设$  X  $为随机变量, 若$  E\\left(|X|^{k}\\right)&lt;+\\infty $，称\n$\\gamma_{k}=E\\left(X^{k}\\right) \\quad k=1,2,3 \\ldots \\ldots$\n为$  X  $的$  k  $阶原点矩。\n称$  \\alpha_{k}=E\\left(|X|^{k}\\right), k=1,2,3 \\ldots . . $为$  X  $的$  k  $阶绝对原点矩。\n设$  X  $为随机变量，若$  E\\left[|X-E(X)|^{k}\\right]   &lt;+\\infty $，称\n$\\mu_{k}=E\\left\\{[X-E(X)]^{k}\\right\\} k=1,2,3 \\ldots \\ldots$\n为$  X $的$  k  $阶中心矩。\n称$  \\beta_{k}=E\\left[|X-E(X)|^{k}\\right] \\quad k=1,2,3 \\ldots \\ldots  $为$  X  $的$  k $阶绝对中心矩。\n注意到$  \\mu_{2}=D(X), \\gamma_{1}=E(X), \\gamma_{2}=E\\left(X^{2}\\right) $\n$\\mu_{2}=\\gamma_{2}-\\gamma_{1}^{2}$\n更一般的, 因$  \\mu_{1}=0 $, 可得$  \\gamma_{k}  $与$  \\mu_{k}  $的关系：\n$\\begin{aligned}\\gamma_{k}=E\\left(X^{k}\\right) &amp; =E\\left\\{[X-E(X)+E(X)]^{k}\\right\\} \\\\&amp; =E\\left\\{\\left[\\left(X-\\gamma_{1}\\right)+\\gamma_{1}\\right]^{k}\\right\\}\\\\&amp;=\\sum_{i=0}^{k} C_{k}^{i} \\gamma_{1}^{i} E\\left[\\left(X-\\gamma_{1}\\right)^{k-i}\\right] \\\\&amp;=\\sum_{i=0}^{k} C_{k}^{i} \\gamma_{1}^{i} \\mu_{k-i}\\end{aligned}$\n同理可得\n$\\mu_{k}=\\sum_{i=0}^{k}(-1)^{k-i} C_{k}^{i} \\gamma_{1}^{k-i} \\gamma_{i}$\n随机变量的矩是数。\n🎆第五章 大数定律与中心极限定理大数定律概率不等式马尔可科夫（Markov）不等式设随机变量$  Y  $的$  k  $阶绝对原点矩$  E\\left\\{|Y|^{k}\\right\\}&lt;   +\\infty $，则对于任意的$  \\varepsilon&gt;0 $，有\n$P\\{|Y| \\geq \\varepsilon\\} \\leq \\frac{E\\left\\{|Y|^{k}\\right\\}}{\\varepsilon^{k}}, \\quad k=1,2, \\cdots$\n切比雪夫（Chebyshev）不等式对马尔可科夫不等式特别取$  k=2 $，令$  Y=   X-E(X), E\\left\\{|Y|^{2}\\right\\}=D(X)  $存在，有切比雪夫不等式成立.\n设随机变量$  X  $的数学期望$  E(X)  $和方差$  D(X) $都存在，则对于任意的$  \\varepsilon&gt;0$ ，有\n$\\begin{array}{c}P\\{|X-E(X)| \\geq \\varepsilon\\} \\leq \\frac{D(X)}{\\varepsilon^{2}} \\\\\\text { 或者 } \\quad P\\{|X-E(X)|&lt;\\varepsilon\\} \\geq 1-\\frac{D(X)}{\\varepsilon^{2}} .\\end{array}$\n大数定律依概率收敛设$  X_{n},~~n=1,2 \\ldots  $是一个随机变量序列，$  X  $是一个随机变量或常数，若对于任意的$  \\varepsilon&gt;0$，有\n$\\lim _{n \\rightarrow \\infty} P\\left\\{\\left|X_{n}-X\\right| \\geq \\varepsilon\\right\\}=0$\n或者\n$  \\lim _{n \\rightarrow \\infty} P\\left\\{\\left|X_{n}-X\\right|&lt;\\varepsilon\\right\\}=1 $\n称随机变量序列$  \\left\\{X_{n}\\right\\}  $依概率收敛于$  X $，记为\n$X_{n} \\stackrel{P}{\\longrightarrow} X$\n或者$\\lim _{n \\rightarrow \\infty} X_{n}=X,(P)$\n\n\n\n\n\n\n\n\n\n\n在定义中，随机变量$  X  $也可以是常数$  a$，称随机变量序列$  \\left\\{X_{n}\\right\\}  $依概率收敛于常数$  a$ \n\n随机变量序列依概率收敛不同于微积分中数列或函数列的收敛性.\n\n\n随机变量序列$  \\left\\{X_{n}\\right\\}  $依概率收敛于$  X  $，指当$  n  $足够大时，有足够大的概率保证$  X_{n}  $任意接近于$  X $，但$  X_{n}  $仍然有可能与$  X  $相差很大。\n大数定律的定义设$  X_{n}, n=1,2 \\ldots  $是随机变量序列，其数学期望都存在，若对于任意的$  \\varepsilon&gt;0 $, 有\n$\\lim _{n \\rightarrow \\infty} P\\left\\{\\left|\\frac{1}{n} \\sum_{i=1}^{n} X_{i}-\\frac{1}{n} \\sum_{i=1}^{n} E\\left(X_{i}\\right)\\right|&lt;\\varepsilon\\right\\}=1$\n称随机变量序列$  \\left\\{X_{n}\\right\\}  $服从大数定律。\n服从大数定律的概率意义:  $\\left\\{X_{k}\\right\\}, k=1,2 \\ldots $的前$  n  $项算术平均将紧密地聚集在其数学期望的附近。\n切比雪夫大数定律设$ X_{k}, k=1,2 \\ldots  $是相互独立的随机变量序列，其数学期望和方差都存在，且存在常数$  C$，使得\n$D\\left(X_{n}\\right)&lt;C, k=1,2, \\ldots$\n则随机变量序列$  \\left\\{X_{k}\\right\\}, k=1,2 \\ldots  $服从大数定律。\n独立同分布大数定律设$  X_{k}, k=1,2 \\ldots  $是相互独立且同分布的随机变量序列，且\n$  E\\left(X_{k}\\right)=\\mu, D\\left(X_{k}\\right)=\\sigma^{2}, k=   1,2, \\ldots  $\n则$  \\left\\{X_{k}\\right\\}, k=1,2 \\ldots  $服从大数定律，即对任意的$  \\varepsilon&gt;0 $，有\n$\\lim _{n \\rightarrow \\infty} P\\left\\{\\left|\\frac{1}{n} \\sum_{k=1}^{n} X_{k}-\\mu\\right|&lt;\\varepsilon\\right\\}=1$\n贝努里大数定律设$  \\frac{m}{n} $是$  n  $次重复独立试验中事件  A  发生的频率，$  p $是事件$  A  $在每次试验中发生的概率，则对任意的$  \\forall \\varepsilon&gt;0 $，有\n$\\lim _{n \\rightarrow \\infty} P\\left\\{\\left|\\frac{m}{n}-p\\right|&lt;\\varepsilon\\right\\}=1$\n小概率事件定理：概率很小的事件，在一次试验中几乎是不可能发生的，从而在实际中可看成不可能事件。\n辛钦大数定律设$  X_{k}, k=1,2 \\ldots  $是相互独立同分布的随机变量序列，若$  X_{k}  $的数学期望存在，则$  \\left\\{X_{k}\\right\\}  $服从大数定律。\n中心极限定理设随机变量$  X, X_{1}, X_{2}, \\ldots  $的分布函数分别为$  F(x), F_{1}(x), F_{2}(x), \\ldots$ ，若极限式\n$\\lim _{n \\rightarrow \\infty} F_{n}(x)=F(x)$\n在$  F(x)  $的每一个连续点上都成立，称随机变量序列$  \\left\\{X_{k}\\right\\}, k=1,2, \\ldots  $依分布收敛于$  X $。\n记为$X_n\\xrightarrow{L} X$\n中心极限定理中心极限定理设随机变量序列$  \\left\\{X_{k}\\right\\} ， k=1,2, \\ldots  $相互独立，有有限数学期望和方差.若随机变量序列\n$Y_{n}=\\frac{\\sum_{k=1}^{n} X_{k}-\\sum_{k=1}^{n} E\\left(X_{k}\\right)}{\\sqrt{\\sum_{k=1}^{n} D\\left(X_{k}\\right)}},\\text{标准化}$\n对$  y \\in R  $一致地有\n$\\lim _{n \\rightarrow \\infty} P\\left\\{Y_{n}&lt;y\\right\\}=\\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{y} e^{-\\frac{1}{2} t^{2}} d t=\\Phi(y)$\n称随机变量序列$  \\left\\{X_{k}\\right\\}  $服从中心极限定理。\n\n\n\n\n\n\n\n\n\n随机变量序列$  \\left\\{X_{k}\\right\\}  $服从中心极限定理，指其前$  n  $项和$ \\sum_{k=1}^{n} X_{k}  $的标准化随机变量依分布收敛于标准正态分布随机变量$  X $。\n（概率的近似计算公式）若随机变量序列$  \\left\\{X_{k}\\right\\}, k=1,2, \\ldots  $服从中心极限定理，有\n$\\frac{\\sum_{k=1}^{n} X_{k}-\\sum_{k=1}^{n} E\\left(X_{k}\\right)}{\\sqrt{\\sum_{k=1}^{n} D\\left(X_{k}\\right)}} \\xrightarrow{L} X \\sim N(0,1),as~~n\\rightarrow \\infty$\n故当$  n  $足够大时，可以认为\n$\\frac{\\sum_{k=1}^{n} X_{k}-\\sum_{k=1}^{n} E\\left(X_{k}\\right)}{\\sqrt{\\sum_{k=1}^{n} D\\left(X_{k}\\right)}} \\sim N(0,1)$\n近似成立，或\n$\\sum_{k=1}^{n} X_{k} \\sim N\\left(\\sum_{k=1}^{n} E\\left(X_{k}\\right), \\sum_{k=1}^{n} D\\left(X_{k}\\right)\\right)$\n近似成立。\n林格伯格-列维定理、独立同分布极限定理设$  \\left\\{X_{k}\\right\\}, k=1,2 \\ldots  $为相互独立，具有相同分布的随机变量序列，且$  E\\left(X_{k}\\right)=\\mu, D\\left(X_{k}\\right)=\\sigma^{2} $，则$  \\left\\{X_{k}\\right\\}  $满足中心极限定理，即有\n$\\lim _{n \\rightarrow \\infty} P\\left\\{\\frac{\\sum_{k=1}^{n} X_{k}-n \\mu}{\\sqrt{n} \\sigma} \\leq x\\right\\}=\\Phi(x)$\n🎇第六章 数理统计的基本概念总体、样本与统计量\n总体：研究对象的单位元素所组成的集合\n个体：组成总体的每个单位元素\n样本：按照一定的规则从总体中抽取的一部分个体。\n抽样：抽取样本的过程\n样本容量：样本中个体的数目n\n\n将第$  i  $个个体的对应指标记为$  X_{i}, i=1,2 ,  \\ldots, n$，构成的随机向量$  \\left(X_{1}, X_{2}, \\cdots, X_{n}\\right)  $称为样本。\n样本是一组随机变量，其具体试验（观察）数值记为:  $x_{1}, x_{2}, \\cdots, x_{n} $，称为样本观测值，简称样本值。\n为使样本具有代表性，抽样应满足：\n\n$X_{i}  $与总体同分布\n$X_{1}, X_{2}, \\cdots, X_{n}  $相互独立\n\n设$  X_{1}, X_{2}, \\cdots, X_{n}  $是来自总体$  X $的样本，如果相互独立且每个分量与总体同分布，称其为简单随机样本，简称样本。\n若总体$  X  $的分布函数为$  F(x) $，则样本$  X_{1} ,  X_{2}, \\cdots, X_{n}  $的联合分布函数为\n$\\begin{aligned}F\\left(x_{1}, x_{2}, \\cdots, x_{n}\\right) &amp; =P\\left\\{X_{1} \\leq x_{1}, X_{2} \\leq x_{2}, \\cdots, X_{n} \\leq x_{n}\\right\\} \\\\&amp; =\\prod_{k=1}^{n} F_{X_{k}}\\left(x_{k}\\right)\\end{aligned}$\n统计量设$  X_{1}, X_{2}, \\cdots, X_{n}  $是总体$ X  $的样本，$  T  $为$  n  $元实值函数，若样本的函数\n$T=T\\left(X_{1}, X_{2}, \\cdots, X_{n}\\right)$\n是随机变量且不含未知参数，称$  T  $为统计量。\n对相应的样本值$  \\left(x_{1}, x_{2}, \\ldots, x_{n}\\right) $，称$ t=T\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right) $\n为统计量的统计值。\n常见统计量\n\n样本均值：$\\bar{X}=\\frac{1}{n} \\sum_{i=1}^{n} X_{i}$\n样本方差：$S^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\bar{X}\\right)^{2}$\n样本$k$阶原点矩：$A_{k}=\\frac{1}{n} \\sum_{i=1}^{n} X_{i}^{k}$\n样本$k$阶中心矩：$M_{k}=\\frac{1}{n} \\sum_{i=1}^{n}\\left(X_{i}-\\bar{X}\\right)^{k}$\n\n统称为样本矩。\n$\\begin{array}{l}A_{1}=\\bar{X} \\\\M_{2}=\\frac{n-1}{n} S^{2}=\\frac{1}{n} \\sum_{i=1}^{n} X_{i}^{2}-\\bar{X}^{2}=A_{2}-A_{1}^{2} \\\\X, S^{2}, A_{k}, M_{k} \\longmapsto x, \\mathrm{~s}^{2}, a_{k}, m_{k}\\end{array}$\n样本矩与总体矩的区别：\n\n样本矩是随机变量\n总体矩是数值\n\n常用统计分布正态分布$f(x)=\\frac{1}{\\sqrt{2 \\pi}} e^{\\frac{-x^{2}}{2}}, x \\in R$\n上侧分位数$  u_{\\alpha}(0&lt;\\alpha&lt;1)  $满足\n$P\\left\\{X&gt;u_{\\alpha}\\right\\}=\\int_{u_{\\alpha}}^{+\\infty} f(x) d x=\\alpha$\n\n对正态分布有$\\phi(u_\\alpha)=1-\\alpha$\n$\\chi ^2$分布$f_{\\chi^{2}}(x)=\\left\\{\\begin{array}{ll}\\frac{1}{2 \\Gamma\\left(\\frac{n}{2}\\right)}\\left(\\frac{x}{2}\\right)^{\\frac{n}{2}-1} e^{-\\frac{x}{2}}, x&gt;0 \\\\0 , x \\leq 0\\end{array}\\right.$\n其中$  \\Gamma(\\alpha)  $为 Gama函数，称随机变量$  X  $服从自由度为$  n  $的$  \\chi^{2}  $分布，记为$  \\chi^{2} \\sim \\chi^{2}(n) $\nGama函数为\n$\\Gamma(\\alpha)=\\int_{0}^{+\\infty} x^{\\alpha-1} e^{-x} d x, \\quad(\\alpha&gt;0)$\n主要性质:\n$\\Gamma(1)=1, \\quad \\Gamma\\left(\\frac{1}{2}\\right)=\\sqrt{\\pi}, \\quad \\Gamma(\\alpha)=(\\alpha-1) \\Gamma(\\alpha-1)$\n设$  X_{1}, X_{2}, \\ldots, X_{n}  $相互独立且都服从标准正态分布，则标准正态随机变量的独立平方和\n$\\chi^{2}=\\sum_{i=1}^{n} X_{i}^{2} \\sim \\chi^{2}(n)$\n即随机变量$  \\chi^{2}  $服从自由度为$  n  $的卡方分布。\n$ \\chi^{2}(n)  $的上侧分位数$  (0&lt;\\alpha&lt;1)  $：\n$P\\left\\{\\chi^{2}&gt;\\chi_{\\alpha}^{2}(n)\\right\\}=\\int_{\\chi_{\\alpha}^{2}(n)}^{+\\infty} f_{\\chi^{2}}(x) d x=\\alpha$\n\n性质\n数字特征\n设$  \\chi^{2} \\sim \\chi^{2}(n)$ , 则有\n$E\\left(\\chi^{2}\\right)=n, \\quad D\\left(\\chi^{2}\\right)=2 n$\n\n$(n-1)S^2/\\sigma^2\\sim \\chi^2(n-1)$\n\n可加性\n设$  Y_{1}, Y_{2}  $相互独立，且$  Y_{1} \\sim   \\chi^{2}\\left(n_{1}\\right), Y_{2} \\sim \\chi^{2}\\left(n_{2}\\right) $，则$  Y_{1}+Y_{2} \\sim \\chi^{2}\\left(n_{1}+n_{2}\\right) .$\n\n大样本分位数$\\chi^2_\\alpha(n)$\n当$  n  $足够大（如$  n&gt;45 $）时，有\n$\\chi_{\\alpha}^{2}(n) \\approx n+u_{\\alpha} \\sqrt{2 n}$\n\n\n  其中$  u_{\\alpha}  $满足$  \\Phi\\left(u_{\\alpha}\\right)=1-\\alpha $。\n自由度为$n$的$t$分布$T\\sim t(n)$$f_{T}(x)=\\frac{\\Gamma\\left(\\frac{n+1}{2}\\right)}{\\sqrt{n \\pi} \\Gamma\\left(\\frac{n}{2}\\right)}\\left(1+\\frac{x^{2}}{n}\\right)^{-\\frac{n+1}{2}}, \\quad x \\in R$\n$ t(n) $的上侧分位数$  t_{\\alpha}(n)(0&lt;\\alpha&lt;1)  $：\n$P\\left\\{T&gt;t_{\\alpha}(n)\\right\\}=\\int_{t_{\\alpha}(n)}^{+\\infty} f_{T}(x) d x=\\alpha$\n\n设随机变量$  X, Y  $相互独立，$X \\sim   N(0,1), Y \\sim \\chi^{2}(n)$ ，则\n==$T=\\frac{X}{\\sqrt{Y / n}} \\sim t(n)$==\n即随机变量$  T  $服从自由度为$  n  $的$  t  $分布。\n特点\n关于纵轴（y轴）对称：$t_{1-\\alpha}(n)=-t_{\\alpha}(n)$\n$n  $较大时，$\\lim _{n \\rightarrow \\infty} f_{T}(x)=\\varphi(x) $\n\n​    $t_{\\alpha}(n) \\approx u_{\\alpha} \\quad(n&gt;30)$\nF分布$F\\sim F(n_1,n_2)$$f_{F}(x)=\\left\\{\\begin{array}{cc}n_{1} \\frac{n_{1}}{2} n_{2} \\frac{n_{2}}{2} \\frac{\\Gamma\\left(\\frac{n_{1}+n_{2}}{2}\\right)}{\\Gamma\\left(\\frac{n_{1}}{2}\\right) \\Gamma\\left(\\frac{n_{2}}{2}\\right)} x^{\\frac{n_{1}}{2}-1}\\left(n_{1} x+n_{2}\\right)^{-\\frac{n_{1}+n_{2}}{2}}, x&gt;0 \\\\0, &amp; x \\leq 0\\end{array}\\right.$\n称$  X  $服从第一自由度为$  n_{1} $，第二自由度为$  n_{2} $的$  F  $分布。\n设随机变量$  X, Y  $相互独立,\n$\\begin{aligned}X \\sim \\chi^{2}\\left(n_{1}\\right), &amp; Y \\sim \\chi^{2}\\left(n_{2}\\right), \\quad \\text { 则 } \\\\&amp; F=\\frac{X / n_{1}}{Y / n_{2}} \\sim F\\left(n_{1}, n_{2}\\right)\\end{aligned}$\n即随机变量$  F  $服从第一自由度为$  n_{1} $，第二自由度为$  n_{2}  $的$  F  $分布。\n上侧分位数$  F_{\\alpha}\\left(n_{1}, n_{2}\\right) \\quad(0&lt;\\alpha&lt;1)  $：\n$P\\left\\{F&gt;F_{\\alpha}\\left(n_{1}, n_{2}\\right)\\right\\}=\\int_{F_{\\alpha}\\left(n_{1}, n_{2}\\right)}^{+\\infty} f_{F}(x) d x=\\alpha$\n推论\n若$ \\quad F \\sim F\\left(n_{1}, n_{2}\\right) \\Rightarrow \\frac{1}{F} \\sim F\\left(n_{2}, n_{1}\\right)$\n若$\\quad F \\sim F\\left(n_{1}, n_{2}\\right) \\Rightarrow F_{1-\\alpha}\\left(n_{1}, n_{2}\\right)=\\frac{1}{F_{\\alpha}\\left(n_{2}, n_{1}\\right)}$\n\n抽样分布定理设$  X_{1}, X_{2}, \\ldots, X_{n}  $是正态总体$  X \\sim N\\left(\\mu, \\sigma^{2}\\right) $的样本，$\\bar{X}, S^{2}  $分别是样本均值和样本方差,则\n\n$\\bar{X} $与$  S^{2}  $相互独立\n$  \\frac{\\bar{X}-\\mu}{\\sigma / \\sqrt{n}} \\sim N(0,1) $\n$\\frac{n-1}{\\sigma^{2}} S^{2} \\sim \\chi^{2}(n-1) $\n$ \\frac{\\bar{X}-\\mu}{S / \\sqrt{n}} \\sim t(n-1) $\n\n设正态总体$  X  $与$  Y  $相互独立，$X \\sim N\\left(\\mu_{1}, \\sigma_{1}^{2}\\right) $，样本为$  X_{1}, X_{2}, \\ldots X_{n_{1}} $，样本均值和样本方差为$  \\bar{X}, S_{1}^{2}$\n$Y \\sim N\\left(\\mu_{2}, \\sigma_{2}^{2}\\right) $样本为$Y_{1}, \\quad Y_{2}, \\ldots Y_{n_{2}} $，样本均值和样本方差为$  \\bar{Y}, S_{2}^{2} $，有\n\n$F=\\frac{S_{1}^{2} / \\sigma_{1}^{2}}{S_{2}^{2} / \\sigma_{2}^{2}} \\sim F\\left(n_{1}-1, n_{2}-1\\right)$ \n\n当$  \\sigma_{1}^{2}=\\sigma_{2}^{2}  $时，\n$T=\\frac{(\\bar{X}-\\bar{Y})-\\left(\\mu_{1}-\\mu_{2}\\right)}{S_{w} \\sqrt{\\frac{1}{n_{1}}+\\frac{1}{n_{2}}}} \\sim t\\left(n_{1}+n_{2}-2\\right)$\n其中，$ S_{w}=\\sqrt{\\frac{\\left(n_{1}-1\\right) S_{1}^{2}+\\left(n_{2}-1\\right) S_{2}^{2}}{n_{1}+n_{2}-2}} $\n$  \\bar{X}-\\bar{Y}  $服从正态分布，$  S_{w}{ }^{2}  $可化为$  \\chi^{2} $分布，二者组合而成的统计量应服从$  t  $分布。\n\n\n","slug":"概率论公式整理-2","date":"2023-12-22T04:28:29.000Z","categories_index":"","tags_index":"概率论与数理统计","author_index":"C4IN"},{"id":"7c65919e4df8c3abe772a3ca56ddb1a4","title":"计组复习-4","content":"输入/输出系统一、基本概念及应用（注明：应用是指基本概念的应用）\n\n系统总线上一般包含哪三组信息？\n中断方式定义、实质、特点？\n\n中断向量、中断向量表、向量地址？\n\n何谓向量中断？何谓非向量中断？各有何优点和缺点？\n单级中断、多重中断？ \n中断控制器8259A的工作原理？\n转子与中断调用的相似、区别？\nDMA方式定义、实质、特点？\n程序直传方式，中断方式，DMA方式之间的区别？\n\n二、计算题：\n1.在8259A中，如何通过IRR、IMR、ISR的值，判断中断接口是否向CPU发INT信号。\n2.如何根据中断类型码（或中断号）生成向量地址。\n总线一组能为多个部件分时共享的信息传送线路。\n特点：分时、共享\n实体：一组传送线与相应控制逻辑\n\nCPU内设置控制逻辑\n设置总线控制器\n\n分类按功能划分\nCPU内总线：ALU总线\nCPU芯片内寄存器与算逻部件之间互连的总线\n单组数据线(单向、双向)或多组数据线，或多种总线。\n\n部件内总线：局部总线、片级总线\n插件板内各芯片之间互连的总线\n分为地址、数据、控制线\n\n系统总线：板级总线\n计算机系统内各功能部件之间，或各插件板之间互连的总线。 \n分为地址、数据、控制线，包含对应的三组信息。\n\n外总线：通信总线\n计算机系统之间，或计算机系统与其他系统之间互连的总线。\n分为数据线（与地址复用）、控制线。\n\n\n按时序控制方式划分\n同步总线\n由统一时序控制总线（时钟周期、同步脉冲）传送操作。在固定时钟周期内完成数据传送，由同步脉冲定时打入。\n\n异步总线\n无固定时钟周期划分，总线周期时间由传送实际需要决定；以异步应答方式控制总线传送操作。\n\n扩展同步总线\n以时钟周期为时序基础，允许总线周期中的时钟数可变。\n\n\n几个周期：\n\n时钟周期：CPU一步操作（一次内部数据通路传送）时间\n总线周期：经过总线的一次数据传送（访存）时间，通常包含若干时钟周期\n工作周期：指令周期中的一个操作阶段，可包含多个总线周期\n\n按数据传送格式划分\n并行总线：同时传送各位信息\n串行总线：分时逐位传送各位信息\n\nCPU内总线：同步、并行\n外总线：异步、并行、串行\n系统总线：同步、异步、扩展同步、并行\n接口看我另一篇博客内容（暂时还没传上去）\n中断CPU暂时中止现行程序的执行，转去执行为某个随机事态服务的中断处理程序。处理完毕后自动恢复原程序的执行。\n\n\n\n\n\n\n\n\n\n中断与转子两者的本质区别主要表现在：\n\n转子子程序的执行是由程序员事先安排好的，而中断服务程序的执行则是由随机的中断事件引起的调用。\n\n转子子程序的执行受到主程序或上层子程序的控制，而中断服务程序一般与被中断的现行程序没有关系。\n\n不存在同时调用多个转子子程序的情况，而可能发生多个外设同时请求CPU为自己服务的情况。\n\n\n实质程序切换的方法：\n\n保存断点，保护现场（中断处理前）\n恢复现场，返回断点（中断处理后）\n\n程序切换的时间：\n\n一条指令结束时切换\n保证程序的完整性\n\n特点随机性：\n\n随机发生的事态（按键，故障等）\n有意调用，随机请求与处理的事态（调用打印机）\n随机插入的事态（软中断指令插入程序任何位置）\n注意中断与转子的区别\n\n\n\n直接程序传送方式（程序查询）依靠CPU直接执行相关的IO程序来实现数据的输入和输出的控制\n优缺点：硬件开销小、并行程度低，实时性差\n优先权逻辑与屏蔽技术判优\nCPU（现行程序）与中断请求间的判优\n在一般计算机中，CPU进行简单的判优处理，根据CPU标志寄存器中的“允许中断”控制位（IF）状态，确定是否响应该中断请求。\n\nIF=1，开中断\n\nIF=0，关中断\n\n\n\n在性能更强的计算机中，除了设置IF中断控制位外，还在程序状态字PSW中设定现行程序优先级，以便进一步细分现行程序任务的重要程度。\n\n中断判优\n\n优先顺序：故障 &gt; DMA &gt; 外中断（输入输出）\n\nCPU现行程序与外设请求的判优\n\nCPU设置允许中断标志（=1开中断，=0关中断，模型机采用）\n\nCPU设置程序状态字（PSW）的优先级字段\n为现行程序赋予优先级\n\n$&lt;$外设请求优先级，响应\n$\\geq$外设请求优先级，不响应\n\n\n\n\n\n\n\n\n各外设请求的判优\n\n软件判优\n由程序查询顺序确定优先级，可灵活修改优先级。\n\n硬件判优\n如中断控制器判优。\n中断控制器(如8259)集中解决请求信号的接收、屏蔽、判优、编码等问题。\n\n\n\n\n8259中断控制器IRR 中断请求寄存器（Interrupt Request Register）：8位，可存放8个中断请求信号，作为向CPU申请与判优、编码的依据。\nPR 优先级裁决器（Priority Resolver）：即中断源的优先级排队逻辑，选择优先级最高的中断申请者。\nISR 中断服务寄存器（Interrupt Service Register）：8位，用来存放或记录正在服务中的所有中断请求优先级（如在多重嵌套时），每一位对应一个中断优先级。\nIMR 中断屏蔽寄存器（Interrupt Mask Register）：8位，其内容可由CPU预置。这就是前面提到的集中屏蔽方式，各接口可以提出自己的中断请求信号，在8259A中再与屏蔽字比较。对应位（IMRi）若为1，则该请求（IRRi）被屏蔽，不会被送往CPU。\n\n服务程序入口地址的获取方式向量中断将各个中断服务程序的入口地址（或包括状态字）组织成中断向量表；响应中断时，由硬件直接产生对应于中断源的向量地址；据此访问中断向量表，从中读取服务程序入口地址，由此转向服务程序的执行，这些工作在中断周期IT中由硬件直接实现。\n\n中断向量\n采用向量化的中断响应方式，将中断服务程序的入口地址及其程序状态字存放在特定的存储区中，所有的中断服务程序入口地址和状态字一起，称为中断向量。\n\n中断向量表\n即用来存放中断向量的一种表。在实际的系统中，常将所有中断服务程序的入口地址（或包括服务程序状态字）组织成一个一维表格，并存放于一段连续的存储区，此表就是中断向量表。\n\n组成（IBMPC）\n在IBMPC中，中断向量表在主存中占用0—1023号地址单元（即1K），每个中断源占用4个单元，因此，该表中可存放256个中断源。\n\n\n\n从中断向量表中获取中断服务程序入口地址\n\n\n\n\n\n向量地址\n访问中断向量表的地址码，即读取中断向量所需的地址（也可称为中断指针）。\n\n\n非向量中断CPU响应中断时只产生一个固定的地址，由此读取中断查询程序的入口地址，从而转向查询程序，通/，确定被优先批准的中断源，然后分支进入相应的中断服务程序。\n响应中断的条件\n有中断请求信号发生，如IREQi或INT n。\n\n该中断请求未被屏蔽。\n\nCPU处于开中断状态，即中断允许触发器TIEN=1（或中断允许标志位IF=1）。\n\n没有更重要的事件要处理（如因故障引起的内部中断，或是其优先权高于程序中断的DMA请求等）。\n\nCPU刚刚执行的指令不是停机指令。\n\n在一条指令结束时响应（因为程序中断的过程是程序切换过程, 不能在一条指令执行的中间就切换）。\n\n\n响应过程\n中断处理单级中断CPU响应后只处理一个中断源的请求，处理完毕后才能响应新的请求。\n多级中断在某次中断服务过程中，允许响应处理更高级别的中断请求。\n允许多重中断的处理方式：\n\n流程\n恢复现场与返回原程序在编制中断服务程序时应遵循一个原则：在响应过程、保护现场、恢复现场等过渡状态中，应当关中断，使之不受打扰。\nDMA方式DMA，即直接存储器访问（Direct Memory Access），它指这样一种传送控制方式：依靠硬件直接在主存与外围设备之间进行数据传送，在传送过程中不需要CPU的干预。\n\n特点：DMA方式只能处理简单的数据传送。\n\n应用：DMA传送方式一般应用于主存与高速I/O设备之间的简单数据传送。高速I/O设备包括磁盘、磁带、光盘等外存储器，以及其他带有局部存储器的外围设备、通信设备等等。\n\nDMA传送过程:\n\n程序准备：主程序实现初始化（对DMA控制器和接口\n\n传送请求\n\nDMA传送：存储器—直传—IO（硬件实现）\n善后处理：执行中断处理程序\n\n\n\n程序直传方式&amp;中断方式&amp;DMA方式\n直接程序传送：依靠CPU直接执行相关的I/O程序来实现数据的输入和输出控制\n中断方式：设备提出中断请求，主机响应后与设备交换信息，接口中包含中断控制请求\nDMA方式：直接依靠硬件系统来控制主存和设备之间的数据传送，传送期间无需CPU干预，传送结束后通常通过中断方式通知CPU,支持高速外设与主存之间进行DMA方式交换数据\n\n","slug":"计组复习-4","date":"2023-12-22T02:14:43.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"7c7c949c89bab904b100e05ce4b585dc","title":"计组复习-3","content":"存储子系统一、基本概念及应用（注明：应用是指基本概念的应用）\n\n主存、缓存、外存？\n\n高速缓存Cache用来存放什么内容？设置它的主要目的是什么？\n\n存储介质？\n\n何谓随机存取？何谓顺序存取？何谓直接存取？请各试举一例。\n\n静态存储器SRAM、动态存储器DRAM存储原理？\n\n动态刷新分为哪几种情况，各有什么特点？\n\n刷新、重写的区别？\n\n全地址译码方式？部分地址译码方式？\n\n\n二、设计题：\n半导体存储器逻辑设计：(地址分配、片选逻辑、逻辑框图)，片选逻辑采用全/部分译码方式。\n存储器的层次结构主存储能由CPU直接编程访问的存储器，它存放当前CPU需要执行的程序与需要处理的数据。\n特点：存取速度快，容量有限\n为满足CPU编程直接访问的需要，对主存储器的基本要求有三条：\n\n随机访问\n工作速度快\n具有一定的存储容量\n\n外存储器用来存放需要联机保存但暂不使用的大量程序与数据。\n特定：存取速度较慢，容量很大\n程序与数据只有进入主存才能真正运行，而外存储器是作为后援的。 \n高速缓存（Cache）高速缓存中存放的是最近要使用的程序与数据，作为主存中当前活跃信息的副本。\n特点：存取速度很快，容量很小\n存储介质\n磁芯存储器：微型磁环\n半导体存储器：是构成高速缓存、主存的单元。\n\n    静态存储器：依靠双稳态触发器的两个稳定状态保存信息\n​    动态存储器：依靠电容上的存储电荷暂存信息\n\n磁表面存储器\n利用磁层上不同方向的磁化区域表示信息。容量大，非破坏性读出，长期保存信息，速度慢，作外存。\n是构成外存的单元之一，分为：磁卡、磁鼓、磁带、磁盘等。\n\n光盘存储器\n利用光斑的有无表示信息。容量很大，非破坏性读出，长期保存信息，速度慢，作外存。\n\n\n存取方式随机存取存储器（RAM）主存与高速缓存Cache是CPU可以直接编址访问的存储器，这就要求它们采取随机访问的存取方式。\n随机存取的含义：\n\n可按地址随机地访问任一存储单元，如可直接访问0000单元，也可直接访问FFFF单元；CPU可按字节或字存取数据，进行处理。\n访问各存储单元所需的读/写时间相同，与地址无关；可用读/写周期（存取周期）表明RAM的工作速度。\n\n速度指标：存取周期或读/写周期\n应用：作主存、高速缓存\n只读存储器（ROM）只读存储器在正常工作中只能读出，不能写入。主存中常采用部分ROM固化系统软件中的核心部分、已调试好不再改变的应用软件、汉字字库一类信息。\nCPU中也常采用ROM，存放用来解释执行机器指令的微程序。\n\n顺序存取存储器（SAM，sequential access memory）顺序存取存储器的信息是按记录块组织、顺序存放的，访问时间与信息存放位置有关。\n磁带是采取顺序存取方式的存储器。\n直接存取存储器（DM，direct access memory）访问时读/写部件先直接指向一个小区域，再在该区域内顺序查找。访问时间与数据位置有关。\n半导体存储器静态MOS存储单元与芯片SRAM（静态存储器）依靠双稳态电路内部交叉反馈的机制存储信息。功耗较大，速度快，作Cache。\n动态MOS存储单元与存储芯片DRAM（动态存储器）依靠电容存储电荷的原理存储信息。功耗较小，容量大，速度较快，作主存。\n主存储器的逻辑设计\n需先明确所要求的总容量这一技术指标，即字数×位数。字数指可编址单元数，常简称单元数；位数指每个编址单元的位数。模型机中，采用主存按字节编址，那么每个编址单元有8位（一个字节）\n\n需要确定可供选用的存储芯片，即什么类型、型号的存储芯片， 每片的容量是多少。每片容量通常低于总容量，就需要用若干块芯片组成。相应地，可能存在位数与字数的扩展问题。\n\n\n半导体存储器逻辑设计看我这篇博客：\n半导体的组织\n地址译码方法全地址移码方式就是构成存储器时要使用全部地址总线信号，即所有的高位地址信号都用来作为译码器的输入，低位地址信号接存储芯片的地址输入线，从而使存储器芯片上的每一个单元在整个内存空间中具有唯一的地址。\n部分地址译码就是仅把地址总线的一部分地址信号线与存储器连接，通常是用高位地址信号的一部分（而不是全部）作为片选译码信号；低位地址信号接存储芯片的地址输入线。\n动态存储器的刷新定期向电容补充电荷。\n刷新：非破坏性读出的动态M，需补充电荷以保持原来的信息。\n重写：破坏性读出后重写，以恢复原来的信息。\n最大刷新间隔：2ms，必须对所有动态单元刷新一遍\n刷新方法按行读。\n刷新周期（存取周期）：刷新一行所用的时间\n刷新一块芯片所需的刷新周期数由芯片矩阵的行数决定。\n\n安排方式\n集中刷新\n2ms内集中安排所有刷新周期。用在实时要求不高的场合。\n\n分散刷新\n各刷新周期分散安排在存取周期中。用在低速系统中。\n\n异步刷新\n各刷新周期分散安排在2ms内。每隔一段时间刷新一行。用在大多数计算机中。\n\n\n\n","slug":"计组复习-3","date":"2023-12-22T01:19:55.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"57a7ae1f378922eb989d4675588d82b0","title":"计组复习-0","content":"概论\n冯.诺依曼体制？存储程序方式？\n控制流？数据流？\n模拟信号？数字信号？数字信号有哪两种？\n总线及其组成？\n接口的概念？\n基本字长？\nCPU主频？时钟频率？\n数据通路宽度？数据传输率？\n\n冯诺依曼体制\n采用二进制形式表示数据和指令\n采用存储程序方式工作（核心)\n由五大部分组成计算机系统的硬件，并规定了这五部分的基本功能\n运算器\n控制器\n存储器\n输入设备\n输出设备（包括总线、接口）\n\n\n\n存储程序方式计算机采取：\n\n事先编制程序\n存储程序\n自动连续运行程序\n\n的工作方式。\n控制流&amp;数据流控制流：控制计算机工作的信息，即指令、命令\n数据流：计算机加工处理的对象，即数值型数据、非数值型数据\n两条基本线索是：\n\n信息的表示\n信息的传送及传送中的控制\n\n模拟信号&amp;数字信号在计算机中，信息是通过电信号表示的。\n模拟信号：是一种随时间连续变化的电信号\n数字信号：是一种在时间或空间上断续变化的电信号，有两种：\n\n电平（位）：并行传送\n脉冲：串行传送\n\n总线及其组成总线：能为多个部件分时共享的一组信息传送线路及相应的控制逻辑。\n\n\n以CPU为中心的双总线结构\n\n\n单总线结构\n\n\n以M为中心的双总线结构\n\n\n多级总线结构\n\n\n\n模型机系统结构\n\n内总线： 16位单向数据传送线，实现ALU和寄存器间的数据交换，寄存器间数据传送必须通过ALU，不能直接传送\n系统总线：单总线结构。CPU，主存，I/O设备都直接挂接系统总线，包括地址总线，数据总线，控制总线。同步控制。\nCPU通过MAR（地址寄存器）向地址总线提供数据，选择外部设备，外部设备也可以向地址总线发送地址码。\nCPU通过MDR向数据总线发送或接收数据，通过R/W控制命令决定传送方向及MDR与数据总线的通断。\n\n\n控制总线：CPU和外部设备向控制总线发出或接收控制信号，主存通常只接收控制信号并提供回答信号。\n\n接口部件与部件（指硬件或软件）之间的交接部分称为接口；主机系统总线与I/O设备之间的交接部分称为I/O接口。\n类型按传送格式： 串行接口、并行接口 \n按时序控制： 同步接口、异步接口\n按信息传送控制方式：中断接口、DMA接口\n基本字长一般是指参加一次定点运算的操作数的位数，如：8、16、32、64位，它影响计算精度、指令功能。\nCPU主频&amp;时钟频率\nCPU主频\n\n​    是计算机的振荡器输出的脉冲序列的频率，是计算机中一切操作所依据的时间基准信号，其高低决定了计算    机工作速度的快慢。\n\n时钟频率\n\n​    是主频脉冲经分频后所形成的时钟脉冲序列的频率，两个相邻时钟脉冲之间的间隔时间是一个时钟周期时间，也称为节拍。\n数据通路宽度&amp;数据传输率\n数据通路宽度\n\n​    指数据总线一次能并行传送的数据位数。\n\n数据传输率\n\n​    指数据总线每秒传送的数据量，也称为数据总线的带宽。\n​    公式：$\\text { 总线带宽 }=\\frac{\\text { 总线数据通路宽度 } \\times \\text { 总线时钟频率 }}{8}(\\mathrm{BPS})$\n","slug":"计组复习-0","date":"2023-12-15T08:09:15.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"d791938eaa4548a75cb2973241af39d9","title":"计组复习-2","content":"第三章 中央处理器一、基本概念及应用（注明：应用是指基本概念的应用）\n1.CPU内部各寄存器的功能？\n2.数据通路结构？\n3.何谓同步控制方式，何谓异步控制？有何主要特征？应用场合？\n4.何谓主从设备，试举例说明。\n5.同步控制中如何引入异步应答的，试举例说明.\n6.微程序控制思想的基本要点是什么？\n7.判断下面叙述是否正确，说明理由：串行加法器中的进位链是串行进位链，并行加法器中的进位链只有并行进位链。\n8.常用的加法器进位链结构有哪几种？\n9.组合逻辑控制器、微程序控制器有何区别？\n10.组合逻辑控制器、微程序控制器的时序系统是如何划分的？\n11.微命令、微操作、微指令、微指令周期、微程序？\n12.1位全加器的结构及关系表达式。\n13.时序信号？时序系统？\n二、计算题：\n1.并行加法器中的串行进位链结构：Cn = Gn + PnCn-1\n并行进位链结构：Cn = Gn + PnGn-1+ … + Pn…P1C0\n2.原码一位乘法（要求运算过程）；\n三、设计题：\nCPU的逻辑组成及工作机制\n1.CPU的逻辑组成（模型机框图）\n（1）CPU的逻辑组成→模型机框图；\n（2）CPU内每个寄存器的作用；\n（3）总线的分类及定义；\n（4）控制器的分类及区别；\n2.CPU的指令流程\n（1）指令类型：MOV指令、双操作数算数逻辑运算指令、单操作数算是逻辑运算指令、转移/返回指令、转子指令；（主要以MOV指令、双操作数算数逻辑运算指令为主）\n（2）核心是寻址方式：立即寻址、R、(R)、-(R)、(R)+、@(R)+、X(R)；\n3.操作时间表的安排（微命令的安排）：\n（1）CPU数据通路操作：按照数据的流向分成四段\nALU输入选择→AUL功能选择→移位器功能选择→分配脉冲（打入到寄存器中的脉冲）；\n（2）与访问主存有关的微命令。\n寻址方式\n\n\n\n序号\n寻址方式\n助记符\n可指定寄存器\n\n\n\n\n1\n立即寻址\nI\n无\n\n\n2\n寄存器寻址\nR\nR0~R3，SP、PC、PSW\n\n\n3\n寄存器间址\n(R)\nR0~R3，SP、PC\n\n\n4\n自减型寄存器间址\n-（R）\nR0~R3、SP\n\n\n5\n自增型寄存器间址\n（R）+\nR0~R3、SP、PC\n\n\n6\n自增型双间址\n@（R）+  @（PC）+\nR0~R3、SP、PC\n\n\n7\n变址方式\nX（R）  X（PC）\nR0~R3、SP、PC\n\n\n8\n跳步方式\nSKP\n\n\n\n\nCPU内部寄存器用于处理的寄存器通用寄存器组一组可编程访问的寄存器。\n在指令系统中为这些R分配了编号，有：R0~R3，PC，SP，PSW。\n暂存器用户不能直接访问的R，用来暂存信息，在指令系统中没有为它们分配编号，有C、D。\n暂存器C：从主存中读取源操作数或源操作数地址时，使用它。\n暂存器D：从主存中读取目的作数或目的操作数地址时，或中间运算结果时，使用它。\n用于控制的寄存器指令寄存器IR用来存放现行运行指令，它的输出是产生微操作命令序列的主要逻辑依据。\n为了提高读取指令的速度，在主存与IR间建立直接传送通路，并且将IR扩充为指令队列（或指令栈），允许预取若干条指令。\n程序计数器PCPC提供后继指令地址，并送往与主存器相连接的地址寄存器（MAR）。\n后继指令地址=PC+n，模型机中为了简化起见，令n=1\n程序状态字寄存器PSW（Program Status Word）PSW的内容就是表现的现行程序的状态。\n包括：\n\n特征位：进位C、溢出V、零Z、负N，允许中断I等； \n\n编程设定位。\n\n\n用作主存接口的寄存器CPU访问主存时，首先送出地址码，然后送出/接收数据，需：\n\n当作用在MAR上的微命令EMAR为低电平时，MAR输出呈高阻态，与地址总线断开\n当作用在MAR上的微命令EMAR为高电平时，MAR输出其内容（地址信息）送往地址总线；\n\n地址寄存器MAR读取指令/存取操作数/操作数地址时，CPU先将地址信息送入MAR，再由MAR经地址总线送往主存M，找到相应的主存单元。\n地址寄存器MBR（MDR）由控制命令R/W决定传送方向。\nR：由主存单元$~\\rightarrow~$数据总线$~\\rightarrow~$MDR\nW：由MDR$~\\rightarrow~$数据总线$~\\rightarrow~$数据单元\n==数据通路框图==\n各类信息的传送路径数据通路形成后，指令的执行基本上可以归纳为信息的传送，即控制流和数据流两大信息流。\n控制流：指令信息的传送，及由此产生的微命令序列。\n数据流：数据信息的传送。\n指令信息与数据信息的读取，依赖于地址信息。\n取指令地址PC$~\\rightarrow~$A$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MAR$~\\Rightarrow~$PC$~\\rightarrow~$MAR\n后继指令地址PC$~\\rightarrow~$A$~\\rightarrow~$ALU ( +1 ) $~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$PC$~\\Rightarrow~$PC+1$~\\rightarrow~$PC\n指令信息的传递M$~\\rightarrow~$数总$~\\rightarrow~$IR\n取操作数地址寄存器间址(R)Ri$~\\rightarrow~$A/B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MAR$~\\Rightarrow~$Ri$~\\rightarrow~$MAR\n\n自减型寄存器间址-(R)Ri$~\\rightarrow~$A/B$~\\rightarrow~$ALU ( -1 )$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MAR$~\\Rightarrow~$Ri - 1$~\\rightarrow~$MAR\n\n自增型寄存器间址(R)+Ri$~\\rightarrow~$A/B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MAR\n$~\\Rightarrow~$Ri$~\\rightarrow~$MAR，Ri + 1$~\\rightarrow~$ Ri\n\n自增型双重间址@(R)+Ri$~\\rightarrow~$A/B$~\\rightarrow~$ALU ($~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MAR\n$~\\Rightarrow~$Ri$~\\rightarrow~$MAR，Ri + 1$~\\rightarrow~$ Ri\n\nM$~\\rightarrow~$数总$~\\rightarrow~$MDR$~\\rightarrow~$B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$C$~\\rightarrow~$A/B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MAR$~\\Rightarrow~$M$~\\rightarrow~$MDR$~\\rightarrow~$C，C$~\\rightarrow~$MAR\n变址器址X(R)\n从主存中取处变址Rx：\n\nPC$~\\rightarrow~$A$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$MAR$~\\Rightarrow~$PC$~\\rightarrow~$MAR\nM$~\\rightarrow~$数总$~\\rightarrow~$MDR$~\\rightarrow~$B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$C$~\\Rightarrow~$M$~\\rightarrow~$MDR$~\\rightarrow~$C\n\n\n相加后得到所求地址后存入寄存器中，程序计数器指向下一指令：\n\n数据信息的传送寄存器$~\\rightarrow~$寄存器（CPU内的R）Ri$~\\rightarrow~$A/B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$Rj$~\\Rightarrow~$Ri$~\\rightarrow~$Rj\n\n寄存器$~\\rightarrow~$主存Ri$~\\rightarrow~$A/B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MDR$~\\rightarrow~$数总$~\\rightarrow~$M\n$~\\Rightarrow~$Ri$~\\rightarrow~$MDR，MDR$~\\rightarrow~$M\n\n主存$~\\rightarrow~$寄存器M$~\\rightarrow~$数总$~\\rightarrow~$MDR$~\\rightarrow~$B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$Ri\n$~\\Rightarrow~$M$~\\rightarrow~$MDR$~\\rightarrow~$Ri\n\n主存$~\\rightarrow~$主存M$~\\rightarrow~$数总$~\\rightarrow~$MDR$~\\rightarrow~$B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$C$~\\rightarrow~$A/B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MDR$~\\rightarrow~$数总$~\\rightarrow~$M\n$~\\Rightarrow~$M1$~\\rightarrow~$MDR$~\\rightarrow~$C，C$~\\rightarrow~$MDR，MDR$~\\rightarrow~$M2\n\nCPU内寄存器$~\\rightarrow~$外围设备（统一编址）Ri$~\\rightarrow~$A/B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$MDR$~\\rightarrow~$数总$~\\rightarrow~$Rj\n\n外围设备$~\\rightarrow~$CPU内寄存器（统一编址）Rj$~\\rightarrow~$数总$~\\rightarrow~$MDR$~\\rightarrow~$B$~\\rightarrow~$ALU$~\\rightarrow~$移位器$~\\rightarrow~$CPU内总线$~\\rightarrow~$Ri\n微命令设置数据通路操作\nALU输入选择\nRi→A，Ri的取值：R0—R3，C, D, PC, SP\nRi→B，Ri的取值：R0—R3，C, D, MDR, PSW\n\nALU功能选择\nS0—S3，C0，M\n\n移位器功能选择\n\n00：直传DM\n01：左移SL\n10：右移SR\n11：高低字节交换EX\n\n\n分配脉冲（打入到寄存器中的脉冲）\nCPR0-CPR3, CPC,CPD,CPMDR,CPMAR,CPPSW, CPPC,CPSP\n\n\n访存操作相关的控制符号（系统总线及主存有关的微命令）EMAR（输出到AB）、EMDR（输出到DB）、SMDR（DB到MDR）、 R（M到CPU）、W（CPU到M）、SIR（M到IR）\n (1)读入CPU：EMAR、R、SMDR（除指令以外），或SIR（指令）\n (2)写入M：EMAR、EMDR、W\n时序控制方式与时序系统时序控制方式\n同步控制方式\n如果各项操作与统一的时序信号同步称为同步控制。\n\n特征：\n\n时间分配（基本特征）：\n同步控制方式的基本特征是将操作时间划分为许多时钟周期，周期长度固定，每个时钟周期完成一步操作。\n\n同步定时：\n在许多操作中需要严格地同步定时，如同步打入脉冲。\n\n各部件协调：\n在CPU内，一般采用由CPU提供的统一时序信号来控制部件间信息的传送的。\n\n\n\n特点：\n时序关系比较简单，在时间安排利用上可能是不经济的。\n\n应用：\nCPU在工作时，各部件都要严格受控于统一信号，所有部件的动作都要时钟信号触发，用于CPU内部、设备内部、系统总线操作。\n\n\n\n异步控制方式\n异步控制是指各项操作按其需要选择不同的时间，不受统一的时钟周期的约束；各操作之间的衔接与各部件之间的信息交换采取应答方式。\n\n特征：\n\n时间分配（基本特征）：\n没有统一的节拍划分与同步定时脉冲，但存在着申请、响应、询问、回答一类的应答关系。\n\n\n\n应用：\n用于异步总线操作（各挂接部件速度差异大、传送时间不确定、传送距离较远等）。\n\n\n\n应用\n在CPU或设备的内部普遍采用同步控制方式；对连接CPU、主存、外设的系统总线，有的采用同步，有的采用异步控制，但多采用异步控制。在实际应用中，同步控制甚至引入异步应答关系。\n\n同步控制中引入异步应答\n以固定时钟周期作为时序基础, 引入应答思想。\n\n\n\n主从设备的概念申请使用总线，并获得批准后掌管总线控制权的设备，称为主设备，否则为从设备。\n特点：时间紧凑，能按不同部件，设备的实际需要分配时间，实现异步应答所需的控制比较复杂。\n加法单元\n$\\begin{array}{l}\\Sigma_{i}=\\left(A_{i} \\oplus B_{i}\\right) \\oplus C_{i-1} \\\\C_{i}=A_{i} B_{i}+\\left(A_{i} \\oplus B_{i}\\right) C_{i-1}\\end{array}$\n如果三个输入中1的个数为奇数，则本位和为1，否则为0。\n当本位的两个输入$A_i$、$B_i$均为1时，不管低位有无进位$C_{i-1}$传来，都必然产生进位$C_i$；若$C_{i-1}$为1，只要$A_i$、$B_i$中有一个为1，也必然产生进位。\n串行加法器如果每步只求一位和，将n位加分成n步实现，这样的加法器称为串行加法器。\n特点：结构简单，速度极慢\n并行加法器如果用n位全加器一步实现n位相加，即n位同步相加，这样的加法器称为并行加法器。\n进位信号的基本逻辑$C_{i}=A_{i} B_{i}+\\left(A_{i} \\oplus B_{i}\\right) C_{i-1}$令\n$G_{i}=A_{i} B_{i}$进位产生函数（ 本地进位 ）\n$P_{i}=A_{i} \\oplus B_{i}$进位传递函数（传递进位）\n串行进位链各级进位信号直接依赖于低一级的进位信号。\n关系式：\n$\\begin{array}{l}\\mathrm{C}_{1}=\\mathrm{G}_{1}+\\mathrm{P}_{1} \\mathrm{C}_{0} \\\\\\mathrm{C}_{2}=\\mathrm{G}_{2}+\\mathrm{P}_{2} \\mathrm{C}_{1} \\\\\\cdots \\cdots \\\\\\mathrm{C}_{\\mathrm{n}}=\\mathrm{G}_{\\mathrm{n}}+\\mathrm{P}_{\\mathrm{n}} \\mathrm{C}_{\\mathrm{n}-1}\\end{array}$\n\n结构简单，运算较慢\n并行进位链各级进位信号是并行（同时）形成的。\n关系式：\n$\\begin{array}{l}C_{1}=G_{1}+P_{1} C_{0} \\\\C_{2}=G_{2}+P_{2} G_{1}+P_{2} P_{1} C_{0} \\\\\\cdots \\cdots \\\\C_{n}=G_{n}+P_{n} G_{n-1}+\\cdots+P_{n} \\cdots P_{1} C_{0}\\end{array}$\n\n结构复杂，运算快\n定点乘法运算建议结合具体计算例子食用，不然很难看懂\n==原码一位乘法==取两个操作数的绝对值相乘，每步处理一位乘法，符号位单独处理。\n运算规则\n寄存器分配与初始值：ABC三个寄存器\n\nA存放部分积累加和，初始值为0（双符号位00表示）\nB存放被乘数X（绝对值），此时，符号位为双符号位00（在乘的过程中，B中的值一直保持不变）\nC存放乘数Y（绝对值），将符号位去掉；C寄存器的初始值是乘数Y的尾数（有效位数），以后每乘一次，将已处理的低位乘数右移舍去，同时将A寄存器的末位移入C寄存器的高位。\n\n\n符号位：A，B均设置双符号位\n\n基本操作\nC存放乘数Y（绝对值），将符号位去掉\nC寄存器的初始值是乘数Y的尾数（有效位数），以后每乘一次，将已处理的低位乘数右移舍去，同时将A寄存器的末位移入C寄存器的高位。\n\n\n\n在原码一位乘中，每步只处理一位乘数，即位于C寄存器末位的乘数，也称之为判断位Cn：\n\n若$C_n=1$，则部分积为B，执行A+B操作，然后将累加和右移一位，用“→”表示\n若$C_n=0$，则部分积为0，执行A+0操作，然后右移。或直接让A右移一位。 \n\n右移时，A的末位移入C的高位，A的第二符号位移入尾数最高位，第一符号位移入第二符号位，而第 一符号位本身则补0。\n\n操作步骤：\nN次累加与n次移位（最后一次累加后要移位）\n\n加符号位\n\n微命令设置\n$\\begin{array}{l}C_{n}=1, \\text { 即 } A+B:+A 、+B 、(A+B), \\Sigma / 2 \\rightarrow A 、 \\vec{C}, C P_{A} 、 C P_{C} \\\\C_{n}=0, \\text { 即 } A+0:+A 、(A), \\Sigma / 2 \\rightarrow A, \\vec{C}, C_{A} 、 C P_{C}\\end{array}$\n\n\n补码一位乘法操作数与结果均以补码表示，连同符号位一起，按相应算法运算。\n运算方式及关系式（比较法）$[X Y]_{\\text {补 }}=\\left[A_{n}\\right]_{\\text {补 }}+\\left(Y_{n+1}-Y_{n}\\right)[X]_{\\text {补 }}$\n注意$Y_{n+1}$为地位，$Y_n$为高位，$[A_n]_补$为部分积。\n运算规则\n寄存器分配、初始值及符号位\n寄存器ABC：\n\nA存放部分积累加和，初始值为0（双符号位00表示）\nB存放被乘数$X_补$，（双符号位00、或11表示）\nC存放乘数$Y_补$，单符号位（符号位参与运算），Y的末位添0，称为附加位$Y_{n+1}$。\n\n\n基本操作\n用C寄存器最末两位（含增加的$C_{n+1}$）作判断位，即（$Y_n,Y_{n+1}$）为判断位。\n\n若$Y_n Y_{n+1}$为00或11，执行A+0，右移，实际上可直接让A右移一位\n若$Y_n Y_{n+1}$为01，执行$A+X_补$，右移\n若$Y_n Y_{n+1}$为10，执行$A+[-X_补]$，右移\n\n在右移时，A寄存器中的第二符号位值移入尾数的最高数位（有效位的最高位），第一符号位值移入第二符号位，第一符号位本身不变，而A寄存器末位移入C寄存器。\n\n操作步数：为有效位位数的n+1\n\n微命令设置\n\n$Y_n Y_{n+1}$为00或11\n$+\\mathrm{A}, \\quad \\Sigma \\rightarrow \\mathrm{A}, \\quad \\Sigma / 2 \\rightarrow \\mathrm{A} 、 \\overrightarrow{\\boldsymbol{C}}, \\mathrm{CP}_{\\mathrm{A}} 、 \\mathrm{CP}_{\\mathrm{C}}$\n\n若$Y_n Y_{n+1}$为01\n$+\\mathrm{A},+\\mathrm{B}, \\quad \\Sigma \\rightarrow \\mathrm{A}, \\quad \\Sigma / 2 \\rightarrow \\mathrm{A} 、 \\overrightarrow{\\boldsymbol{C}}, \\mathrm{CP}_{\\mathrm{A}} 、 \\mathrm{CP}_{\\mathrm{C}}$\n\n若$Y_n Y_{n+1}$为10\n$\\begin{array}{c}+\\mathrm{A} 、 \\overline{\\boldsymbol{B},}+\\mathbf{1}, \\Sigma \\rightarrow \\mathrm{A}, \\Sigma / 2 \\rightarrow \\mathrm{A} 、 \\overrightarrow{\\boldsymbol{C}}, \\mathrm{CP}_{\\mathrm{A}} 、 \\mathrm{CP}_{\\mathrm{C}} \\\\(+\\bar{B},+1 \\text { 实现B变补 })\\end{array}$\n\n\n\n\n组合逻辑控制器组合逻辑控制器的微命令是由组合逻辑电路来实现。每种微命令都需要一组逻辑电路，全机所有微命令所需的逻辑电路就构成了微命令发生器。\n工作原理从主存读取的现行指令存放在IR中，其中，操作码与寻址方式代码分别经译码电路形成一些中间逻辑信号，送入微命令发生器，作为产生微命令的基本逻辑依据。\n微命令的形成还需考虑各种状态信息，如PSW所反映的CPU内部运行状态、由控制台（如键盘）产生的操作员控制命令、I/O设备与接口的有关状态、外部请求等等。\n微命令是分时产生的，所以还需引入时序系统提供的周期、节拍、脉冲等时序信号。\nIR中的地址段信息送往地址形成部件，按照寻址方式码形成实际地址，或送主存以访问主存单元；或送往运算器，按指定的寄存器号选取相应的寄存器。\n当程序顺序执行时，PC增量计数，形成后续指令的地址；当程序需要转移时，IR中的地址段信息经地址形成部件产生转移地址，送入PC，使程序发生转移。\n时序系统组合逻辑控制器依靠不同的时间标志，使CPU分步工作，模型机按常规采用工作周期、时钟周期、工作脉冲三级时序。\n工作周期模型机设置了六种工作周期状态，用六个周期状态触发器作为它们的标志。其中，四个工作周期（取指、源、目的、执行）用于指令的正常执行，两个工作周期（中断、DMA）用于I/O传送控制。\n某一时期内只有其中一个周期状态触发器为1，指明CPU现在所处的工作周期状态，为该阶段的工作提供时间标志与依据。\n\n取指周期FT：在FT中完成的操作是公共性操作\n\n源周期ST：如果需要从主存中读取源操作数（非寄存器寻址），则进入ST\n\n目的周期DT：如果需要从主存中读取目的地址或目的操作数（非寄存器寻址），则进入DT\n\n执行周期ET：取得操作数后，CPU进入E，这也是各类指令都需经历的最后一个工作阶段\n\n中断周期IT：除了考虑指令的正常执行，还需考虑外部请求带来的变化。在响应中断请求之后，到执行中断服务程序之前，需要一个过渡期，称为中断周期IT\n\nDMA周期DMAT：响应DMA请求之后，CPU进入DMAT。在DMAT中，CPU交出系统总线的控制权，即MAR、MDR与系统总线断开（呈高阻态），改由DMA控制器控制系统总线，实现主存与外围设备间的数据直传。\n\n\n\n时钟周期（节拍）指令的读取与执行既有CPU内部数据通路操作，也包含访问主存的操作。为简化时序控制，模型机将两类操作周期统一起来，即以主存访问周期所需时间为时钟周期的宽度，这里设为1微秒。\n工作脉冲时钟周期表示一个时间段，在这段时间内可以进行某种数据通路操作，如两数相加。但有些操作需要同步定时脉冲进行控制，如将稳定的运算结果打入寄存器，又如进行周期状态切换。模型机在每个时钟周期的末尾发一个工作脉冲P，作为各种同步脉冲的来源。\n指令流程与操作时间表取指周期FT进入FT的方式与条件\n由S端异步置入\n上电初始化\n复位初始化\n\n\n运算过程中同步打入FT（由D端打入）\n程序正常执行，应进入FT\nDMA周期执行后，应进入FT\nIT周期执行后，应进入FT\n\n\n\n取址流程$M\\rightarrow IR,PC+1\\rightarrow PC$\n操作时间表EMAR，R，SIR，PC→A，经过ALU中传送，DM ,CPPC，\n① 1→ST,CPST；\n② 1→DT,CPDT；\n③ 1→ET,CPET；\n寻址方式\n(R)\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nRi→MAR\nRi→A/B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\n1→DT？\nCPDT？\n\n\n\n\n1→ET？\nCPET？\n\n\n\n\n-(R)\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nRi-1→Ri，MAR\nRi→A/B\n\n\n\n\n\n在ALU中A-1\n\n\n\n\n\nDM\nCPMAR,CPR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\n1→DT?\nCPDT?\n\n\n\n\n1→ET?\nCPET?\n\n\n\n\n(R)+\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nRi→MAR\nRi→A/B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\nT+1\nCPT\n\n\nST2\nRi+1→Ri\nRi→A/B\n\n\n\n\n\n在ALU中A+1\n\n\n\n\n\nDM\nCPRi\n\n\n\n\n1→DT？\nCPDT？\n\n\n\n\n1→ET？\nCPET？\n\n\n\n\n@(R)+\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST2\nRi+1→Ri\nRi→A/B\n\n\n\n\n\n在ALU中A+1\n\n\n\n\n\nDM\nCPRi\n\n\n\n\nT+1\nCPT\n\n\nST3\nC→MAR\nC→A/B\n\n\n\n\n\n在ALU中传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCDT\n\n\nST4\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\n1→DT?\nCPDT?\n\n\n\n\nX(R)\n\n\n\n\n\n电平\n脉冲\n\n\n\n\nST0\nPC→MAR\nPC→A\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST1\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\nT+1\nCPT\n\n\nST2\nPC+1→PC\nPC→A\n\n\n\n\n\n在ALU中A+1\n\n\n\n\n\nDM\nCPPC\n\n\n\n\nT+1\nCPT\n\n\nST3\nRi+C→MAR\nRi→A/B,C→B/A\n\n\n\n\n\n在ALU中A+B\n\n\n\n\n\nDM\nCPMAR\n\n\n\n\nT+1\nCPT\n\n\nST4\nM→MBR→C\nEMAR\n\n\n\n\n\nR\n\n\n\n\n\nSMBR\n\n\n\n\n\nMBR→B\n\n\n\n\n\n经过ALU传送\n\n\n\n\n\nDM\nCPC\n\n\n\n\n1→DT？\nCPDT？\n\n\n\n\n1→ET？\nCPET？\n\n\n\n\n模型机的微程序控制器基本概念\n微命令：构成控制信号序列的最小单位，又称微信号，指那些直接作用于部件或控制门电路的命令。\n\n​    如：打开或关闭某传送通路的电信命令，或对触发器或    R进行同步打入，置位、复位等的控制脉冲。\n\n微操作：由微命令控制实现的最基本的操作称为微操作，如：开门、关门、选择。\n\n微周期：从控制存储器中读取一条微指令并执行相应的一步操作所需的时间，称为一个微周期或微指令周期。通常一个时钟周期为一个微周期。\n\n微指令：每个微周期的操作所需的微命令组成一条微指令。从控制存储器的组织角度讲，每个单元存放一条微指令。\n微程序：一系列微指令的有序集合称为微程序，用来解释执行一条机器指令。\n\n对应关系\n一条机器指令$~\\longleftrightarrow~$一段微程序$~\\leftarrow~$一系列微指令$~\\leftarrow~$若干微命令\n微程序控制\n将控制器所需的微命令，以代码（微码）形式编成微指令，存入一个ROM构成的控制存储器中。  ……将存储逻辑引入CPU。\n\n将各种机器指令的操作分解为若干微操作序列。  ……将程序技术引入CPU的构成级。\n\n\n上面从两个角度阐明了微程序控制的基本概念：\n\n微命令的产生方式\n微程序与机器指令之间的对应关系。\n\n\n","slug":"计组复习-2","date":"2023-12-15T08:06:14.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"66c8c18b39717219057479840ba6c9df","title":"计组复习-1","content":"计算机中的信息表示一、基本概念及应用（注明：应用是指基本概念的应用）\n\n一个数值型数据的完整表示需三个方面？\n权、基数？\n真值？机器数的定义？分类？\n数的定点表示与浮点表示？\n指令？指令系统？\n地址码？寻址方式？地址结构？\n寻址方式：\n\n大致可将众多的寻址方式归纳为以下四大类，其它的寻址方式则是它们的变型或组合。\n① 立即寻址。在读取指令时也就从指令之中获得了操作数，即操作数包含在指令中。\n② 直接寻址类。直接给出主存地址或寄存器编号，从CPU内或主存单元内读取操作数。\n③ 间接寻址类。先从某寄存器中或主存中读取地址，再按这个地址访问主存以读取操作数。\n④ 变址类。指令给出的是形式地址（不是最终地址），经过某种变换（例如相加、相减、高低位地址拼接等），才获得有效地址，据此访问主存储器以读取操作数。\n8.何谓隐式I/O指令？其主要特点是什么？\n9.主机调用外围设备，外设编制可采用那几种方式？\n二、计算题                                                    \n1.扩展操作码：根据条件计算指令条数？\n2.根据寻址方式寻找操作数？\n3.IEEE754短浮点数格式表示？\n进位计数值及其相互转换多位数码中每一位数码的构成方法及从低位向高位的进位规则称为进位计数制，简称数制。\n基数：每个数位中所允许的最大数码值+1或每个数位中所允许的最多数码个数。\n权：是一个与所在数位相关的常数。\n权与基数的关系：相邻两位的权值之比等于基数值。\n\n\n十进制十进制转二进制：\n\n整数：除基取余（倒序排列）直至商为0（转R进制也相同）\n小数：乘基取整（顺序排列）直至小数为0或达到指定位数（转R进制也相同）\n\n二进制转十进制：按权展开各部分相加（转R进制也相同）\n二进制八进制：从小数点起分别向左向右三位一组，不够三位时整数不够在前面添0，小数不够在后面添0。八进制转二进制则相反。\n十六进制：从小数点起分别向左向右四位一组，不够三位时整数不够在前面添0，小数不够在后面添0。十六进制转二进制则相反。\n带符号数的表示真值：用正负号与绝对值表示数值\n机器数表示：\n机器数：在计算机内部使用，将符号数值化\n机器数由符号位+有效位构成，最高位表示符号（正0负1）。\n原码正数原码符号为0，负数原码符号为1；有效位与真值有效位相同。\n真值0有两种表示：\n$\\begin{array}{l}{[+0]_{\\text {原 }}=00000000 \\mathrm{~B} ;} \\\\{[-0]_{\\text {原 }}=10000000 \\mathrm{~B} ;}\\end{array}$\nn位整数原码（含一位符号）的表示范围：$-\\left(2^{n-1}-1\\right) \\sim+\\left(2^{n-1}-1\\right)$\nn位纯小数原码（含一位符号）的表示范围：$-\\left(1-2^{-(n-1)}\\right) \\sim+\\left(1-2^{-(n-1)}\\right)$\n反码正数：反码符号为0，有效位与真值有效位相同\n负数：反码符号为1，有效位为真值有效位各位取反\n真值0有两种表示：\n$\\begin{array}{l}{[+0]_{反}=00000000 \\mathrm{~B} ;} \\\\{[-0]_{反}=11111111 \\mathrm{~B} ;}\\end{array}$\nn位整数反码（含一位符号）的表示范围：$-\\left(2^{n-1}-1\\right) \\sim+\\left(2^{n-1}-1\\right)$\nn位纯小数反码（含一位符号）的表示范围：$-\\left(1-2^{-(n-1)}\\right) \\sim+\\left(1-2^{-(n-1)}\\right)$\n补码正数：补码符号为0，有效位与真值有效位相同\n负数：补码符号为1，有效位为真值有效位各位取反后末位+1\n真值0只有一种表示：00000000B\n编码100000000B表示-128（8位补码表示的最小负数）。\nn位整数补码（含一位符号）的表示范围：$-2^{n-1} \\sim+\\left(2^{n-1}-1\\right)$\nn位纯小数补码（含一位符号）的表示范围：$-1\\sim +(1-2^{-(n-1)})$\n\n\n\n\n\n\n\n\n\n\n原码两次取补还是原码，常用于补码求原码。 \n正数的原码、反码、补码相同\n\n补码加减运算操作数用补码表示，符号位一起参与运算；运算结果为补码形式，结果符号通过运算得到。\n补码加：两个数的补码之和等于两个数之和的补码，即$(X+Y)_补=X_补+Y_补$\n补码减：两个数的补码之差等于两个数之差的补码，即$(X-Y)_补=X_补-Y_补=X_补+(-Y)_补$\n特别注意$(-Y)_补$：将$Y_补$连同符号位一起各位变反，末位+1，称为求补（变补）操作\n补码表示：原码转补码\n变补：补码连同符号位取反末位加1，称为补码的机器负数。\n溢出超出8位补码能表示的最大正数127产生正溢，如$(126+2)_补$\n超出8位补码能表示的最小负数-128产生负溢，如$(-2-(127))_补$\n定点数小数点位置固定不变的数称为定点数。\n\n无符号定点整数：正整数，不考虑符号位，所有数位都用于表示有效值。\n带符号定点整数：纯整数，小数点在最低位之后，最高位为符号位，其余表示有效位。\n带符号定点小数：纯小数，最高位为符号位，小数点位于符号位之后，用原码或补码表示。\n\n定点数表示的范围和分辨率（相邻两个数位的差）与二进制序列的位数有关。\n\n浮点数小数点位置不固定，可随需要浮动。\n真值$\\mathbf{N}= \\pm \\mathbf{R}^{\\mathrm{E}} \\times \\mathbf{M}$\n式中$  N  $为真值，$R^{E}  $为比例因子，$M  $是尾数,  $E  $为阶码， $R  $为阶码的底；\n对于某种特定浮点格式，R固定不变且隐含约定，一般选择与尾数M的基数相同。\n浮点数的机器格式\nE：阶码，带符号定点整数，可用补码或移码表示；指明小数点位置，决定浮点数的表示范围。\nM：尾数，带符号定点小数，可用补码或原码表示；给出有效值位数，决定浮点数的精度。\n尾数规格化（绝对值的最高位为1）：\n\n原码表示：$1/2\\leq|M|&lt;1$\n补码表示：$1/2\\leq M&lt;1,-1\\leq M\\leq -1/2$\n例如：0.1001，1.0111，1.1（特例，真值-1/2）\n\n\n\n\n移码常用于表示浮点数的阶码。\n定义：真值$  X  $的$  m+1  $位（含一位符号位）移码表示为：\n$X_{\\text {移 }}=2^{m}+X $，其中：$-2^{m} \\leqslant X&lt;2^{m}$\n相当于真值X沿坐标轴平移了$  2^{m} $，所以称为移码。\n我们需要注意，移码和补码符号是相反的，真值为负移码永远为正，为正移码永远为负。\n\n特点：\n\n最高位为符号位，正数移码符号位为1, 负数移码符号位为0，与原码、补码表示相反\n除符号位之外，移码的其余各位与补码相同\n随着$X$从最小逐渐增至最大，相应地$X_移$从$00\\cdots00$逐渐增至$  11 \\cdots \\cdots \\cdot 11 $，呈递增状，能更直观地比较阶码大小。\n\nIEEE754（非常重要，必考）\n\n短浮点数（或称短实数、单精度浮点数，32位）\n\n长浮点数（或称长实数、双精度浮点数，64位）\n\n临时浮点数（或称临时实数、扩展精度浮点数，80位）\n\n\n\n根据浮点数的尾数规格化，我们省略了一位数字$2^0$，所以实际上尾数数值应该有24位。\n十进制真值转换为浮点数：\n\n先将十进制转换为二进制\n规格化二进制数（隐藏尾数最高位1，还原为真值时需要加回来）\n计算移码表示的阶码，表示为二进制（偏置值+阶码真值）\n以短浮点数格式存储该数\n\n例题\n\n\n\nIEEE754转为十进制真值单精度浮点计算公式\n$(-1)^{S} \\times 1 . M \\times 2^{E-127}\\left\\{\\begin{array}{l}S: \\text { 符号位 (1为负, } 0 \\text { 为 正) } \\\\M: \\text { 尾数, 表示小数 } \\\\E: \\text { 阶码 }\\end{array}\\right.$\n其他精度只需更换对应的偏置值即可。\n\n指令&amp;指令系统指令：一系列按照某种规律有序排列的，能被CPU识别、执行的二进制代码。\n指令系统（或集）：一台计算机所能执行的全部指令。\n指令系统—-对应—-计算机硬件功能\n指令基本格式一条指令提供两方面的信息：\n① 与CPU操作有关的信息—-操作码（OP）\n② 与操作数有关的信息—-地址码（AD）。\n注意：一条指令中的操作码OP有且仅有一个，而地址码A可有0、1、2、3个。\n$\\begin{array}{|l|l|}\\hline \\text { 操作码OP } &amp; \\text { 地址码 } \\mathrm{A} \\\\\\hline\\end{array}$\n指令长度：影响指令执行时间\n在1~7个字节之间，操作码1~2B，操作数（地址码）0~2个\n指令类型：\n\n零操作数：可隐含提供操作数\n单操作数：可隐含提供另一个操作数\n双操作数\n\n指令格式设计时需要注意：\n\n指令字长\n\n固定字长\n可变字长\n\n\n操作码\n\n位数与位置固定\n可扩展\n\n\n地址码\n\n涉及的地址\n\n指令中给出地址\n\n数量\n显式地址：0123地址指令\n隐式地址\n\n简化地址结构的基本途径：尽量使用隐地址。\n\n\n\n寻址方式\n\n直接寻址\n间接寻址\n经过某种变换（包括计算）获取\n\n\n\n操作码操作码的位数决定了操作类型的多少，位数越多所能表示的操作种类也就越多。\n\n定长操作码\n指令长度比较长时，位置、位数固定，位置在指令的前几位\n\n扩展操作码：\n指令长度比较长时，位置、位数不固定，用扩展标志表示\n\n\n扩展操作码\n设地址长度为n，上一层留出m种状态，下一层便可扩展出$m\\times 2^n$种状态。\n\n地址结构在指令中明确给出几个地址，给出哪些地址。\n\n指令给出操作数地址方式\n\n显式：直接、间接、变址、基址\n隐式：隐含约定寄存器号、主存储器单元号\n\n四地址指令\n三地址指令\n二地址指令\n一地址指令\n例：无符号乘法\n1）字节乘法：OPRD × AL → AX\n如：MUL DL  ;DL × AL → AX\n2）字乘法：OPRD × AX → DX: AX\n如：MUL BX  ;BX × AX → DX: AX\n\n\n\n\n\n\n\n\n\nOPRD是源操作数，AL 是隐含的另一个源操作数，AX是隐含的目的操作数\nAX是一个十六寄存器，AL是它的低八位，AH是它的高八位\nMUL是无符号乘法指令，指令格式 MUL SRC\n如果SRC是字节操作数，则把AL中的无符号数与SRC相乘得到16位结果送AX中，即：AX←（AL)*(SRC)。如果SRC是字操作数，则把AX中的无符号数与SRC相乘得到32位结果送DX和AX中，DX存高16位，AX存低16位                                            \n\n\n\n\n\n\n\n\n\n\nNEG 被0减 相当于补码\nNOT 按位变反 相当于反码\n零地址指令\n\n\n\n\n\n\n\n\n\n\nFLAGS 标志寄存器：又称程序状态字（PSW）是一个16位的寄存器，存放条件标志、控制标志，主要用于反映处理器的状态和ALU运算结果的某些特征及控制指令的执行。\npushf 将标志寄存器的值压栈，而 popf 是从栈中取出数据，存入标志寄存器\n取标志指令LAHF  功能：将标志寄存器低八位的内容送给AH\n设置标志指令SAHF功能：将AH的内容送给标志寄存器的低八位\n\n==寻址方式==按字编址：按字长编址，字长由计算机位数决定，比如32位就是1字=32bit\n按字节编址：一个地址对应一个字节\n能被CPU直接使用的操作数位置：\n\nCPU内的R\n主存M（CACHE、接口中的R）\n\n① CPU能够直接访问的操作数只能存放在主存储器（包括CACHE、接口中的R）或CPU内的寄存器中；\n② 由于主存储器的容量远远大于CPU内的寄存器的容量，因此CPU能够直接访问的操作数主要存放在主存储器中。\n寻址方式可分为四大类，其它的寻址方式则是它们的变型或组合：\n\n立即寻址\n在读取指令时也就从指令之中获得了操作数，即操作数包含在指令中。\n\n直接寻址\n直接给出主存地址或寄存器编号，从CPU内或主存单元内读取操作数。\n\n间接寻址\n先从某寄存器中或主存中读取地址，再按这个地址访问主存以读取操作数。\n\n变址类\n指令给出的是形式地址（不是最终地址），经过某种变换（例如相加、相减、高低位地址拼接等），才获得有效地址，据此访问主存储器以读取操作数。\n\n\n立即寻址立即寻址是一种特殊的寻址方式。\n指令中在操作码字段后面的部分是操作数本身，也就是在取出指令的同时也就取出了可以立即使用的操作数。\n如MOV AX, 1234H\n直接寻址（绝对地址）由指令直接给出操作数地址，根据该地址可读取或写入操作数，这种方式称为直接寻址方式。\n直接寻址（主存直接寻址）若指令中给出的地址码是主存的某个单元号，操作数存放在该指定的主存单元中，这种寻址方式称为直接寻址或主存直接寻址方式。\n假定主存储器是按字编址，一个操作数占一个主存单元，操作数为S，主存单元地址码为A；指令也是占一个字，其中包含操作码OP和地址码A。\n\n操作数S与地址码A的关系为：S=(A)\n寄存器寻址（寄存器直接寻址）若指令中给出的地址码是寄存器编号，操作数存放在该指定的寄存器中,这种寻址方式称为寄存器寻址或寄存器直接寻址方式。\n在CPU中有若干寄存器，其中的一些是可编程访问的，称为可编址寄存器，设计时为它们分配不同的寄存器编号。指令中给出的寄存器号是Ri，从寄存器Ri中可直接读取操作数S。\n\n操作数S与寄存器Ri的关系为：S=(Ri）\n直接寻址与寄存器寻址方式的比较\n直接寻址是访问一次主存才能读取所需操作数\n\n寄存器寻址是从CPU的寄存器中读取操作数，不需访问主存，所需时间大约是从主存中读数时间的几分之一到几十分之一，因而寄存器寻址比直接寻址快得多。\n\n\n\n\n\n\n\n\n\n注意：减少指令中地址数目与减少一个地址的位数是两个不同的概念。\n采用隐地址可以减少指令中地址的数目；\n采用寄存器寻址方式、寄存器间址方式可以使指令中为给出一个地址所需的位数减少。\n其实，均减少了指令长度。\n\n\n间接寻址地址段提供的不一定就是操作数地址，如间接寻址方式。\n主存间接寻址方式\n若操作数存放在主存某个存储单元中，则该主存单元的地址被称为操作数地址。\n\n若操作数地址存放在另一主存单元之中（不是由指令直接给出），则该主存单元被称为间址单元，间址单元本身的地址被称为操作数地址的地址。\n\n若指令中地址给出的是间址单元地址（即操作数地址的地址，而不是操作数地址，且在主存），从中读取操作数地址，按照操作数地址再次访问主存，从相应单元中读写操作数，这种寻址方式称为间接寻址或主存间接寻址方式。\n\n指令中给出地址A1，据此访问间址单元，从中读取地址A2，按A2再访问一次主存，读取操作数S。\n\n操作数S与地址A1的关系为：S=((A1))=(A2)\n寻址过程为：间址单元地址$~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数地址$~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数\n寄存器间接寻址方式若指令中给出的地址码是寄存器编码，被指定的寄存器中存放的是操作数地址，按照该地址访问某主存单元，该单元的内容为操作数，这种寻址方式称为寄存器间接寻址。\n指令在地址段给出的是寄存器号Ri，从Ri中读出的是操作数地址A，按地址码A访问主存，从相应单元中读取操作数S。\n\n操作数S与地址A1的关系为：S=((Ri))\n寻址过程为：间址单元地址$~\\stackrel{\\text { M2 }}{\\longrightarrow}~$操作数地址$~\\stackrel{\\text { M2 }}{\\longrightarrow}~$操作数\n间接寻址的变形自减型寄存器间址方式若指令中给出寄存器号，被指定的寄存器内容先减1后作为操作数地址，按照该地址访问主存储器，相应的主存单元内容为操作数，自减型寄存器间址方式常用助记符-(R)表示。 \n指令在地址段给出的是寄存器号Ri，将Ri中的内容减1作为操作数地址A，按地址码A访问主存，从相应单元中读取操作数S。\n\n寄存器号$~\\stackrel{\\text { Ri }}{\\longrightarrow}~$操作数地址= (Ri) - 1$~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数\n操作数S与寄存器Ri的关系为：S=((Ri-1))\n通过重复执行这同一条指令，就可以访问从(Ri-1)开始沿地址码减小方向的一个连续数据区。\n堆栈寻址堆栈寻址方式是指操作数在堆栈中，指令隐含约定由堆栈指针SP寄存器提供栈顶单元地址（SP也可以编码形式出现在指令中），进行读出或写入的一种寻址方式。 \n根据压入数据时栈顶单元的地址是减小还是增大或不变，可以将堆栈的工作方式大致分为向上生成方式（SP+1）、向下生成方式（SP-1）和栈顶固定方式三种。\n指令在地址段给出的是寄存器号SP，对SP中的内容进行相应操作（减1或不变，对应压栈或出栈），得到操作数地址A，按地址码A访问主存，从相应单元中访问操作数S。\n\n\n压栈：寄存器号$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数地址 = (SP) - 1 $~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数\n操作数与寄存器SP的关系为：S = ((SP - 1))\n\n出栈：寄存器号$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数地址$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数\n操作数与寄存器SP的关系为：S = ((SP))，弹出后修改堆栈指针：(SP) + 1 $\\rightarrow$ SP\n\n\n多重间接寻址（主存多重间接寻址）根据指令找到间址单元，其中的内容还不是操作数地址，而是又一层间址单元的地址；根据该地址访问又一层间址单元，取出来的才是操作数地址（存放操作数的存储单元的地址码），可在间址单元的存储内容中设置一位间址标志位，一般选取最高位，当该位为1时，表明所读出的是间接地址,还需再次间址；直到该位为0,表明这次取出的是操作数的有效地址，按这个地址访问主存，读出的是操作数(即间址过程结束)。\n\n寄存器多重间址\n\n寄存器号$~\\stackrel{\\text { R }}{\\longrightarrow}~$一级间址$~\\stackrel{\\text { M }}{\\longrightarrow}~\\cdots \\stackrel{\\text { M }}{\\longrightarrow}$操作数\n\n存储器多重间址\n\n寄存器号$~\\stackrel{\\text { M }}{\\longrightarrow}~$一级间址$~\\stackrel{\\text { M }}{\\longrightarrow}~\\cdots \\stackrel{\\text { M }}{\\longrightarrow}~$操作数\n\n\n变址寻址若指令中给出变址寄存器号和一个形式地址，变址寄存器的内容(称为变址量)与形式地址相加，得到操作数有效地址(即操作数实际地址)，按照有效地址访问某主存单元,该单元的内容即为操作数，这种寻址方式称为变址寻址方式。变址方式常用助记符X（R）表示。\n指令中为获得某个操作数地址给出两个信息：\n形式地址D，变址寄存器Rx。有效地址A= D+(Rx)= D+N，根据A访问主存储器，读写操作数S。\n\n例如：\nMOV AX, 10H[BX]  ;\n​    等价于MOV AX, DS: 10H[BX]\n\n\n\n\n\n\n\n\n\n其中 DS 是数据段寄存器，而 10H[BX] 依然表示偏移量和基地址。数据从内存地址 DS * 16 + BX + 10H 处加载到寄存器AX中。\nMOV AL, 20H[SI]   ;\n   等价于MOV AL, DS: 20H[SI]\n基址寻址若指令中给出基址寄存器号和一个形式地址，基址寄存器内容（作为基准地址）与形式地址（作为位移量）相加，其和为操作数有效地址(即操作数实际地址)，按照该地址访问主存储器，该单元的内容即为操作数，这种寻址方式称为基址寻址。\n指令中为获得某个操作数地址给出了两个信息：\n形式地址D，基址寄存器RB。有效地址A= D+(RB)= D+N，根据A访问主存储器，读写操作数S。\n\n基址&amp;变址比较\n基址寻址方式的目的是扩大有限字长指令的寻址空间,变址寻址方式的目的是为了灵活修改地址以适应连续区间(程序循环)的操作。\n如果在同一条指令中要兼有这两种功能，可以采取复合型的寻址方式，即基址加变址方式。\n变址&amp;基址寻址变化相对寻址X(PC)若指令中选定程序计数器PC作为变址寄存器，或是隐含地指定PC，指令中给出的形式地址作为位移量（可正、可负），二者相加后形成操作数的有效地址。这种寻址方式实际上就是以当前指令位置为基准，相对它进行位移定位（往前或往后），所以称为相对寻址。\n程序计数器PC的内容为现行指令地址A，按地址A从主存中读取指令;\n指令中形式地址段给出位移量d，它是从现行指令位置到操作数S所在单元之间的距离（单元数）;\n操作数有效地址D=A+d，据此访问主存储器，从D单元中读取操作数。\n\n\n页面寻址将PC内容的高位段与位移量相拼接,相对寻址就演变成页面寻址。\n程序计数器PC的内容为A，指令中形式地址段给出位移量d。\n按页面寻址方式，操作数有效地址 = $(PC)_H，d $；\n据此访问主存储器，从单元中读取操作数。\n\n\n以上四类十余种寻址方式,重点在“数在哪里”(在指令中、在CPU寄存器中、在主存中)。\n① 如果操作数在主存中，指令直接给出有效地址还是通过“多次读取”间接获得有效地址(通过寄存器间址、通过存储单元间址)?\n② 如何通过计算使地址量可变 (与变址寄存器内容加、与基址寄存器内容加、与程序计数器内容加或拼接)?\n指令类型自己看看得了\n","slug":"计组复习-1","date":"2023-12-13T11:53:39.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"add768c24e8f1c57682e3d07a8cf025b","title":"DMA方式","content":"DMA方式及接口定义\nDMA，即直接存储器访问（Direct Memory Access），它指这样一种传送控制方式：依靠硬件直接在主存与外围设备之间进行数据传送，在传送过程中不需要CPU的干预。\n特点：DMA方式只能处理简单的数据传送。\n应用：DMA传送方式一般应用于主存与高速I/O设备之间的简单数据传送。高速I/O设备包括磁盘、磁带、光盘等外存储器，以及其他带有局部存储器的外围设备、通信设备等等。典型的例子是磁盘调用，磁盘读写采用DMA方式进行数据传送，而对寻道正确性的判别、批量传送结束后的处理，则采用中断方式。\nDMA控制器与接口的连接\nDMA控制器功能初始化：接收初始化信息（传送方向、主存首址、交换量）\n传送前：接收外设DMA请求，判优，向CPU申请总线。\n传送期间：接管总线权，发地址、读/写命令。（不需要CPU干预）\n接口功能初始化：接收初始化信息（外设寻址信息）。\n传送前，外设准备好：向DMA控制器发请求。\n传送期间：传送数据。\n磁盘存储器接口（磁盘适配器）\n系统连接方式：\n\n两级DMA控制器：\n\n主机板上DMA控制器：M$\\longleftrightarrow$适配器\n适配器内DMA控制器：适配器$\\longleftrightarrow$适配器\n\n\n硬盘适配器粗框\n\n\n处理机接口（面向系统总线一侧）\nEPROM控制逻辑：放有硬盘驱动程序(系统自检时被引入系统管理之下)。\nI/O端口控制逻辑：接收CPU送来的端口地址、读/写命令，访问处理机接口中的相应寄存器。\n\n\n智能主控器\n微处理器：执行硬盘控制程序\nRAM：扇区缓存（存放第二个扇区数据）\nROM：存放硬盘控制程序\nDMA控制器：控制主控RAM与驱动器之间的数据传送。\n硬盘控制逻辑：控制串-并转换：\n写盘：主控RAM$\\stackrel{并-串}{\\longrightarrow}$驱动器\n读盘：驱动器$\\stackrel{串-并}{\\longrightarrow}$主控RAM\n\n\n\n\n驱动器接口（面向设备一侧）\n驱动器控制逻辑：向驱动器送出控制命令（驱动器选择、寻道方向选择、读、写等）\n驱动器状态逻辑：接收驱动器状态信息（选中、就绪、寻道完成等）\n传送串行数据\n\n\n\n\n硬盘调用过程（DMA方式）\n\n初始化：CPU向适配器送出驱动器号、圆柱面号、磁头号、起始扇区号、扇区数等外设寻址信息；向DMA控制器送出传送方向、主存首址、 交换量等信息。\n适配器启动寻道，并用中断方式判寻道是否正确。（不正确，重新寻道；正确，启动磁盘读/写。）\n适配器准备好（读盘：主控RAM满一扇区；写盘：主控RAM空一扇区），提出DMA请求。\nCPU响应，由DMA控制器控制总线，实现传送。\n批量传送完毕，适配器申请中断。\nCPU响应，作善后处理。\n\n\n\n","slug":"DMA方式","date":"2023-12-12T07:14:56.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"87122f1313843578dbea5a21e7a0d4c1","title":"中断","content":"中断方式及接口中断：CPU暂时中止现行程序的执行，转去执行为某个随机事态服务的中断处理程序。处理完毕后自动恢复原程序的执行。\n\n实质：\n程序切换。\n方法：\n\n保存断点，保护现场（中断处理前）\n恢复现场，返回断点（中断处理后）\n\n时间：\n\n一条指令结束时切换\n保证程序的完整性。\n\n\n特点：随机性\n\n随机发生的事态（按键、故障）\n有意调用，随机请求与处理的事态（调用打印机）\n随机插入的事态（软中断指令插入程序任何位置）\n\n\n\n注意中断与转子的区别：\n\n转子子程序的执行是由程序员事先安排好的，而中断服务程序的执行则是由随机的中断事件引起的调用。\n转子子程序的执行受到主程序或上层子程序的控制，而中断服务程序一般与被中断的现行程序没有关系。 \n不存在同时调用多个转子子程序的情况，而可能发生多个外设同时请求CPU为自己服务的情况。\n\n分类\n\n硬件中断与软中断\n硬件中断：由硬件请求信号引发中断\n软中断：由软中断指令引发中断\n\n\n内中断与外中断\n内中断：中断源来自主机内部\n外中断：中断源来自主机外部\n\n\n可屏蔽中断与非屏蔽中断\n可屏蔽中断：可通过屏蔽字屏蔽该类请求；关中断时不响应该类请求。\n非屏蔽中断：该类请求与屏蔽字无关；请求的响应与开/关中断无关。\n\n\n向量中断与非向量中断\n向量中断：由硬件提供服务程序入口地址。\n非向量中断：由软件提供服务程序入口地址\n\n\n\n典型应用\n\n管理中低速I/O操作\n\n处理故障\n\n实时处理\n某事件出现的实际时间内及时处理，不是批量处理；\n利用时钟中断定时采集参数，检测，调节。\n\n人机对话\n\n多机通信\n\n\n终端系统的硬、软件组织\n硬件：I/O接口\n软件：中断请求源，中断服务程序，中断向量表\n\n中断请求源\n\n外部硬件中断源：8种，IREQ0—IREQ7\n内部硬件中断源：掉电、溢出、校验错中断等\n软中断：模型机软中断为INT11—INTn\n\n\n中断服务程序\n在主存种的空间不必连续\n\n中断向量表\n\n存放在模型机中的空间不必连续\n向量地址=中断号+2\n\n\n\n中断全过程中断请求的产生\n外设工作完成：完成标志为1\nCPU允许请求：屏蔽标志位为0\n\n\n中断请求的传送\n使用单独请求线\n\n\n使用公共请求线\n\n\n混合传送方式\n\n\n\n中断请求优先级判断\n优先顺序：故障、内中断、DMA、外中断\n\n基本原则：高速操作优于低速操作，输入优于输出\n\nCPU现行程序与外设请求的判优\n\nCPU设置允许中断标志，1为开中断，0为关中断（模型机）\n\nCPU设置程序状态字的优先级字段\n为现行程序赋予优先级：\n\n小于外设请求优先级，响应\n大于等于外设请求优先级，不响应\n\n\n\n\n\n外设请求的判优方法\n软件判优：由查询顺序（程序）确定优先级\n\n\n硬件判优\n\n一种采用独立请求线的并行判优逻辑\n\n\n链式优先权判优逻辑\n\n\n专用芯片硬件判优——中断控制器(8259)\n集中解决请求信号的接收、屏蔽、判优、编码等问题\n\n\n\n\n\n中断响应\n响应条件\n\n外设有请求，且未被屏蔽\nCPU开中断\n中断源优先级高于当前程序的优先级\n一条指令（非停机）结束，即ET之后\n\n\n进入中断周期\n安排一个过渡周期，位于主程序与中断服务程序之间，为转到中断服务程序做准备。\n\n响应过程（硬件自动完成）\n例如向量中断方式（单级中断）为例：\n\n\n\n中断周期IT（过渡周期依靠硬件实现）\n\n其中PC记录了断点内容。\n*优先权逻辑与屏蔽技术\n顺序是：\n中断请求$\\rightarrow$8259（未屏蔽的请求判优，生成相应中断号）$\\rightarrow$公共请求INT$\\rightarrow$CPU\nIRR 中断请求寄存器(Interrupt Request Register)：8位，可存放8个中断请求信号，作为向CPU申请与判优、编码的依据。接收到外部的中断请求后自动将对应标志位设置成1。\nPR 优先级裁决器(Priority Resolver)：即中断源的优先级排队逻辑，选择优先级最高的中断申请者。有两种优先级裁决规则：\n\n固定优先级：$IRQ_0&gt;\\cdots&gt;IRQ_7$\n循环优先级\n\nISR 中断服务寄存器(Interrupt Service Register)：8位，用来存放或记录正在服务中的所有中断请求优先级（如在多重嵌套时），每一位对应一个中断优先级。\nIMR 中断屏蔽寄存器(Interrupt Mask Register)：8位，其内容可由CPU预置。这就是前面提到的集中屏蔽方式，各接口可以提出自己的中断请求信号，在8259A中再与屏蔽字比较。对应位（IMRi）若为1，则该请求（IRRi）被屏蔽，不会被送往CPU。\nINT：用来给CPU发送中断信号\nINTA：用来接收CPU的INTA中断响应信号\n服务程序入口地址的获取方式向量中断\n中断向量：采用向量化的中断响应方式，将中断服务程序的入口地址及其程序状态字存放在特定的存储区中，所有的中断服务程序入口地址和状态字一起，称为中断向量。\n\n中断向量表：用来存放中断向量的一种表。\n在实际的系统中，常将所有中断服务程序的入口地址（或包括服务程序状态字）组织成一个一维表格，并存放于一段连续的存储区，此表就是中断向量表。\n\n向量地址：访问中断向量表的地址码，即读取中断向量所需的地址（也可称为中断指针）。\n\n向量中断：将各个中断服务程序的入口地址（或包括状态字）组织成中断向量表；响应中断时，由硬件直接产生对应于中断源的向量地址；据此访问中断向量表，从中读取zx\n\n服\n\n务程序入口地址，由此转向服务程序的执行。这些工作在中断周期IT中由硬件直接实现。\n\n\n中断向量表的组成在IBMPC中，中断向量表在主存中占用0—1023号地址单元（即1K），每个中断源占用4个单元，因此，该表中可存放256个中断源。\n$\\text { 组成 }\\left\\{\\begin{array}{ll}\\text { 专用区 } &amp; \\text { 中断类型码：0-4型 } \\\\\\text { 系统保留区 } &amp; \\text { 中断类型码：5-31型 } \\\\\\text { 用户扩展区 } &amp; \\text { 中断类型码：32-255型 }\\end{array}\\right.$\n从中断向量表中获取中断服务程序入口地址形成向量地址后根据中断向量表获取中断服务程序入口地址。根据中断方式，向量地址的形成有两种：\n\n硬中断：$向量地址=中断类型码\\times 4$\n软中断：$向量地址=中断号\\times 4$\n\n模型机向量表：\nM按字编址。一个入口地址16位，占一个编址单元。\n向量地址=中断号+2（单元地址）\n\nIBM PC向量表（从主存0#单元开始安排）\nM按字节编址。一个入口地址32位，占4个编址单元。\n向量地址=中断号 × 4\n\n非向量中断CPU响应中断时只产生一个固定的地址，由此读取中断查询程序的入口地址，通过软件查询，确定被优先批准的中断源，然后分支进入相应的中断服务程序。\n响应中断的条件\n有中断请求信号发生，如IREQi或INT n。\n\n该中断请求未被屏蔽。\n\nCPU处于开中断状态，即中断允许触发器TIEN=1（或中断允许标志位IF=1）。\n\n没有更重要的事件要处理（如因故障引起的内部中断，或是其优先权高于程序中断的DMA请求等）。\n\nCPU刚刚执行的指令不是停机指令。\n\n在一条指令结束时响应（因为程序中断的过程是程序切换过程, 不能在一条指令执行的中间就切换）。\n\n\n响应过程\n中断处理CPU执行中断服务程序。\n中断处理\n\n单级中断\nCPU响应后只处理一个中断源的请求，处理完毕后才能响应新的请求。\n\n多重中断\n在某次中断服务过程中，允许响应处理更高级别的中断请求。\n\n\n\n允许多重中断的处理方式\n\n恢复现场与返回原程序\n在编制中断服务程序时应遵循一个原则：在响应过程、保护现场、恢复现场等过渡状态中，应当关中断，使之不受打扰。\n中断接口组成（寄存器级）\n寄存器选择电路：对接口寄存器寻址。\n命令字寄存器：接收CPU发向外设的命令字，转换为相应操作命令送外设。\n命令字格式的拟定：用代码表示各种命令\n\n\n状态字寄存器：反映设备和接口的运行状态。\n数据缓冲器：传送数据，实现缓冲\n控制逻辑：\n请求信号产生逻辑\n电平转换逻辑\n串-并转换逻辑（串口）\n扩展中断源\n\n\n公用中断控制器\n接收外设请求，判优，送出公共请求INT\n接收中断批准INTA，送出中断号（中断类型码）\n\n\n\n\n工作过程（外中断）\n初始化：设置工作方式、屏蔽字、分配中断类型码等\n启动设备（送命令字）\n设备请求中断\n中断控制器汇集各请求，向CPU送INT\nCPU响应，发INTA\n中断控制器送出中断号\nCPU执行中断隐指令，转中断服务程序\n\n接口设计涉及命令字、状态字格式的拟定，中断源的扩展。\n","slug":"中断","date":"2023-12-12T01:23:45.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"e66d5f78b8371b501dcd13a0b9f02bba","title":"数值计算基本概念","content":"数值计算基本概念补档，之前漏了这一块\n误差分类\n模型误差：建立数学模型时所引起的误差；\n观测误差：测量工具的限制或在数据的获取时随机因素所引起的物理量的误差；\n截断误差：求解数学模型时，用简单代替复杂，或者用有限过程代替无限过程所引起的误差\n舍入误差：计算机表示的数的位数有限，通常用四舍五入的办法取近似值，由此引起的误差.\n\n误差度量\n绝对误差：\n绝对误差限：\n相对误差：$e_{r}(x)=\\frac{e(x)}{\\left|x^{}\\right|}=\\frac{\\left|x-x^{}\\right|}{\\left|x^{}\\right|} \\quad\\left(x^{} \\neq 0\\right)$\n相对误差限：$\\left|e_{r}(x)\\right|=\\left|\\frac{e(x)}{x^{}}\\right|=\\left|\\frac{x-x^{}}{x^{*}}\\right| \\leq \\varepsilon_{r} \\quad \\varepsilon_{r}&gt;0$\n\n是某一数据的准确值，是近似值。\n有效数字一个位有效数字的数：\n\n乘号前的部分称为尾数部，乘号后的部分称为阶码部。\n绝对误差限满足：\n相对误差限满足：\n若近似数的相对误差满足，则至少有位有效数字。\n数值运算的误差估计\n一元函数误差分析（准确值$y^=f(x^)$）\n绝对误差：\n相对误差：\n\n多元函数\n绝对误差：\n\n数据误差对算术运算影响\n\n\n\n2)  3)  \n\n\n数值计算中的一些基本原则\n避免绝对值小的数作除数\n\n避免两个相近的数据相减\n\n要防止大数“吃掉”小数 \n\n尽量减少计算工作量\n\n选用数值稳定性好的算法\n\n\n初始误差在算法执行过程中不断减小，这种算法称为数值稳定算法。\n","slug":"数值计算基本概念","date":"2023-12-04T08:10:47.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"24a433eb423b7b9a2feb4c638862cc39","title":"数值计算公式整理-第九章","content":"常微分方程的数值解本章主要介绍\n\n的数值解法。\n为了计算方便，可取，称为步长。\n常微分方程的数值解法有单步法和多步法之分：\n\n单步法：在计算时只用到前一点的值 ;\n多步法：计算时不仅利用, 还要利用  , 一般步法要用到。\n\n简单数值方法欧拉（Euler）方法用差商代替导数，在处有：\n\n同理在处，有\n\n若记则上式可记为\n此即为求解初值问题的Euler方法，又称显式Euler方法，精度较差。\n著直接对在积分,\n\n利用数值积分中的左矩形公式：\n\n设, 则得\n\n此即为Euler公式。\n若用右矩形公式：\n\n得\n上式称后退的Euler方法, 又称隐式Euler方法。可用迭代法求解:\n初值:  迭代：  \n因\n\n故当时，迭代法收敛。\n\n\n\n\n\n\n\n\n\n矩形公式：用积分区间和被积函数估计积分值\n梯形方法由利用梯形求积公式:\n\n得\n上式称梯形方法，是一种隐式方法。\n用迭代法求解：\n初值： \n迭代：  \n因\n\n故当时，迭代法收敛。\n改进的Euler方法采用将显式Euler格式与梯形格式结合使用的方法来避免求解非线性方程。\n记\n再用梯形格式计算:\n\n上面两式统称预测—校正法，又称改进的Euler方法。\n单步法的局部截断误差和精度单步法的一般形式为 : （与有关）\n\n显式单步法形式为:\n\n整体截断误差: 从开始，考虑每一步产生的误差, 直到 , 则有误差\n设是初值问题的精确解, 则称\n\n为显式单步法在节点处的局部截断误差。若存在最大整数使局部截断误差满足\n\n则称显式单步法具有阶精度或称阶方法。\n注：将表达式各项在处作Taylor展开，可得具体表达式。\nEular方法的局部截断误差设\n\n其中称局部截断误差主项。\n故，即Euler方法具1阶精度。\n梯形方法的局部截断误差设\n\n故，梯形方法具有2阶精度。\n局部截断误差主项为\nRunge-Kutta方法设法计算在某些点上的函数值，然后对这些函数值作线性组合，构造近似计算公式，再把近似公式和解的泰勒展开式相比较，使前面的若干项吻合，从而获得达到一定精度的数值计算公式 。\n对于Eular公式以及改进的Eular方法有\n\n\nEular公式局部截断误差： \n改进的Eular方法局部截断误差： \n设\n\n其中 为待定常数。\n上面第一个式子的右端在作泰勒展开后，按的幂次作升序排列 :\n\n再与初值问题的精确解在点处的泰勒展开式\n\n相比较，使其有尽可能多的项重合。\n例如, 要求\n\n就得到个方程，从而定出参数, 再代的表达式，就可得到计算微分方程初值问题的数值计算公式：\n\n上式称为级Runge - Kutta方法的计算公式。若，则称其为阶级方法。当时，就是Euler方法。\n二阶Runge-Kutta方法\n满足上述条件的公式都为2阶公式。\n如取, 则 , 即为改进 Euler公式。\n若取, 则, 得\n\n称中点公式，相当于数值积分的中矩形公式:\n\n三阶与四阶Runge-Kutta方法\n三阶\n\n常用公式\n\n\n四阶\n常用公式\n\n\n\n一阶常微分方程和高阶微分方程的数值解法简介一阶常微分方程下列包含多个一阶常微分方程的初值问题:\n\n称为一阶常微分方程组的初值问题。\n引进向量记号:\n\n则上述一阶常微分方程组的初值问题化为矩阵形式:  \n高阶微分方程可化为一阶常微分方程组求解。例如，二阶常微分方程初值问题\n\n引进新的变量, 令, 即可将上述二阶方程化为如下的一阶方程组的初值问题:\n\n","slug":"数值计算公式整理-第九章","date":"2023-12-02T05:49:38.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"69858ac0972069bd7cc93fc87b03fc2e","title":"数值计算公式整理-第八章","content":"数值积分积分的近似计算方法。\n基本思想：利用积分区间上一些离散点的函数值的线性组合计算定积分的近似值。无需寻求原函数。\n\n上式称数值求积公式。\n：求积系数  \n：求积节点\n：求积算式\n：求积公式的余项\n代数精度若求积公式\n\n对所有次数不超过次的代数多项式都准确成立, 即\n\n但对次多项式却不能准确成立, 即只要\n\n则称该求积公式具有次的代数精度。\n插值型求积公式已知函数在上的一组节点以及对应的函数值。\nLagrange插值多项式记\n\n则插值型求积公式为 ，为求积系数。\n余项:\n\n注:\n\n当取次数的多项式时，，即含个节点的插值型求积公式至少具有次代数精度。\n特别地，当时，有\n\nNewton-Cotes求积公式Newton-Cotes公式是指等距节点下使用Lagrange插值多项式建立的数值求积公式。\n设函数，将积分区间等分，步长, 节点为等距节点。\n引进变换，则有\n可得：\n\n记 所以插值型求积公式化为\n\n称Newton-cotes公式，式中称柯特斯系数。\n梯形(trapezia)公式及其余项取，\n上式称为梯形求积公式，也称为两点公式。\n余项为\n\n具有1次代数精度。\nSimpson公式及其余项取，则\n计算Cotes系数，得到求积公式为：\n\n上式称为Simpson求积公式，也称三点公式或抛物线公式。\nSimpson公式的余项:\n\n具有3次代数精度。\nCotes公式取，则\n计算Cotes系数，得到求积公式为：\n求积公式为\n\n上式称为Cotes求积公式, 也称五点公式，记为。\nCotes公式的余项:\n\nCotes公式具有5次代数精度。\n\n\n\n\n\n\n\n\n\n当为偶数时，Newton-Cotes公式至少具有次代数精度。\n复合求积公式在实际应用中一般不使用高阶Newton-Cotes公式，而是采用低阶复合求积法。\n将积分区间分成若干个子区间，然后在每个小区间上使用低阶Newton-Cotes公式，最后将每个小区间上的积分的近似值相加。\n复合梯形公式将等分,  ，在每个子区间上采用梯形公式，得阶复合梯形公式：\n\n记\n\n设被积函数, 由得  \n\n由于\n由介值定理，，使得\n即有\n\n\n当足够大的时候，余项为：\n\n复合Simpson公式将等分，在每个子区间上采用Simpson公式， 若记，则可得阶复合Simpson公式形式为\n\n当足够大时，余项为\n\n复合Cotes公式将等分，在每个子区间上采用Cotes公式， 若记，则可得阶复合Cotes公式形式为\n\n复合Cotes公式的余项：\n设被积函数，当足够大时\n\n比较三种公式的余项，趋于定积分的速度依次更快。\n外推原理利用若干已算出的近似值作适当组合以求得更精确的近似值的加速收敛的方法称外推算法。\n例如使用来近似逼近：\n\nRomberg求积算法byd什么玩意\n若将等分, 即将求积区间再二分一次，只增加一个分点，用复合梯形公式求得该区间的积分值为:\n\n进一步推导我们可以得到：\n\n分析与的误差我们可以得到：。这种以计算结果估计误差的方法称事后估计法。\n若用的误差作为的一种补偿，得到：\n\n进一步处理我们发现，即复合Simpson公式。\n类似的我们能得到，为复合Cotes公式。\n重复上述过程得到Romberg公式：\n\n由梯形公式出发，将逐次二分可以提高精度，每加速一次，误差量级提高2阶。\n一般地, 若记, 则有\n\n经过次加速后,  \n上述处理方法称理查森（Richardson）外推加速方法。\n设以表示二分次后求得的梯形值，且以表示序列的次加速值，则以外推公式\n\n得\n$T_{m}^{(k)}=\\frac{4^{m}}{4^{m}-1} T_{m-1}^{(k+1)}-\\frac{1}{4^{m}-1} T_{m-1}^{(k)}~~ (m=1,2, \\ldots, k) $\n称Romberg求积算法。\n计算过程\n取, , 求;由(为二分次数  )  计算\n求梯形值\n求加速值。用Romberg求积公式逐个求出表的第行其余元素\n若, 则中止计算, 并取；否则, 令, 转 (2) 继续。\n\n\nGauss求积公式找Gauss点才能用。\n公式\n含个待定参数, 当取等距节点时得到的插值型求积公式的代数精度至少为次, 若适当选取, 有可能使求积公式具次代数精度, 这类求积公式称Gauss 求积公式。为Gauss点。\n只要取对精确成立, 即\n\n解得即可得到Gauss求积公式。\n对积分区间, 作变换\n则求积公式为\n\n插值型求积公式\n\n的节点是Gauss 点的充要条件是以这些节点为零点的多项式\n\n与任何次数不超过次的多项式带权正交, 即\n\nGauss-Legendre求积公式因Legendre多项式是上的正交多项式, 故的零点就是求积公式\n\n的Gauss点, 上式称Gauss-Legendre求积公式。\n 时, 可得两点Gauss-Legendre求积公式:\n\n时, 三点Gauss-Legendre求积公式:\n\n当积分区间不是时, 可如前作变换:\n\nGauss-Chebyshev求积公式个求积节点的Gauss-Chebyshev求积公式为:\n\n","slug":"数值计算公式整理-第八章","date":"2023-12-02T05:49:34.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"cfaca4c6e1102b132048f2ed6d42b0f7","title":"数值计算公式整理-第七章","content":"数据拟合及最佳函数逼近若要求所求曲线（面）通过所给所有数据点，就是插值问题。\n若不要求曲线（面）通过所有数据点，而是要求它反映对象整体的变化趋势，这就是数据拟合，又称曲线拟合或曲面拟合。\n拟合与插值的区别：函数插值与曲线拟合都是要根据一组数据构造一个函数作为近似，由于近似的要求不同，二者的数学方法上是完全不同的。\n曲线拟合准则数据拟合的基本概念。\nChebyshev近似准则\n极小化最大绝对偏差：\n\n极小化绝对偏差之和：\n\n最小二乘准则（极小化绝对偏差平方之和）：\n\n平方误差：\n\n\n\n数据拟合的最小二乘法给定一组和，求\n\n使得\n\n最小（最小二乘准则）。最小二乘法：以残差平方和最小问题的解来确定拟合函数的方法。\n引入记号\n\n则由内积的概念可知\n\n显然内积满足交换律正规方程组便可化为\n\n这是一个系数为, 常数项为的线性方程组。\n将其表示成矩阵形式:\n\n使用多项式函数作为拟合函数，设基函数为\n\n基函数之间的内积为:\n\n正规方程组为\n\n超定方程组的最小二乘解\n若, 则此方程组称超定方程组（方程个数  &gt;  末知数个数）\n求解的主要过程：\n\n求出系数矩阵的转置矩阵\n计算矩阵和向量\n求解正规方程组。\n\n函数的最佳一致逼近基本思想：对于函数类A中给定的函数，在选定的函数类B中寻找的 “最佳” 逼近函数，使与之差在某种度量意义下最小。\n即\n正交多项式设是区间上的非负函数, 则称\n\n为上以为权函数的内积。\n设是区间上的权函数, 若\n\n成立, 则称在上带权正交。当时, 简称正交。\n若函数系满足关系\n\n则称是上带权的正交函数系。\n若，则称之为标准正交函数系。\n以四维矩阵为例：\n\n正交多项式的系数为：\n\n于是拟合函数可表示为\n\n勒让德（Legendre）多项式区间为, 权函数时, 由正交化得到的多项式称为勒让德多项式，并用表示。\n\n由于是次多项式，求阶导数后得\n\n于是得首项的系数\n正交性：\n\n**==递推式==**：\n\n\n在区间内有个不同的实零点。\n\n切比雪夫（Chebyshev）多项式区间为时，由正交化得到的多项式就是切比雪夫多项式，它可表示为:\n\n若令\n则\n\n\n**==递推式==**：\n\n由得\n\n\n由递推关系可得的最高次项系数是。\n\n**==正交性==**\n\n令则，于是\n\n切比雪夫多项式零点：\n","slug":"数值计算公式整理-第七章","date":"2023-12-02T05:49:28.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"5206386e490b6f8de3c4e836eae6cd15","title":"数值计算公式整理-第六章","content":"数值插值方法已知函数在有定义，且已知它在个互异节点\n\n上的函数值\n\n若存在一个次数不超过次的多项式\n\n满足条件\n则称为的次插值多项式。\n点称插值节点,  为被插值函数。称插值区间，点称插值点。\n插值点在插值区间内的叫内插, 否则叫外插。次插值问题的解是存在而且唯一的。\nLagrange插值若次多项式在个节点上满足条件\n\n则称这个次多项式为节点上的次插值基函数。\n线性插值线性插值基函数\n\n满足\n\n插值函数\n\n抛物插值插值基函数\n\n插值函数为：\n\nLagrange插值多项式插值基函数为\n\n插值多项式为：\n\n插值余项与误差估计插值多项式的余项：\n在上具有阶连续倒数，且存在，则插值多项式余项满足：\n\n其中\n\n分段低次插值Runge证明了, 存在一个常数, 使得当时,  ; 而当时,  发散。\n分段线性Lagrange插值\n分段线性插值Lagrange的构造\n构造Lagrange线性插值\n\n得到\n\n\n分段线性插值Lagrange的误差分析\n分段线性插值的余项为：\n且与有关\n\n\n分段二次Lagrange插值\n构造\n任取三个相邻的节点, 以为插值区间构造二次Lagrange插值多项式\n\n\n误差估计\n分段二次插值的余项为\n且与有关\n\n\n均差设在互异节点处的函数值为, 称\n\n为关于节点的一阶均差,两个一阶均差的均差\n\n称为关于节点的二阶均差，一般地，两个阶的均差\n\n称为阶均差（也称差商）。\n\n性质\n\n的阶均差可表示为函数值的线性组合, 即\n\n\n\n\n\n\n均差具有对称性, 即任意调换节点的次序,均差的值不变。\n如\n\n设在  [a, b]  上具有阶导数，且, 则阶均差与导数的关系如下:\n\n\n\n均差的计算方法：\n\nNewton插值法Newton均差插值多项式：\n\n插值余项：\n\n\nNewton插值多项式的系数为均差表中各阶均差的第一个数据\nNewton插值多项式的基函数为\nNewton插值多项式的插值余项为\n\nHermite插值丝滑地插值\n已知节点处函数值及对应节点导数值，求使其函数值及导数值均相等的插值多项式。\n设上，\n\n求使 \n共有个条件, 可唯一确定一次数的多项式。\n形式:\n\n三次Hermite插值\n即有\n\n同理可得\n\n代入插值多项式：\n\n三次Hermite插值余项设在区间上有定义，  在内有 4 阶导数,  是满足插值条件\n\n的三次Hermite插值函数, 则对任意的的插值余项为\n\n分段三次Hermite插值余项设节点, 分段插值函数在两个相邻节点构成的小区间，用三次埃尔米特插值，有\n\n其中\n\n三次样条插值定义：给定区间上的一个划分： , 已知函数在点上的函数值为 如果存在分段函数\n \n满足下述条件：\n\n在每一个子区间上是一个三次多项式\n在每一个内接点上具有二阶的连续导数\n\n则称为 节点上的三次样条函数。\n如果满足插值条件，则为三次样条插值函数。（即全部通过样点的二阶连续可微的分段三次多项式函数）\n设\n由样条函数的定义有（）\n\n\n\n\n共得到个方程。再有边界条件：\n\n自然边界条件（自然样条，最光滑）：\n固定边界：\n周期边界条件：\n\n共个方程，可唯一地确定个未知数。\n","slug":"数值计算公式整理-第六章","date":"2023-12-02T05:49:23.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"f0d67581156d40cbe23d37c58827d570","title":"数值计算公式整理-第五章","content":"特征值与特征向量设是阶方阵，如果数和一维非零向量使关系式成立，则称数为方阵A的特征值，非零向量称为的属于特征值的特征向量。\n如果是矩阵A的属于特征值的特征向量，那么的任何一个非零倍数也是的属于的特征向量。\n一个特征值对应的特征向量不唯一，但一个特征向量只能属于一个特征值。\n上式是以为末知量的一元次方程，称为方阵的特征方程， 是的次多项式，记为称为方阵的特征多项式。\n是以为末知量的一元次方程，称为方阵的特征方程，  是的次多项式，记为称为方阵的特征多项式。\n设阶方阵的特征值为则有\n\n\n\n\n求方阵的特征值和特征向量实际上就是求行列式和方程组的解。\n对于一阶矩阵，如果是A的k重特征根，则对应于的线性无关特征向量的个数不大于，也就是说， 的基础解系所含向量的个数不大于。\n属于不同特征值的特征向量是线性无关的。\n方阵在复数域内总有特征根，但不一定有实特征根。\nGerschgorin圆盘定理设矩阵，记复平面上以为圆心，以为半径（除去对角元素的第行元素之和）的个圆盘为\n\n则：\n\nA的任一特征值至少位于其中一个圆盘\n在个圆盘相互连通（而与其余个圆盘互不连通）的区域内,恰有的个特征值（重特征值按重数记）\n\n适当选取非奇异对角矩阵, 则矩阵与矩阵有相同的特征值，且对角元素相同. 而矩阵对应的个圆盘为\n\n瑞利(Rayleigh)商设A是n阶实对称矩阵，则关于非零向量x的瑞利(Rayleigh)商定义为\n\n其中为两向量的内积。\n设为阶实对称矩阵， 为其全部特征值，则\n\n\n\n\n\n如果是特征向量，则是对应的特征值；如果仅是一近似特征向量，则是对应的特征值的一个近似值。\n幂方法乘幂法乘幂法是用来求矩阵A按模最大的特征值和相应的特征向量的方法。\n迭代方法：\n若将向量的第个分量记为 ，则\n\n迭代步骤\n\n任取一非零向量一般可取\n\n当足够大时，即可得到：\n\n矩阵的谱半径即按模最大特征值，决定了迭代矩阵是否收敛。因此矩阵的按模最大的特征值比其余特征值更重要。\n规范化幂法防止时发生溢出。\n每步先对向量进行“规范化”，即用中绝对值最大的一个分量记作，用遍除的所有分量，得到规范化向量，并令\n原理是，其中\n计算公式：\n\n反幂法求的最大值即求的最小值。\n迭代方法：\n等价于解方程组\n由于需要反复求解方程组, 一般不用高斯消元法, 而用直接分解法解方程组。将分解为 , 记,\n\n幂法的加速和降阶\n原点移位法\n是的特征值, 则是的特征值。\n\n用幂法求的按模最大的特征值$  \\lambda_{1}^{} 则  \\lambda_{1}=\\lambda_{1}^{}+\\lambda_{0} $, 这种方法称为原点移位法。\n实际应用时,  的特征值不知道,  无法确定，当收敛速度慢时，可以适当移动原点.\n\nAitken加速法\n若收敛与, 且即线性收敛，当充分大时, 有\n\n\n对称矩阵的Rayleigh商加速法\n设对称,  , Rayleigh商\n\n所以我们有\n\n计算公式\n\n其中\n\n\n\n我们可以将Aitken和Rayleigh方法结合得到更好的近似值：\n\n","slug":"数值计算公式整理-第五章","date":"2023-12-02T05:49:08.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"f07088020d060ad9a6e044a6f32129d4","title":"数值计算公式整理-第四章","content":"线性方程组的迭代解法基本思想是改写成\n\n这样的形式，简写为。\nJacobi迭代将原方程改写并改为迭代格式：\n\n矩阵表示：\n\n简写成：\n计算公式：\n，表迭代次数\n将的系数矩阵分解为\n\n\n\n其中，有\n迭代矩阵\nGauss-Seidel迭代核心思想是在Jacobi方法上使用最新计算得到的值来进行迭代。\n\n计算公式：\n\n矩阵形式：\n\n简写为\n迭代格式为：\n\n\n迭代矩阵：\n\n迭代法的收敛性令：\n则有：，为非零常数向量\n迭代法收敛的充要条件\n\n可写为：\n迭代格式收敛的充要条件为：\n\n或迭代矩阵的谱半径\n若迭代法收敛，且有\n$\\begin{array}{l}\\left|x^{(k)}-x^{}\\right| \\leq \\frac{|B|}{1-|B|}\\left|x^{(k)}-x^{(k-1)}\\right|\\\\left|x^{(k)}-x^{}\\right| \\leq \\frac{|B|^{k}}{1-|B|}\\left|x^{(1)}-x^{(0)}\\right|\\end{array}$\n对角占优矩阵设，若，则称A为对角占优矩阵，若不等式严格成立（即），则称A为严格对角占优矩阵。\n若中A为严格对角占优矩阵，则Jacobi迭代和Gauss－Seidel迭代均收敛。\n超松弛迭代法（SOR）由GS迭代以及，我们得到\n\n上式称为逐次超松弛法(SOR迭代法)，称为松弛因子。\n矩阵形式：\n其中参数\n\n时即GS迭代。\n收敛条件\n迭代收敛\nSOR迭代收敛的必要条件是\n若对称正定，则当时，SOR收敛。\n若为严格对角占优矩阵，则当时， SOR收敛。\n\n分块迭代设，将方程组中系数矩阵分块\n\n其中，  \n将分解,  \n\nJacobi块迭代\n\n\nGauss-Seidel块迭代\n\n\n\n","slug":"数值计算公式整理-第四章","date":"2023-12-02T03:07:23.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"7a2093395eac9ba6b9063433c4c5aefb","title":"数值计算公式整理-解线性方程组的直接法","content":"解线性方程组的直接法克莱姆法则只适用于低阶方程组，高阶方程组工作量太大，故一般用数值方法求解。数值方法分两类：\n\n直接法\n迭代法\n\nGauss消元法传统线代的方程组解法。\n\n对角线元素称为约化主元素。\n上三角方程组系数计算公式：\n记\n工作量（时间复杂度）：\n解上三角方程组计算公式：\n\n工作量（时间复杂度）：\n总工作量为：\n\n定理: 约化的主元素的充分必要条件是矩阵的各阶顺序主子式不为零。即\n\n如果的顺序主子式，则 Gauss消元法中的约化主元可以表示为\n\n三角分解对线性方程组Ax=b的系数矩阵A施行初等行变换相当于用初等矩阵左乘A。\n\n重复，有：\n\n记则\n这里\n\n通过简单的计算, 可知\n\n通过矩阵的乘法运算, 可得\n\n是单位下三角矩阵（对角线元素均为1），是上三角矩阵的矩阵分解为Doolittle分解。\nGauss列主元消元法每一步选取系数矩阵中（或消元后的低阶矩阵中）绝对值最大的元素作主元，以具较好的数值稳定性。\n三角分解\n行变换矩阵，行运算矩阵\n有\n\n矩阵分解关系为\n全主元素消元法经过行列互换将换到的位置后进行消元。\n注：全主元素消元法有可能改变未知数的顺序。\n矩阵三角分解法Doolittle分解法计算顺序：先列后行\n\n设非奇异, 且为单位下三角阵,  为上三角阵, 即\n\n计算公式：\n\n紧凑格式，以4维矩阵为例：\n\nCrout分解法将矩阵分解为如下形式:\n\n计算顺序：先行后列\n计算公式：\n\n\n\n\n\n\n\n\n\n\n\n\n得出最后方程组的解的公式？\n对称正定矩阵的Cholesky分解法（平方根法）是对称正定矩阵，记\n\n根据对称正定矩阵的性质有\n\n\n称A的分解。\n\n计算公式\n\n对于\n\n方程组的解：\n\n分解（改进的平方根法）\n计算公式\n\n解方程公式：\n\n解方程，得\n\n这里由于，有\n三对角矩阵方程组数值解法\n其中\n且\n\n三角分解\n\n计算公式：\n\n\n求解\n\n计算公式：\n\n\n求解\n\n计算公式：\n\n\n\n追赶法\n化为\n\n计算公式：\n\n\n\n向量范数设向量, 若的某个实值函数 满足条件:\n非负性:  且的充要条件是\n齐次性:  \n三角不等式：对, 有\n则称为上的向量的范数。\n设, 则定义：\n\n向量的 “2-范数”  ：\n向量的 “-范数” ： \n向量的 “-范数” ：\n向量的 “-范数”：\n\n等价性\n对任何向量，有\n\n收敛性\n在中的一个向量序列当且仅当\n\n称为收敛于一个向量\n设为中的一向量序列，  $\\boldsymbol{X}^{} \\in \\boldsymbol{R}^{n} ，记  X^{(k)}=\\left(x_{1}^{(k)}, x_{2}{ }^{(k)}, \\ldots, x_{n}^{(k)}\\right)^{T}, X^{}=\\left(x_{1}^{}, x_{2}^{}, \\ldots, x_{n}^{*}\\right)^{T} $,若\n\n则称收敛于向量$  X^{}  ，记为  \\lim _{k \\rightarrow \\infty} X^{(k)}=X^{} $\n矩阵范数设矩阵, 若的某个非负实值函数满足条件:\n\n非负性:  且的充要条件是\n\n齐次性:  \n\n三角不等式：对, 有\n\n相容性:  \n\n\n则称为上的矩阵的范数。\n向量范数与矩阵范数的关系对于给定的向量范数和矩阵范数, 如果对任一个向量和任一个矩阵都有不等式成立, 则称所给矩阵范数与向量范数是相容的。\n设向量, 矩阵, 且给定一种向量范数, 则定义\n\n为矩阵A的范数，并称为A的算子范数。\n设矩阵, , 则 \n\n列范数： \n\n\n\n行范数：\n\n\n谱半径设阶方阵的特征值为, 则称\n\n为的谱半径。（是的模）\n特征值上界：设, 则\n\n即的谱半径不超过的任何一种算子范数。\n谱范数、F-范数若为对称阵, 则\n\n故又称为谱范数。\n设，则称\n\n为的Frobenius范数，简称-范数。也就是矩阵中所有元素平方之和的开方。\n误差分析若矩阵A或常数项的微小变化引起方程组＝的解的巨大变化，则称此方程组为病态方程组，为病态矩阵（相对方程组而言）；否则称方程组为良态方程组，为良态矩阵。\n设的扰动方程组为，其中叫的扰动矩阵，  和叫和的扰动向量。\n进行扰动分析：\n\n\n\n\n\n\n\n\n条件数非奇异，矩阵的条件数定义为，最常用的是和\n\n条件数小，扰动引起的解的相对误差一定小； 条件数大，扰动引起的解的误差可能很大。\n，条件数是一放大的倍数，且总以1为下界。\n当，即是正交矩阵时，选取时，所以正交矩阵的方程组是良态的。\n\n残差向量 (事后误差估计) 设非奇异,  和分别是的精确解和近似解,  为残差向量, 则:\n$\\frac{\\left|x^{}-x\\right|}{|x |} \\leq \\operatorname{cond}(A) \\cdot \\frac{|r|}{|b|}$\n","slug":"数值计算公式整理-第三章","date":"2023-12-01T10:59:06.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"97103139ce60d6a1a5b401631bf76078","title":"数值计算-非线性方程组求根","content":"数值计算公式整理备考捏（悲\n期末考试题型包括：计算，简答和判断分析改错\n第二章 非线性方程组的求根方法😃二分法\n定理一      \n设函数在区间连续，且,则方程在区间内至少有一个根。\n\n\n假定在内有唯一单实根$  x^{}  ，考察有根区间  [a, b] 取中点  x_{0}=(a+b) / 2 若  f\\left(x_{0}\\right)=0  ，则  x^{}=x_{0}  $，否则，\n\n若，则在右侧，令;\n若，则在左侧，令。\n\n的长度为\n\n性质\n\n\n定理二\n设为方程在内唯一根, 且满是，则由二分法产生的第个区间的中点满足不等式\n\n\n优缺点\n\n优点\n计算过程简单, 收敛性可保证\n对函数的性质要求低, 只要连续即可。\n\n缺点\n收敛速度慢\n不能求复根和重根\n调用一次求解一个间的多个根无法求得。\n\n\n\n\n😄迭代法迭代法是一种逐次逼近的方法，用某个固定公式反复校正根的近似值，使之逐步精确化，最后得到满足精度要求的结果。即由经过一些操作后得到\n不动点迭代\n不动点\n不动点：若$x^满足f(x^)=0，则x^=\\varphi(x^)；反之，若x^=\\varphi (x^)，则f(x^)=0 ，称x^为\\varphi(x)$的一个不动点。\n\n不动点迭代\n\n若对任意 ，由上述迭代得序列，有极限\n\n 则称迭代过程收敛，且$x^{}=\\varphi\\left(x^{}\\right) 为 \\varphi(x) $的不动点。 \n\n不动点的存在性\n设且满足以下两个条件:\n\n对于任意，有;\n\n若在一阶连续, 且存在常数, 使得对任意成立\n\n\n则在上存在唯一的不动点。\n证明：构造并证明存在\n\n全局收敛性\n设且满足以下两个条件：\n\n对于任意，有;\n\n若在一阶连续, 且存在常数, 使得对任意成立\n\n\n即存在唯一不动点$x^，则对任意  x_{0} \\in[a, b] 由  x_{n+1}=\\varphi\\left(x_{n}\\right)  得到的迭代序列  \\left\\{x_{n}\\right\\}  收敛到  \\varphi(x)  的不动点  x^ $, 并有误差估计：\n$\\begin{array}{l}\\left|x_{n}-x^{}\\right| \\leq \\frac{1}{1-L}\\left|x_{n+1}-x_{n}\\right| \\\\left|x_{n}-x \\right| \\leq \\frac{L^{n}}{1-L}\\left|x_{1}-x_{0}\\right|\\end{array}$\n证明：将$x_n,x^分别带入\\varphi (x)，相减后取绝对值，使用积分中值定理转化为\\left|\\varphi^{\\prime}(\\xi) | x_{n-1}-x^{}\\right|$，反复递推即可得到上式\n\n局部收敛性\n设有不动点$ x^{} 若存在  x^{ }  的某邻域  R  :  |x-x^| \\leq \\delta对任意  x_{0} \\in R 迭代过程  x_{k+1}=\\varphi\\left(x_{k}\\right)  产生的序列  \\left\\{\\boldsymbol{x}_{\\boldsymbol{k}}\\right\\} \\in \\boldsymbol{R}  且收敛到  \\boldsymbol{x}^{}  ，则称不动点迭代法  x_{k+1}=\\varphi\\left(x_{k}\\right)  $局部收敛。（实际应用常用）\n设$  x^{}  为 \\varphi(x)  的不动点\\varphi^{\\prime}(x)  在  x^{}  的某邻域连续且  \\left|\\varphi^{\\prime}\\left(x^{*}\\right)\\right|&lt;1 则不动点迭代法  x_{k+1}=\\varphi\\left(x_{k}\\right)  $局部收敛。\n证明：同上，注意不动点的定义$\\varphi(x^)=x^$\n可以用来辅助构造来达到迭代收敛和提高迭代精度和速度（PPT P26）。\n\n收敛阶\n设迭代过程收敛于方程的根$  x^{}  ，若迭代误差  e_{k}=x_{k}-x^{}  当  k \\rightarrow \\infty  $时成立下列渐近关系式：\n\n则称迭代过程是阶收敛的。\n特别地，  \n时称线性收敛; \n时称平方收敛;  \n时称超线性收敛。\n且越大，收敛越快。\n设为的不动点, 若满足：\n\n在附近是次连续可微的（p&gt;1）\n$\\varphi^{\\prime}\\left(x^{}\\right)=\\varphi^{\\prime \\prime}\\left(x^{}\\right)=\\cdots=\\varphi^{(p-1)}\\left(x^{}\\right)=0, \\varphi^{(p)}\\left(x^{}\\right) \\neq 0$\n\n则迭代过程在点邻近是阶收敛的。\n证明：将在处泰勒展开，然后用收敛阶的定义即可\n\n\nAitken迭代加速\nSteffensen迭代加速将Aitken加速技巧与不动点结合可得：\n\n\n也可以写成\n\n也就是套娃\n😊Newton迭代法（切线法）将非线性方程逐步归结为某种线性方程求解。\n由泰勒展式得到：\n\n\n\n\n\n\n\n\n\n\n例: 设, 证明由迭代格式产生的迭代序列, 对任意的, 均收敛于; 且具有 2 阶收敛速度（PPT 42）\n\n收敛性\n假设在$  x^{}  的某邻域内具有连续的二阶导数，且设  f\\left(x^{}\\right)=0, f\\left(x^{}\\right) \\neq 0 则对充分靠近  x^{}  的初始值  x_{0}迭代法产生的序列  \\left\\{x_{n}\\right\\}  至少平方收敛于  x^{*}  $。\n\n缺陷\n\n被零除错误，例如\n程序死循环，例如\n\n\n\n简化Newton法（平行弦法）迭代公式：\n迭代函数：\n若, 即取在附近成立, 则收敛。\n若取，则称简化Newton法。\n弦截法（割线法）用差商近似导数，得到：\n\nNewton下山法为了防止发散我们增加一个条件：\n\n下山因子\n得到：\n\n的选取：对于同一个，从开始，逐次减半：，直到下降条件成立。\n\n\n\n\n\n\n\n\n\n我们会发现至少需\n重根设$  f(x)=\\left(x-x^{}\\right)^{m} g(x), m \\geq 2, m  为整数g\\left(x^{}\\right) \\neq 0 则  x^*  为方程  f(x)=0  的  m  $重根。\n此时有$f\\left(x^{}\\right)=f^{\\prime}\\left(x^{}\\right)=\\ldots \\ldots=f^{(m-1)}\\left(x^{}\\right)=0, f^{(m)}\\left(x^{}\\right) \\neq 0$\n\n方法一\n只要, 仍可用Newton法计算,此时为线性收敛。\n\n方法二\n取\n\n则$  \\varphi’\\left(x^{}\\right)=0  ，用迭代法求  m  $重根，具 2 阶收敛，*但要知道重根个数m。\n\n方法三（修正的牛顿迭代法）\n令\n\n则\n$\\mu(x)=\\frac{\\left(x-x^{}\\right) g(x)}{m g(x)+\\left(x-x^{}\\right) g^{\\prime}(x)}$\n故是的单根，对用Newton法，可得\n\n该方法二阶收敛。\n\n\n","slug":"数值计算公式整理-第二章","date":"2023-11-30T08:21:49.000Z","categories_index":"","tags_index":"数值计算","author_index":"C4IN"},{"id":"254a310a18e37ba37214c374ad798d9c","title":"总线与接口","content":"总线一组为多个部件分时共享的信息传送线路。\n特点：分时共享\n特定时刻只允许一个部件送出数据到总线上\n\n分类按传输信号的类型\n\n数据总线：传输数据信息，决定总线宽度\n地址总线：传输地址信息，决定寻址能力\n控制总线：传输控制信息和状态信息\n\n按数据传送格式划分\n\n并行总线：多条数据线，并行（同时）传送各位信息\n串行总线：一条数据线，分时逐位传送各位信息\n\n按时序控制方式划分\n\n同步总线：由统一时序信号控制总线传送操作在固定时钟周期内（一个或多个）完成数据传送，由同步脉冲定时打入。\n\n\n异步总线：无固定时钟周期划分，总线周期时间由传送实际需要决定，以异步应答方式控制传送。\n\n\n扩展同步总线：\n以时钟周期为基础，允许总线周期（完成一次主存或IO端口访问的时间）中的时钟数可变（既有统一时序同步时钟，又有应答信号）。\n\n\n\n几个周期的概念：\n\n时钟周期：CPU一步操作（一次内部数据通路传送）时间\n总线周期：经过总线的一次数据传送（访存）时间，通常包含若干时钟周期。（模型机的一个总线周期只包含一个时钟周期）\n工作周期：指令周期中的一个操作阶段，可包含多个总线周期\n\n按功能划分\n\nCPU内总线：ALU总线，可以同步、并步传送信息\n部件内总线：局部总线、片级总线\n系统总线：板级总线，可以同步、异步、扩展同步、并行\n外总线：通信总线，可以异步、并行、串行传送信息\n\n​    \n按方向划分\n\n单向总线\n双向总线\n\n总线标准对总线信号组成、信号引脚含义、信号电平等作统一规定。\n针对系统总线和外总线，对总线四大特性进行统一的规范，如下:\n\n物理特性：如接插头大小/引脚数量/相对位置等\n功能特性:描述每一信号线的功能\n电气特性：如信号传送方向、信号驱动能力、抗干扰能力、信号的正负逻辑等\n时间特性：如信号有效的时机、持续时间等\n\n技术指标\n\n总线宽度：总线能同时传输的二进制位数\n总线频率：总线在单位时间(秒)传输数据的次数\n总线数据传输率：\n单位时间内总线输出的数据总量（B/s）\n总线数据传输率=(总线宽度/8)x总线频率，这里除以8是计算总线能传输的字节数\n\n\n\n常见总线标准\n\n\n\n\n总线\n开发者\n宽度\n频率\n传输率\n\n\n\n\nISA\nIBM   1984\n8/16\n8.33M\n8.33/16.66MB/s\n\n\nEISA\nCompaq等1988\n32\n8.33M\n33.3MB/s\n\n\nAGP\nIntel，1996\n32\n66.6M×1/2/4/8\n266.4MB/s…\n\n\nPCI\nIntel，1991\n32/64\n33/66/133M\n132MB/s…\n\n\nUSB\nIntel，IBM等，1994\n1\n1.5/12/480/4000M\n0.2/1.5/60/500MB/s\n\n\n\n\n\n接口输入输出设备也称外部设备，简称外设。\n外设与系统总线之间的逻辑电路称为输入输出接口，简称I/O接口。\n需要I/O接口的原因：\n\n工作速度，不同速度外设与CPU连接\n数据格式的转换，外设与CPU的数据格式可能不同\n一次数据传送量的控制\n其它因素(如电平转换—)\n\n\n主要功能\n寻址\n接受CPU送来的地址码\n选择接口中的寄存器供CPU访问\n\n\n数据缓冲\n实现主机与外设的速度匹配\n缓冲深度与传送的数据量有关\n\n\n预处理\n串-并格式转换（串口）\n数据通路宽度转换（并口）\n电平转换\n\n\n控制功能\n传送控制命令与状态信息，实现I/O传送控制\n\n\n\n\n接口编址\n统一编址：为每个端口分配总线地址通用的传送类指令\n\n单独编址：编址到设备端口，有专门的I/O指令，例如：\nIN            AL, 61H\nOUT        62H, AL\n\n\n接口分类按数据传送格式划分\n\n并行接口：接口与系统总线、接口与外设均按并行方式传送数据；数据各位同时传送。适合设备本身并行工作，距主机较近的场合。\n串行接口：接口与系统总线并行传送，接口与外设串行传送；数据逐位分时传送。适用于设备本身串行工作，或距主机较远，或需减少传送线的情况。\n\n按时序控制方式划分\n\n同步接口：连接同步总线，接口与系统总线的信息传送由统一时序信号控制。\n\n异步接口：连接异步总线，接口与系统总线的信息传送采用异步应答方式。\n\n\n按主机与外设的信息交换（I/O传送）控制方式\n\n直接程序传送接口：\n依靠CPU直接执行相关的I/O程序或者通过硬件按指定优先级查询各设备是否要进行I/O，来实现数据的输入和输出控制。\n\n中断接口：\n设备提出中断请求，主机响应后与设备交换信息，接口中包含中断控制逻辑。\n\nDMA接口：\n支持高速外设与主存之间进行DMA方式交换数据。\n\n\n信息传送控制方式\n主机与外设的信息交换过程\n输入：\n\nCPU送地址到地址总线，选择输入设备\nCPU等候输入设备的数据成为有效\nCPU从数据总线读取数据\n\n输出：\n\nCPU送地址到地址总线，选择输出设备\nCPU将数据送到数据总线\n输出设备获知数据有效，取走数据\n\n\n信息传送控制方式\n\n直接程序传送方式\nCPU通过在现行程序中直接执行I/O指令实现数据传送\n\n程序中断方式\n启动设备后，CPU执行自身程序，设备准备好后发中断请求，CPU再响应\n\n直接存储器访问（DMA）方式\n设备准备好后发DMA请求，DMA控制器控制总线权，控制外设与主存之间直接数据传送\n\n\n\n\n程序直接传送及接口执行I/O操作时，CPU直接访问I/O接口，输入或输出数据。\n\n执行/O指令之前,先查询设备状态，等待外设准备好、或完成一次操作，CPU再执行I/O指令与外设交换信息。\n\n设备状态\n\n\n查询方式的程序流程\n\n\n\n优缺点：\n\n硬件开销小\n并行程度低，实时性差\n\n应用场合\n\n对CPU效率要求不高的场合\n或诊断、调试过程\n\n模型机系统总线组成总线信号组成模型机系统总线共78条：\n\n电源线与地线：16条\n\n电源线10条： +5V 2条（主电源线），-5V 2条，+12V 2条， -12V 2条\n地线4条\n附加地线2条\n\n\n地址线：16条\n寻址空间需要16条地址线，包括I/O端口地址\n\n数据线：16条\n\n控制信号线：30条\n七组：\n\n复位信号线（RESET）：1条\n同步定时信号线：6条\n异步应答信号线：3条\n总线控制权信号线：3条（BREQ，BACK，BUSY）\n中断请求与响应信号线：10条（IREQ0—IREQ7，INT，INTA）\n优先权判定线\n\n数据传送控制信号：5条（MEMR，MEMW，IOR，IOW，BHEN）\n\n\n总线操作与时序\n同步控制的总线操作\n主要特征：以时钟周期为划分时间段的基准。\n总线周期为时钟周期的整数倍。\n\n异步控制方式的总线特征\n主要特征：没有统一的时钟周期划分，而采取应答方式实现总线的传送操作，所需时间视需要而定。\n根据主、从设备的请求信号、回答信号及设备自身定时的关系。\n异步应答有不互锁、半互锁、全互锁三类：\n\n不互锁：请求信号引发回答信号，两个信号的结束是由设备自身定时决定的。\n\n半互锁：请求信号引发回答信号，设备1的请求信号的结束是设备2决定的。\n\n全互锁：请求信号引发回答信号，设备1的请求信号的结束是由设备2决定的，设备2的回答结束信号是根据设备1决定的。\n\n\n\n扩展同步控制方式\n以时钟周期为时序基础，允许总线周期中的时钟数可变。\n\n\n\n\n\n直接程序传送方式使用I/O指令编程实现信息传送\n\n外设状态\n在接口中设置状态字表示这些状态。\n\n空闲：调用前设备不工作\n\n结束：调用后设备完成工作\n\n\n程序查询接口模型\n\n\n查询流程\n\n输出指令设置启动信号\n\n输入指令读取状态信息并判断\n\nI/O指令读/写数据\n\n输入接口示例：\n\n查询输入程序：\nWAIT: \n    IN AL, STATUS\n    TEST AL, 80H\n    JZ WAIT            ; READY=0, KEEP WAITING\n    IN AL, DATA\n输出接口示例：\n\n查询输出程序：\nWAIT:\n    IN AL, STATUS\n    TEST AL, 08H\n    JNZ WAIT            ; BUSY, NOT READY YET\n    MOV AL, BUFF        ; BUFF SEND 1 TO AL, 主存缓冲器BUFF取1数据送AL \n    OUT DATA, AL        ; DATA数据端口号\n\n\n\n优缺点\n硬件开销小；实时处理能力差，并行程度低\n\n应用场合\n对CPU效率要求不高的场合，或诊断、调试过程\n\n\n\n\n中断方式及接口中断基本概念中断指的是CPU暂时中止现行程序的执行，转去执行为某个随机事态服务的中断处理程序。处理完毕后自动恢复原程序的执行。\n实质程序切换的方法：\n\n保存断点，保护现场（中断处理前）\n恢复现场，返回断点（中断处理后）\n\n程序切换的时间：\n\n一条指令结束时切换\n保证程序的完整性\n\n特点随机性：\n\n随机发生的事态（按键，故障等）\n有意调用，随机请求与处理的事态（调用打印机）\n随机插入的事态（软中断指令插入程序任何位置）\n注意中断与转子的区别\n\n\n\n分类\n硬件中断与软中断\n硬件中断：由硬件请求信号引发中断\n软中断：由软中断指令引发中断\n\n\n内中断与外中断\n内中断：中断源来自主机内部\n外中断：中断源来自主机外部\n\n\n可屏蔽中断与非屏蔽中断\n可屏蔽中断：可通过屏蔽字屏蔽该类请求；关中断时不响应该类请求。\n非屏蔽中断：该类请求与屏蔽字无关；请求的响应与开/关中断无关。\n\n\n向量中断与非向量中断\n向量中断：由硬件提供服务程序入口地址。\n非向量中断：由软件提供服务程序入口地址\n\n\n\n典型应用\n管理中低速I/O操作\n\n处理故障\n\n实时处理\n某事件出现的实际时间内及时处理，不是批量处理；\n利用时钟中断定时采集参数，检测，调节。\n\n人机对话\n\n多机通信\n\n\n终端系统的硬、软件组织硬件：I/O接口\n软件：中断请求源，中断服务程序，中断向量表\n\n中断请求源\n\n外部硬件中断源：8种，IREQ0—IREQ7\n内部硬件中断源：掉电、溢出、校验错中断等\n软中断：模型机软中断为INT11—INTn\n\n\n中断服务程序\n在主存种的空间不必连续\n\n中断向量表\n\n存放在模型机中的空间不必连续\n向量地址=中断号+2\n\n\n\n","slug":"总线与接口","date":"2023-11-15T11:48:05.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"ec97abd0452c3383ae6efc5f2ebc40f7","title":"buuoj-reverse WP-1","content":"Buuoj-Reverse WP-1来学学逆向工程，顺便学学计组\nreverse1在strings窗口发现flag，但直接输入发现flag错误。\n\n进行反汇编，发现\n\n该for循环将所有的o替换成0，所以最后的flag是flag&#123;hell0_w0rld&#125;。\nreverse2打开strings窗口，发现flag的一部分\n\n类似reverse1，该题将 flag 中的 i 和 r 都替换成 1。\n\n内涵的软件打开strings窗口即可发现flag。\n\n新年快乐\nexe 被 upx 压缩，使用命令 upx.exe -d xnkl.exe -o xnkl_unpack.exe 解压。\nXOR反汇编，发现flag应该和global有关\n\n找到对应的数据\n\n查看反汇编的代码，发现对flag进行了异或操作，编写脚本：\n&quot;&quot;&quot;\n__global\n__cstring:0000000100000F6E aFKWOXZUPFVMDGH db &#39;f&#39;,0Ah              ; DATA XREF: __data:_global↓o\n__cstring:0000000100000F6E                 db &#39;k&#39;,0Ch,&#39;w&amp;O.@&#39;,11h,&#39;x&#39;,0Dh,&#39;Z;U&#39;,11h,&#39;p&#39;,19h,&#39;F&#39;,1Fh,&#39;v&quot;M#D&#39;,0Eh,&#39;g&#39;\n__cstring:0000000100000F6E                 db 6,&#39;h&#39;,0Fh,&#39;G2O&#39;,0\n&quot;&quot;&quot;\n\nstr_xor = [&#39;f&#39;, 0x0A, &#39;k&#39;, 0x0C, &#39;w&#39;, &#39;&amp;&#39;, &#39;O&#39;, &#39;.&#39;, &#39;@&#39;, 0x11, &#39;x&#39;, 0x0D, &#39;Z&#39;, &#39;;&#39;, &#39;U&#39;, 0x11, &#39;p&#39;, 0x19, &#39;F&#39;, 0x1F,\n           &#39;v&#39;, &#39;&quot;&#39;, &#39;M&#39;, &#39;#&#39;, &#39;D&#39;, 0x0E, &#39;g&#39;, 6, &#39;h&#39;, 0x0F, &#39;G&#39;, &#39;2&#39;, &#39;O&#39;, 0]\n\nprint(len(str_xor))\n\nfor i in range(0, len(str_xor)):\n    if isinstance(str_xor[i], int):\n        str_xor[i] = chr(str_xor[i])\n\nfor i in range(0, len(str_xor) - 1):\n    print(str_xor[i], end=&quot; &quot;)\n\nprocess = &#39;&#39;.join(str_xor)\n\nprint(process)\n\nflag = &#39;&#39;\nfor i in range(0, len(str_xor)-1):\n    flag += chr(ord(str_xor[i]) ^ ord(str_xor[i - 1]))\n\nprint(flag)\n\nreverse3首先先找到flag\n\n进行反编译：\n\n发现重要函数sub_4110BE，而该函数返回的是sub_411AB0：\nvoid *__cdecl sub_411AB0(char *a1, unsigned int a2, int *a3)\n&#123;\n  int v4; // [esp+D4h] [ebp-38h]\n  int v5; // [esp+D4h] [ebp-38h]\n  int v6; // [esp+D4h] [ebp-38h]\n  int v7; // [esp+D4h] [ebp-38h]\n  int i; // [esp+E0h] [ebp-2Ch]\n  unsigned int v9; // [esp+ECh] [ebp-20h]\n  int v10; // [esp+ECh] [ebp-20h]\n  int v11; // [esp+ECh] [ebp-20h]\n  void *v12; // [esp+F8h] [ebp-14h]\n  char *v13; // [esp+104h] [ebp-8h]\n\n  if ( !a1 || !a2 )\n    return 0;\n  v9 = a2 / 3;\n  if ( (int)(a2 / 3) % 3 )\n    ++v9;\n  v10 = 4 * v9;\n  *a3 = v10;\n  v12 = malloc(v10 + 1);\n  if ( !v12 )\n    return 0;\n  j_memset(v12, 0, v10 + 1);\n  v13 = a1;\n  v11 = a2;\n  v4 = 0;\n  while ( v11 &gt; 0 )\n  &#123;\n    byte_41A144[2] = 0;\n    byte_41A144[1] = 0;\n    byte_41A144[0] = 0;\n    for ( i = 0; i &lt; 3 &amp;&amp; v11 &gt;= 1; ++i )\n    &#123;\n      byte_41A144[i] = *v13;\n      --v11;\n      ++v13;\n    &#125;\n    if ( !i )\n      break;\n    switch ( i )\n    &#123;\n      case 1:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v5 = v4 + 1;\n        *((_BYTE *)v12 + v5) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];\n        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];\n        v4 = v5 + 1;\n        break;\n      case 2:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v6 = v4 + 1;\n        *((_BYTE *)v12 + v6) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | (4 * (byte_41A144[1] &amp; 0xF))];\n        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[64];\n        v4 = v6 + 1;\n        break;\n      case 3:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v7 = v4 + 1;\n        *((_BYTE *)v12 + v7) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | (4 * (byte_41A144[1] &amp; 0xF))];\n        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[byte_41A144[2] &amp; 0x3F];\n        v4 = v7 + 1;\n        break;\n    &#125;\n  &#125;\n  *((_BYTE *)v12 + v4) = 0;\n  return v12;\n&#125;\n查看aAbcdefghijklmn：\n\n发现是常用的base64编码表，编写脚本：\nimport base64\n\n_str = &#39;e3nifIH9b_C@n@dH&#39;\n\nrawDest = &quot;&quot;\nfor i in range(len(_str)):\n    rawDest += chr(ord(_str[i]) - i)\nprint(rawDest)\n\nflag = base64.b64decode(rawDest)\nprint(flag)\n得到flag：\n\nSimpleRev将文件拖进IDA，查看关键函数及数据\nDecry:\nunsigned __int64 Decry()\n&#123;\n  char v1; // [rsp+Fh] [rbp-51h]\n  int v2; // [rsp+10h] [rbp-50h]\n  int v3; // [rsp+14h] [rbp-4Ch]\n  int i; // [rsp+18h] [rbp-48h]\n  int v5; // [rsp+1Ch] [rbp-44h]\n  char src[8]; // [rsp+20h] [rbp-40h] BYREF\n  __int64 v7; // [rsp+28h] [rbp-38h]\n  int v8; // [rsp+30h] [rbp-30h]\n  __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF\n  int v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  *(_QWORD *)src = 0x534C43444ELL;\n  v7 = 0LL;\n  v8 = 0;\n  v9[0] = 0x776F646168LL;\n  v9[1] = 0LL;\n  v10 = 0;\n  text = (char *)join(key3, v9);\n  strcpy(key, key1);\n  strcat(key, src);\n  v2 = 0;\n  v3 = 0;\n  getchar();\n  v5 = strlen(key);\n  for ( i = 0; i &lt; v5; ++i )\n  &#123;\n    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )\n      key[i] = key[v3 % v5] + 32;\n    ++v3;\n  &#125;\n  printf(&quot;Please input your flag:&quot;);\n  while ( 1 )\n  &#123;\n    v1 = getchar();\n    if ( v1 == 10 )\n      break;\n    if ( v1 == 32 )\n    &#123;\n      ++v2;\n    &#125;\n    else\n    &#123;\n      if ( v1 &lt;= 96 || v1 &gt; 122 )\n      &#123;\n        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )\n        &#123;\n          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n          ++v3;\n        &#125;\n      &#125;\n      else\n      &#123;\n        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n        ++v3;\n      &#125;\n      if ( !(v3 % v5) )\n        putchar(32);\n      ++v2;\n    &#125;\n  &#125;\n  if ( !strcmp(text, str2) )\n    puts(&quot;Congratulation!\\n&quot;);\n  else\n    puts(&quot;Try again!\\n&quot;);\n  return __readfsqword(0x28u) ^ v11;\n&#125;\n数据：\nsrc: NDCLS\nv9: hadow\nkey1: ADSFK\nkey3: kills\n注意v9， key1的数据类型是__int64，是以大端存储的，我们要将其倒过来读取，所以strcpy(key, key1); strcat(key, src);将字符串拼接到key中，得到ADSFKNDCLS，text为killshadow。\n接下来我们分析代码：\n大写转小写：\n  for ( i = 0; i &lt; v5; ++i )\n  &#123;\n    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )\n      key[i] = key[v3 % v5] + 32;\n    ++v3;\n  &#125;\n输入处理：\nprintf(&quot;Please input your flag:&quot;);\n  while ( 1 )\n  &#123;\n    v1 = getchar();\n    if ( v1 == 10 )            // 换行停止\n      break;\n    if ( v1 == 32 )            // 过滤空格\n    &#123;\n      ++v2;\n    &#125;\n    else\n    &#123;\n      if ( v1 &lt;= 96 || v1 &gt; 122 )\n      &#123;\n        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )        // 处理大写字母\n        &#123;\n          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n          ++v3;\n        &#125;\n      &#125;\n      else                                // 处理小写字母\n      &#123;\n        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n        ++v3;\n      &#125;\n      if ( !(v3 % v5) )\n        putchar(32);\n      ++v2;\n    &#125;\n  &#125;\n  if ( !strcmp(text, str2) )\n    puts(&quot;Congratulation!\\n&quot;);\n  else\n    puts(&quot;Try again!\\n&quot;);\n  return __readfsqword(0x28u) ^ v11;\n&#125;\n我们需要将处理后的输入与text比较。采用爆破方式编写解密脚本：\nimport string\n\nkey = &quot;ADSFKNDCLS&quot;.lower()\nkey = list(map(ord, key))  # 转化为ASCII表示\ntext = &quot;killshadow&quot;\ntext = list(map(ord, text))  \n\nflag = &#39;&#39;\ncharSet = string.ascii_uppercase + string.ascii_lowercase  \ncharSet = list(map(ord, charSet))  \nfor i in range(len(key)):\n    for char in charSet:\n        if text[i] == (char - 39 - key[i] + ord(&#39;a&#39;)) % 26 + ord(&#39;a&#39;):\n            flag += chr(char)\n            break\nprint(flag)\n得到：KLDQCUDFZO\nJavaRev拖进jadx中，在defpackage/Reverse找到对应源码：\npackage defpackage;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/* loaded from: Reverse.class */\npublic class Reverse &#123;\n    public static void main(String[] args) &#123;\n        Scanner s = new Scanner(System.in);\n        System.out.println(&quot;Please input the flag ：&quot;);\n        String str = s.next();\n        System.out.println(&quot;Your input is ：&quot;);\n        System.out.println(str);\n        char[] stringArr = str.toCharArray();\n        Encrypt(stringArr);\n    &#125;\n\n    public static void Encrypt(char[] arr) &#123;\n        ArrayList&lt;Integer&gt; Resultlist = new ArrayList&lt;&gt;();\n        for (char c : arr) &#123;\n            int result = (c + &#39;@&#39;) ^ 32;\n            Resultlist.add(Integer.valueOf(result));\n        &#125;\n        int[] KEY = &#123;180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65&#125;;\n        ArrayList&lt;Integer&gt; KEYList = new ArrayList&lt;&gt;();\n        for (int i : KEY) &#123;\n            KEYList.add(Integer.valueOf(i));\n        &#125;\n        System.out.println(&quot;Result:&quot;);\n        if (Resultlist.equals(KEYList)) &#123;\n            System.out.println(&quot;Congratulations！&quot;);\n        &#125; else &#123;\n            System.err.println(&quot;Error！&quot;);\n        &#125;\n    &#125;\n&#125;\n我们对Encrypt函数进行分析：\n对于数组 arr 中的每个字符 c，首先将字符 c 转换为其对应的ASCII码值，再加上 @ 字符的ASCII码值（64）并对结果与32进行异或。将处理后的结果转换为整数，并将其加到 Resultlist 中，然后与KEY进行比较。\n编写解密脚本：\nKey = [180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65]\nflag = &quot;&quot;\n\nfor i in range(0, len(Key)):\n\n    flag += chr((Key[i] ^ 32) - 64)\n\nprint(flag)\n\n\n\n\n\n\n\n\n\n注意，异或运算的优先级低于加减\n[GXYCTF2019]luck_guy将文件拖进IDA中，打开字符串窗口，发现GXY&#123;do_not_。\n找到关键代码get_flag()，分析：\nunsigned __int64 get_flag()\n&#123;\n  unsigned int v0; // eax\n  int i; // [rsp+4h] [rbp-3Ch]\n  int j; // [rsp+8h] [rbp-38h]\n  __int64 s; // [rsp+10h] [rbp-30h] BYREF\n  char v5; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  v0 = time(0LL);\n  srand(v0);\n  for ( i = 0; i &lt;= 4; ++i )\n  &#123;\n    switch ( rand() % 200 )\n    &#123;\n      case 1:\n        puts(&quot;OK, it&#39;s flag:&quot;);\n        memset(&amp;s, 0, 0x28uLL);\n        strcat((char *)&amp;s, f1);\n        strcat((char *)&amp;s, &amp;f2);\n        printf(&quot;%s&quot;, (const char *)&amp;s);\n        break;\n      case 2:\n        printf(&quot;Solar not like you&quot;);\n        break;\n      case 3:\n        printf(&quot;Solar want a girlfriend&quot;);\n        break;\n      case 4:\n        s = 0x7F666F6067756369LL;\n        v5 = 0;\n        strcat(&amp;f2, (const char *)&amp;s);\n        break;\n      case 5:\n        for ( j = 0; j &lt;= 7; ++j )\n        &#123;\n          if ( j % 2 == 1 )\n            *(&amp;f2 + j) -= 2;\n          else\n            --*(&amp;f2 + j);\n        &#125;\n        break;\n      default:\n        puts(&quot;emmm,you can&#39;t find flag 23333&quot;);\n        break;\n    &#125;\n  &#125;\n  return __readfsqword(0x28u) ^ v6;\n&#125;\n首先我们先排除没用的2,3，然后对剩下的进行排序：\n\ncase 4初始化s, f2，放在第一个执行\ncase 5对f2进行一系列操作，放在第二个执行\ncase 1输出flag，放在最后执行\n\n我们得到正确的执行顺序应该为case4-&gt;case5-&gt;case1。\n方法一：直接编写python脚本\n按上面那个顺序写就可以了。\nflag = &quot;GXY&#123;do_not_&quot;\nf2 = [0x69, 0x63, 0x75, 0x67, 0x60, 0x6f, 0x66, 0x7f]  # 注意大端序\nfor i in range(0, len(f2)):\n    if i % 2 == 1:\n        f2[i] -= 2\n        flag += chr(f2[i])\n    else:\n        f2[i] -= 1\n        flag += chr(f2[i])\n\nprint(flag)\n方法二：patch\n\n\n\n\n\n\n\n\n\n牛魔酬宾什么鬼东西，给骗了    我有jumpout恐惧症\n\n我们先进入case 4\n\n我们删除case 4中的jmp指令，选中后右键菜单选择nop\n\n同样把case 5的跳转改为case 1的地址\n\n我们再回到case 1，将case 1运行结束后跳转至整个程序的结束。\n\n\n我们只要在反汇编中找到对应的jmp，然后修改跳转的地址就行了，修改后反编译的结果如下：\nint get_flag()\n&#123;\n  unsigned int v0; // eax\n  int i; // [rsp+8h] [rbp-38h]\n  __int64 s; // [rsp+10h] [rbp-30h] BYREF\n  char v6; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v7; // [rsp+38h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  v0 = time(0LL);\n  srand(v0);\n  s = 0x7F666F6067756369LL;\n  v6 = 0;\n  strcat(&amp;f2, (const char *)&amp;s);\n  __asm &#123; insb &#125;\n  for ( i = 0; i &lt;= 7; ++i )\n  &#123;\n    if ( i % 2 == 1 )\n      *(&amp;f2 + i) -= 2;\n    else\n      --*(&amp;f2 + i);\n  &#125;\n  puts(&quot;OK, it&#39;s flag:&quot;);\n  memset(&amp;s, 0, 0x28uLL);\n  strcat((char *)&amp;s, f1);\n  strcat((char *)&amp;s, &amp;f2);\n  return printf(&quot;%s&quot;, (const char *)&amp;s);\n&#125;\n[BJDCTF2020]JustRE我们将文件拖入RH中，查看“测试你的手速”弹窗代码：\n\n发现对应的机器码是129。\n我们再将文件拖入IDA中，查看WinMain：\n\nWinMain里调用sub_4010C0注册RE2类：\n\n查看相应的函数，我们发现“测试你的手速”框口对应的函数是sub_4011C0，再通过之前得到的机器码找到对应的操作函数DialogFunc：\n\n129的十六进制0x81：\n\n查看DialogFunc:\n\n得到flag，注意这里的格式化。\n刮开有奖拖进RH，删除“刮开有奖字样”，修改参数：\n\n处理后的效果是这样的：\n\n把程序拖进IDA，查看DiaglogFunc：\nINT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)\n&#123;\n  const char *v4; // esi\n  const char *v5; // edi\n  int v7[2]; // [esp+8h] [ebp-20030h] BYREF\n  int v8; // [esp+10h] [ebp-20028h]\n  int v9; // [esp+14h] [ebp-20024h]\n  int v10; // [esp+18h] [ebp-20020h]\n  int v11; // [esp+1Ch] [ebp-2001Ch]\n  int v12; // [esp+20h] [ebp-20018h]\n  int v13; // [esp+24h] [ebp-20014h]\n  int v14; // [esp+28h] [ebp-20010h]\n  int v15; // [esp+2Ch] [ebp-2000Ch]\n  int v16; // [esp+30h] [ebp-20008h]\n  CHAR String[65536]; // [esp+34h] [ebp-20004h] BYREF\n  char v18[65536]; // [esp+10034h] [ebp-10004h] BYREF\n\n  if ( a2 == 272 )\n    return 1;\n  if ( a2 != 273 )\n    return 0;\n  if ( (_WORD)a3 == 1001 )\n  &#123;\n    memset(String, 0, 0xFFFFu);\n    GetDlgItemTextA(hDlg, 1000, String, 0xFFFF);\n    if ( strlen(String) == 8 )\n    &#123;\n      v7[0] = 90;\n      v7[1] = 74;\n      v8 = 83;\n      v9 = 69;\n      v10 = 67;\n      v11 = 97;\n      v12 = 78;\n      v13 = 72;\n      v14 = 51;\n      v15 = 110;\n      v16 = 103;\n      sub_4010F0(v7, 0, 10);\n      memset(v18, 0, 0xFFFFu);\n      v18[0] = String[5];\n      v18[2] = String[7];\n      v18[1] = String[6];\n      v4 = (const char *)sub_401000(v18, strlen(v18));\n      memset(v18, 0, 0xFFFFu);\n      v18[1] = String[3];\n      v18[0] = String[2];\n      v18[2] = String[4];\n      v5 = (const char *)sub_401000(v18, strlen(v18));\n      if ( String[0] == v7[0] + 34\n        &amp;&amp; String[1] == v10\n        &amp;&amp; 4 * String[2] - 141 == 3 * v8\n        &amp;&amp; String[3] / 4 == 2 * (v13 / 9)\n        &amp;&amp; !strcmp(v4, &quot;ak1w&quot;)\n        &amp;&amp; !strcmp(v5, &quot;V1Ax&quot;) )\n      &#123;\n        MessageBoxA(hDlg, &quot;U g3t 1T!&quot;, &quot;@_@&quot;, 0);\n      &#125;\n    &#125;\n    return 0;\n  &#125;\n  if ( (_WORD)a3 != 1 &amp;&amp; (_WORD)a3 != 2 )\n    return 0;\n  EndDialog(hDlg, (unsigned __int16)a3);\n  return 1;\n&#125;\n以及函数sub_4010F0：\nint __cdecl sub_4010F0(int a1, int a2, int a3)\n&#123;\n  int result; // eax\n  int i; // esi\n  int v5; // ecx\n  int v6; // edx\n\n  result = a3;\n  for ( i = a2; i &lt;= a3; a2 = i )\n  &#123;\n    v5 = 4 * i;\n    v6 = *(_DWORD *)(4 * i + a1);\n    if ( a2 &lt; result &amp;&amp; i &lt; result )\n    &#123;\n      do\n      &#123;\n        if ( v6 &gt; *(_DWORD *)(a1 + 4 * result) )\n        &#123;\n          if ( i &gt;= result )\n            break;\n          ++i;\n          *(_DWORD *)(v5 + a1) = *(_DWORD *)(a1 + 4 * result);\n          if ( i &gt;= result )\n            break;\n          while ( *(_DWORD *)(a1 + 4 * i) &lt;= v6 )\n          &#123;\n            if ( ++i &gt;= result )\n              goto LABEL_13;\n          &#125;\n          if ( i &gt;= result )\n            break;\n          v5 = 4 * i;\n          *(_DWORD *)(a1 + 4 * result) = *(_DWORD *)(4 * i + a1);\n        &#125;\n        --result;\n      &#125;\n      while ( i &lt; result );\n    &#125;\nLABEL_13:\n    *(_DWORD *)(a1 + 4 * result) = v6;\n    sub_4010F0(a1, a2, i - 1);\n    result = a3;\n    ++i;\n  &#125;\n  return result;\n&#125;\n我们先来看那一堆的数字：\nv7[0] = 90 对应字符 &quot;Z&quot;\nv7[1] = 74 对应字符 &quot;J&quot;\nv8 = 83 对应字符 &quot;S&quot;\nv9 = 69 对应字符 &quot;E&quot;\nv10 = 67 对应字符 &quot;C&quot;\nv11 = 97 对应字符 &quot;a&quot;\nv12 = 78 对应字符 &quot;N&quot;\nv13 = 72 对应字符 &quot;H&quot;\nv14 = 51 对应字符 &quot;3&quot;\nv15 = 110 对应字符 &quot;n&quot;\nv16 = 103 对应字符 &quot;g&quot;\nsub_4010F0对这十个字符进行处理，C语言代码为：\n#include&lt;stdio.h&gt;\n\nint __cdecl sub_4010F0(char* a1, int a2, int a3)\n&#123;\n  int result; // eax\n  int i; // esi\n  int v5; // ecx\n  int v6; // edx\n\n  result = a3;\n  for ( i = a2; i &lt;= a3; a2 = i )\n  &#123;\n    v5 = i;             // 源代码是v5 = 4 * i;  其实这个4指的是4个内存单位，也就是int占4个字节，如果是char的话就不需要了\n    v6 = i[a1];\n    if ( a2 &lt; result &amp;&amp; i &lt; result )\n    &#123;\n      do\n      &#123;\n        if ( v6 &gt; a1[result] )\n        &#123;\n          if ( i &gt;= result )\n            break;\n          ++i;\n          v5[a1] = a1[result];\n          if ( i &gt;= result )\n            break;\n          while ( a1[i] &lt;= v6 )\n          &#123;\n            if ( ++i &gt;= result )\n              goto LABEL_13;\n          &#125;\n          if ( i &gt;= result )\n            break;\n          v5 = i;\n          a1[result] = i[a1];\n        &#125;\n        --result;\n      &#125;\n      while ( i &lt; result );\n    &#125;\nLABEL_13:\n    a1[result] = v6;\n    sub_4010F0(a1, a2, i - 1);\n    result = a3;\n    ++i;\n  &#125;\n  return result;\n&#125;\n\n\nint main() &#123;\n\n    char *str = &quot;ZJSECaNH3ng&quot;;\n    sub_4010F0(str, 0, 10);\n    printf(&quot;%s&quot;, str);\n\n    return 0;\n&#125;\n运行得到3CEHJNSZagn。\n然后我们接下来看sub_4010F0\n_BYTE *__cdecl sub_401000(int a1, int a2)\n&#123;\n  int v2; // eax\n  int v3; // esi\n  size_t v4; // ebx\n  _BYTE *v5; // eax\n  _BYTE *v6; // edi\n  int v7; // eax\n  _BYTE *v8; // ebx\n  int v9; // edi\n  int v10; // edx\n  int v11; // edi\n  int v12; // eax\n  int i; // esi\n  _BYTE *result; // eax\n  _BYTE *v15; // [esp+Ch] [ebp-10h]\n  _BYTE *v16; // [esp+10h] [ebp-Ch]\n  int v17; // [esp+14h] [ebp-8h]\n  int v18; // [esp+18h] [ebp-4h]\n\n  v2 = a2 / 3;\n  v3 = 0;\n  if ( a2 % 3 &gt; 0 )\n    ++v2;\n  v4 = 4 * v2 + 1;\n  v5 = malloc(v4);\n  v6 = v5;\n  v15 = v5;\n  if ( !v5 )\n    exit(0);\n  memset(v5, 0, v4);\n  v7 = a2;\n  v8 = v6;\n  v16 = v6;\n  if ( a2 &gt; 0 )\n  &#123;\n    while ( 1 )\n    &#123;\n      v9 = 0;\n      v10 = 0;\n      v18 = 0;\n      do\n      &#123;\n        if ( v3 &gt;= v7 )\n          break;\n        ++v10;\n        v9 = *(unsigned __int8 *)(v3 + a1) | (v9 &lt;&lt; 8);\n        ++v3;\n      &#125;\n      while ( v10 &lt; 3 );\n      v11 = v9 &lt;&lt; (8 * (3 - v10));\n      v12 = 0;\n      v17 = v3;\n      for ( i = 18; i &gt; -6; i -= 6 )\n      &#123;\n        if ( v10 &gt;= v12 )\n        &#123;\n          *((_BYTE *)&amp;v18 + v12) = (v11 &gt;&gt; i) &amp; 0x3F;\n          v8 = v16;\n        &#125;\n        else\n        &#123;\n          *((_BYTE *)&amp;v18 + v12) = 64;\n        &#125;\n        *v8++ = byte_407830[*((char *)&amp;v18 + v12++)];\n        v16 = v8;\n      &#125;\n      v3 = v17;\n      if ( v17 &gt;= a2 )\n        break;\n      v7 = a2;\n    &#125;\n    v6 = v15;\n  &#125;\n  result = v6;\n  *v8 = 0;\n  return result;\n&#125;\n我们发现里面有个表byte_407830：\n\n发现是标准base64，这里对string的5,6,7以及2,3,4位进行加密，加密的结果是ak1w以及V1Ax，解密得到：\njMp\nWP1\n结合if里面的判断条件：\nif ( String[0] == v7[0] + 34\n        &amp;&amp; String[1] == v10\n        &amp;&amp; 4 * String[2] - 141 == 3 * v8\n        &amp;&amp; String[3] / 4 == 2 * (v13 / 9)\n        &amp;&amp; !strcmp(v4, &quot;ak1w&quot;)\n        &amp;&amp; !strcmp(v5, &quot;V1Ax&quot;) )\n我们可以知道string的值为（注意v7是加密后的）：\nUJWP1jMp\n简单注册机拖进jadx，找到关键代码：\nif (flag == 1) &#123;\n                    char[] x = &quot;dd2940c04462b4dd7c450528835cca15&quot;.toCharArray();\n                    x[2] = (char) ((x[2] + x[3]) - 50);\n                    x[4] = (char) ((x[2] + x[5]) - 48);\n                    x[30] = (char) ((x[31] + x[9]) - 48);\n                    x[14] = (char) ((x[27] + x[28]) - 97);\n                    for (int i = 0; i &lt; 16; i++) &#123;\n                        char a = x[31 - i];\n                        x[31 - i] = x[i];\n                        x[i] = a;\n                    &#125;\n                    String bbb = String.valueOf(x);\n                    textview.setText(&quot;flag&#123;&quot; + bbb + &quot;&#125;&quot;);\n                    return;\n                &#125;\n稍微改一下跑跑就能得到flag啦\ntemp = &quot;dd2940c04462b4dd7c450528835cca15&quot;\nx = []\nfor i in range(0, len(temp)):\n    x.append(ord(temp[i]))\n\nprint(x)\n\nx[2] = ((x[2] + x[3]) - 50)\nx[4] = ((x[2] + x[5]) - 48)\nx[30] = ((x[31] + x[9]) - 48)\nx[14] = ((x[27] + x[28]) - 97)\n\na = []\nfor i in range(0, 16):\n    a = x[31 - i]\n    x[31 - i] = x[i]\n    x[i] = a\n\nflag = &quot;&quot;\nfor i in range(0, len(x)):\n    flag += chr(x[i])\n\nprint(flag)\nPyRE使用python反编译网站或者工具。python反编译相关看这里。\n反编译后的代码是python2.7版本的，由于我的python版本是3.xx，还需要进一步处理：\nprint(&#39;Welcome to Re World!&#39;)\nprint(&#39;Your input1 is your flag~&#39;)\ninput1 = input(&#39;Enter your input1 value: &#39;)\nl = len(input1)\ncode = []\nfor i in range(l):\n    num = ((ord(input1[i]) + i) % 128 + 128) % 128\n    code.append(num)\n\nfor i in range(l - 1):\n    code[i] = code[i] ^ code[i + 1]\n\nprint(code)\ncode = [\n    &#39;%1f&#39;,\n    &#39;%12&#39;,\n    &#39;%1d&#39;,\n    &#39;(&#39;,\n    &#39;0&#39;,\n    &#39;4&#39;,\n    &#39;%01&#39;,\n    &#39;%06&#39;,\n    &#39;%14&#39;,\n    &#39;4&#39;,\n    &#39;,&#39;,\n    &#39;%1b&#39;,\n    &#39;U&#39;,\n    &#39;?&#39;,\n    &#39;o&#39;,\n    &#39;6&#39;,\n    &#39;*&#39;,\n    &#39;:&#39;,\n    &#39;%01&#39;,\n    &#39;D&#39;,\n    &#39;;&#39;,\n    &#39;%&#39;,\n    &#39;%13&#39;]\n解密脚本\ncode = [&#39;\\x1f&#39;, &#39;\\x12&#39;, &#39;\\x1d&#39;, &#39;(&#39;, &#39;0&#39;, &#39;4&#39;, &#39;\\x01&#39;,\n        &#39;\\x06&#39;, &#39;\\x14&#39;, &#39;4&#39;, &#39;,&#39;, &#39;\\x1b&#39;, &#39;U&#39;, &#39;?&#39;, &#39;o&#39;,\n        &#39;6&#39;, &#39;*&#39;, &#39;:&#39;, &#39;\\x01&#39;, &#39;D&#39;, &#39;;&#39;, &#39;%&#39;, &#39;\\x13&#39;]\n\nl = len(code)\nfor i in range(0, l - 1):\n    code[l-i-2]=chr(ord(code[l-i-2])^ord(code[l-i-1]))\n\nflag = &quot;&quot;\nprint(code)\nfor i in range(0, len(code)):\n    num = ((ord(code[i]) - i) % 128) % 128\n    flag += (chr(num))\n\nprint(flag)\n\n\n\n\n\n\n\n\n\n这里有一个问题就是第7行如果去掉chr就会报错\ncode[l-i-2]=(ord(code[l-i-2])^ord(code[l-i-1]))\n                               ^^^^^^^^^^^^^^^^\nTypeError: ord() expected string of length 1, but int found\n我们发现这个时候code[l-i-1])已经是个整型了。这是python3中ord()的一个bug（？）\n有没有人告诉我为什么加上chr就可以了啊\n","slug":"WP-1","date":"2023-11-14T08:44:12.000Z","categories_index":"","tags_index":"CTF,Reverse,buuoj","author_index":"C4IN"},{"id":"d6f1871fd5f6793b4b505709f6e722ba","title":"主存储的组织","content":"主存储器的组织\n\n\n\n\n\n\n\n\n本节PPT内容位于书本P260\n\n一些概念：\n主存容量=字数位数\n字数：可编址存储单元数\n位数：每个编址存储单元的位数\n\n地址译码方法\n全地址译码方式\n就是构成存储器时要使用全部地址总线信号，即所有的高位地址信号都用来作为译码器的输入，低位地址信号接存储芯片的地址输入线，从而使存储器芯片上的每一个单元在整个内存空间中具有唯一的地址。\n\n部分地址译码方式\n就是仅把地址总线的一部分地址信号线与存储器连接，通常是用高位地址信号的一部分（而不是全部）作为片选译码信号;低位地址信号接存储芯片的地址输入线。\n\n\n3-8译码器\n3-8译码器有3个使能端、3个输入端、8个输出端。在使能端为有效电平时，对应每一组输入代码，只有一个输出端为有效电平。\n扩展方式位扩展位扩展指只在位数方向扩展。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。\n\n当CPU访问该存储器时，其发出的地址和控制信号同时传给8个芯片，选中每个芯片的同一单元，其单元的内容被同时读至数据总线的相应位，或将数据总线上的内容分别同时写入相应单元。\n字扩展字扩展是指仅在字数方向扩展，而位数不变。字扩展将芯片的数据线、读/写线并联，由片选信号（高位地址线译码）选定存储芯片，低位地址线直接连接各芯片。\n\n由于存储芯片是，其中共需要14位片选信号，所以将低位的分配给各芯片。而我们用4片组成的芯片，我们需要4个片选信号来对应四个芯片，于是我们将高位的两位地址分给译码器。而是写使能线，负责控制数据的存取。\n\n同时扩展当构成一个容量较大的存储器时，往往需要在字数方向和位数方向上同时扩展，这将是前两种扩展的组合。\n例题相同规格芯片/全译码方式用2114(1Kx4)SRAM芯片组成容量为4Kx8的存储器，存储器的起始地址为1000H。假设CPU地址总线，数据总线,读/写信号线R/W。给出芯片地址分配与片选逻辑，画出存储器框图\n这里我们选用3-8译码器，译码方式采用全译码方式。\n\n扩展\n我们先扩展位数：\n再扩展单元数（字数）：\n一共需要8片2114(1Kx4)SRAM芯片。\n\n芯片地址分配\n我们先确定芯片对应的低位地址，紧接着确定片选逻辑需要的地址，剩下的不需要的地址位数视情况（用什么译码器、译码方式等等）置0或1。\n我们一共有，一共需要12位地址，所以我们将低地址分配给存储芯片。由于位扩展时是以并联方式连接芯片的，所以我们考虑地址时只需要考虑一块芯片需要的地址，每块芯片有需要10位地址，起始地址为。\n示意图如下：\n\n\n片选逻辑\n而我们一共有四组芯片，我们将高位的分配给片选逻辑以寻找各芯片组。我们有：\n第一组: 第二组: 第三组: 第四组: \n如果我们使用3-8译码器来产生片选信号，上述状态为：时（相当于使能端），分别为100、101、110、111（输入端）。\n\n画出存储器框图\n我们需要画出：存储芯片、片选、译码器、。\n由于每片芯片都是4位，所以数据总线D0~D3分别连接四块芯片，D4~D7连接另外四块芯片。\n\n\n\n不同规格芯片/部分译码方式某存储器按字节编址。其中, 0000H~07FFH为ROM区，选用EPROM芯片(2KB/片); 0800H~13FFH为RAM区，选用RAM芯片(2KB/片和1KB/片)。地址总线A15~A0。给出地址分配和片选逻辑。\n\n计算容量及芯片数\n0000H~07FFH：ROM区，一共，即2KB，需要一片EPROM\n0800H~13FFH：RAM区，一共，即3KB，需要2KB与1KB的RAM芯片各一片\n总容量为5KB，共需要3+10=13位地址。\n\n\n\n\n\n\n\n\n\ntips：每07FFH对应2KB，每03FFH对应1KB，每0FFFH对应4KB\n\n地址分配\n总容量为5KB，共需要3+10=13位地址，我们将低位的分配给芯片。\n\n\n片选逻辑\n观察每个芯片对应的地址以及存储空间大小，我们发现不需要额外的地址位来充当片选逻辑，只需要用总容量需要的地址位即可。\n令\n\n对的ROM，低位分配给芯片一共占用11位地址，高位地址形成片选逻辑有\n\n对的RAM，低位分配给芯片一共占用11位地址，高位地址形成片选逻辑有\n\n对的RAM，低位分配给芯片一共占用10位地址，高位地址形成片选逻辑有\n\n\n\n\n结构图：\n\n\n\n\n\n\n\n\n\n\ntips：在这题中我们会发现芯片组总容量寻址需要的地址与连接芯片的地址并不等同，不要混淆了\n根据结构图反推芯片地址等信息CPU地址总线16条,数据总线8条,有以下存储器连接电路:\n\n\n写出每片芯片的地址范围\n，需要13个地址位连接\n，需要12个地址位连接\n，需要11个地址位连接\n根据连接电路，我们知道A15A14A13是输入端，产生8KB芯片与4KB芯片的片选逻辑，剩下的低位直接连接芯片，所以确定了芯片的地址范围；\nA12作为额外的输入时，与前3位共同产生两个2KB芯片的片选逻辑。由于前一个2KB的芯片对应的A15A14A13大于后一个2KB芯片，所以地址也高于后一个芯片，为了地址的连续性（有点奇怪说实话，这里也只是我的猜测），我们令A12=0，取反后1对应第二个芯片，0对应第一个芯片，于是我们有下图：\n这些框是怎么个事儿啊\n\n\n分析芯片地址重叠情况\n\n\n\n\n\n\n\n\n\n地址重叠：即两块地址不同但大小相同的地址空间可以索引到同一块存储芯片上，出现这种情况可能导致数据存取、读写出现问题，也有时候有好处。部分译码方法经常会出现这种问题，全部译码则不会出现这种情况\n\n8KB芯片地址空间，没有地址重叠\n\n4KB芯片地址空间（即两个4K空间：、），有4K地址重叠\n\n2KB①芯片地址空间（即两个2K空间：升、），有2K地址重叠\n\n2KB②芯片地址空间（即两个2K空间：、）,有2K地址重叠\n\n\n\n\n综合用的芯片（若干片）构成一个12KB的存储器，其地址范围在C0000~C2FFFH以及C4000~C6FFF之间。数据总线为D0~D7,地址总线为A0~A19(高地址)，对芯片读写采用控制，且片选要求采用3-8译码器的输出，如下图所示。\n\nC2FFFH-C0000H=2FFFH\nC6FFFH-C4000H=2FFFH\n2FFFH+1=3000H=0011,0000,0000,0000B=12KB\n因此属于部分译码，有地址重叠\nC0000H=1100,0000,0000,0000,0000B\nC4000H=1100,0100,0000,0000,0000B\n可以得到A14地址线没有参与片选译码\n\n需要2K×4b的芯片多少片构成12KB的存储器?\n注意这里是4b而不是4。我们知道1B=8b，所以我们一共需要$((2K\\times 4b)2)6$，一共12片。\n\n每组芯片地址线如何分配？\n\n选择哪些地址线作为译码器的使能端？\n\n选择哪些地址线作为译码器的输入端？\n，一共需要13位地址。每组芯片占，将低位地址；共有6组芯片，需要高位作为输入端（片选逻辑），剩下的不参与译码，为使能端，根据地址范围可以确定\n\n\n在不增加其他器件的条件下，画出存储器逻辑电路图。\n\n\n\n​    PS 上面两个逻辑门分别是与门和或非门\n","slug":"主存储的组织","date":"2023-11-13T12:22:17.000Z","categories_index":"","tags_index":"计算机组成原理","author_index":"C4IN"},{"id":"d99770e1923876729b03e08dda13a753","title":"联邦学习出门","content":"联邦学习初识本质：联邦学习本质上是一种分布式机器学习技术，或机器学习框架。\n目标：联邦学习的目标是在保证数据隐私安全及合法合规的基础上，实现共同建模，提升AI模型的效果。（也就是解决所谓的数据孤岛问题）\n联邦学习的分类根据多参与方之间数据分布的不同，把联邦学习分为三类：横向联邦学习、纵向联邦学习和联邦迁移学习。\n横向联邦学习\n横向联邦学习的本质是样本的联合，适用于参与者间业态相同但触达客户不同，即特征重叠多，用户重叠少时的场景，比如不同地区的银行间，他们的业务相似（特征相似），但用户不同（样本不同）。\n\n步骤：\n\n各参与方从服务器A下载最新的模型，利用本地的数据训练模型，将得到的梯度加密后上传给服务器A，\n服务器A加权聚合各用户的梯度并更新模型参数。\n服务器A返回更新后的模型给各个参与方，各参与方更新各自的模型，直至模型收敛。\n\n\n\n\n\n\n\n\n\n\n加权聚合：，为权重，是值\n在横向联邦学习中，可以看作是基于样本的分布式模型训练，分发全部数据到不同的机器，每台机器从服务器下载模型，然后利用本地数据训练模型，之后返回给服务器需要更新的参数；服务器聚合各机器上的返回的参数，更新模型，再把最新的模型反馈到每台机器。在这个过程中，每台机器下都是相同且完整的模型，且机器之间不交流不依赖，在预测时每台机器也可以独立预测。\n纵向联邦学习\n纵向联邦学习又称基于特征学习，适用于两个数据集共享相同的样本ID空间，但特征空间不同的情况。比如在同一诚实的两家不同的公司，他们的受众都是这个城市的居民，但是两家公司提供的服务与需求不同。\n纵向联合学习是将这些不同的特征聚合在一起，以保护隐私的方式计算训练损失和梯度，从而利用双方的数据协同构建模型的过程。\n\n假设A和B想用自己的数据联合训练一个机器学习模型，且只有B有模型需要预测的标签数据。出于数据隐私和安全原因，A和B不能直接交换数据。为了保证训练过程中数据的保密性，我们引入了第三方合作者C。这里我们假设合作者C是诚实的，不与A或B串通，但A和B是诚实的，但彼此好奇，也就是该方法是在可信第三方下满足半诚实安全性的。\n加密样本对齐：使用基于加密的用户ID对齐技术来确认共同用户（也就是重叠样本），而不会暴露A和B各自的数据。在实体对齐期间，系统不会公开彼此不重叠的用户。\n训练加密样本：在确定共同用户（重叠样本）之后，我们可以使用这些共同用户的数据来训练机器学习模型。\n\n合作者C生成密钥对，将公钥发送给A,B\nA和B计算梯度以及损失，将得到的中间结果进行加密和交换\nA和B分别计算加密梯度并添加附加掩码，同时B计算加密损失；A和B将加密值发送给C\nC进行解密，并将解密后的梯度以及误差发送给A和B。A和B去除梯度的掩码，更新相应的模型参数。\n\n我们以线性回归和同态加密为例：\n假设学习率为 ，正则化参数，数据集以及分别对应的特征空间的模型参数，训练目标是：\n\n令，加密损失是：\n\n我们定义加法同态加密为，令，以及，我们有\n\n同样，令，则梯度为：\n\n\n为了进一步防止C从A或B那里学习信息，A和B可以通过添加加密的随机掩码（）进一步对C隐藏它们的梯度。\n\n\n\n\n\n\n\n\n\n正则化：添加参数来防止曲线过拟合\n\n联邦迁移学习\n联邦迁移学习适用于两个数据集不仅在样本上不同，而且在特征空间上也不同的情况。比如两个机构，一个是位于中国的银行，另一个是位于美国的电子商务公司，此时两者的样本与特征均只有小部分重叠 。我们可以使用有限的公共样本集学习两个特征空间之间的重叠部分，然后应用于其中一侧特征的样本的预测。                                                                                    \n联邦迁移学习与纵向联邦学习相似。在纵向联邦学习，若A，B仅有非常小的重叠样本集，为了将其覆盖范围扩展到整个样本空间，我们引入了迁移学习。迁移学习引入的目的是减少预测时的错误，因此在梯度计算时和纵向联邦略有不同。\n知乎-联邦学习\nWardseptember’ github\n聚合&amp;模型选择\nFederated Machine Learning: Concept and Applications\n","slug":"联邦学习出门","date":"2023-11-03T09:57:05.000Z","categories_index":"","tags_index":"联邦学习","author_index":"C4IN"},{"id":"e16b1f3b0f9a87736cbe2367687acdd5","title":"概率论公式整理-1","content":"\n\n\n\n\n\n\n\n\n😭要期中考了\n🐻1.2 随机事件和随机事件包含关系若，即事件发生，必然导致事件发生，称事件包含事件A，或是的子事件\n和事件从集合角度:  或\n从事件角度:  是事件与至少有一个发生\n积事件从集合角度:  且\n从事件角度:  是事件与同时发生\n互不相容事件\n若, 称、为互不相容或互斥事件,即、不可能同时发生\n\n中任意两个互不相容, 称互不相容(两两互斥)\n\n事件列互不相容是指其中任意有限个事件互不相容\n\n\n对立事件(逆事件)若, 且 , 称、互为对立事件 (逆事件)，记为从集合角度:  从事件角度:  是事件不发生\n差事件事件与之差记为从集合角度:  但从事件角度:  是事件发生并且不发生有\n完备事件组若两两互斥，且, 则称为完备事件组, 或称为的一个有限划分\n运算律\n交换律:  \n\n\n\n结合律:  \n\n\n\n分配律:  \n \n\n\n德·摩根律:\n\n\n吸收律:\n如果, 则，有\n \n\n\n🐶 1.3 概率频率\n频率具有稳定性：在一定条件下，频率稳定于概率\n古典概型\n仅有有限多个基本事件\n每个基本事件发生的可能性相等.\n\n所含的基本事件个数基本事件总数所含样本点的数目样本空间的样本点总数\n古典概率具有如下三个性质：\n\n对任意事件, 有\n\n\n\n若互不相容, 则\n\n\n\n概率的公理化定义设的样本空间为, 对于  E  的每个事件  A  均对应于唯一一个实数，记为  P(A) ,其对应规则为\n\n非负性：对任一事件, 有\n\n规范性：\n\n可列可加性：的事件列 , 互不相容,则\n\n​    \n​    称是的概率\n性质：\n\n不可能事件的概率为 0 , 即\n有限可加性：若试验的事件组互不相容, 则有\n\n​    \n\n对立事件概率之和为 1 , 即\n\n​    \n\n概率单调性：若事件和满足, 则有\n\n由概率的有限可加性，得\n\n有用结论:\n\n\n\n\n概率加法定理: 对试验的任意两个事件和有\n\n🥚1.4 条件概率定义: 设，是随机试验的两个随机事件，且，称\n为在事件发生的条件下，事件发生的条件概率\n非负性​    \n归一性​    \n可列可加性​    \n\n\n\n\n\n\n\n\n\n\n乘法公式​    设, 则有\n​    若, 有\n​    更一般地有, 若, 则\n​    \n全概率公式（事前概率）设随机试验的样本空间为, 为的一个有限划分, 且, 则有\n\n贝叶斯公式（事后概率）设随机试验的样本空间为为的一个有限划分, 且, 则有\n\n🐺1.5 随机事件的独立性事件的独立性设是试验的两个事件，若满足\n\n\n称事件与相互独立（上述两公式等价）。若事件和相互独立，则下列三对事件也相互独立\n​    \n设为试验的事件，若对任意的及 , 有\n\n成立，则称事件相互独立。若对一切, 有\n\n成立，则称事件两两独立。\n若个事件，相互独立，则将，，中的任意多个事件换成它们的对立事件后，所得到的个事件仍然相互独立。\n🍕2.1 随机变量的分布函数设的样本空间为, 对于每一个样本点, 都有唯一实数与之对应,且对于任意实数 , 事件都有确定的概率，则称为随机变量，简记为\n\n\n\n\n\n\n\n\n\n且使总有意义.\n分布函数设是一个随机变量,  是任意实数，称函数\n\n为随机变量的分布函数,  也记为\n分布函数的函数值表示事件 “随机点落在内“。\n的改变量是事件 “随机点落在内” 概率。\n\n\n\n\n\n\n\n\n\n如果左端点也取会是什么情况呢？\n\n\n\n\n\n\n\n\n\n\n\n\n也就是说， \n对于左端点，不包括它时，用函数值，包括它时，用右极限\n对于右端点，不包括它时，用右极限），包括它时，用函数值\n分布函数的性质\n为单调不降函数, 即若，则有\n, 且\n\n是右连续函数, 即，从而有\n\n\n🍔2.2 离散型随机变量如果随机变量  X  至多取可列无穷个数值:  , 记, 且满足\n\n称是离散型随机变量\n离散型随机变量的分布律称为的分布律。表示为\n\n\n\n\nX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对于离散型随机变量，因\n\n故由概率可加性\n\n贝努里实验和二项分布在重贝努里试验中, 事件发生概率为, 则事件发生的次数的分布律为\n\n称随机变量服从二项分布, 记为。分布可以看作\n泊松分布若随机变量的分布律为\n\n称服从参数为的泊松分布。记为泊松分布的重要性在于:\n\n现实中大量随机变量服从泊松分布\n泊松分布可视为二项分布的极限分布\n\n设随机变量序列，即有\n\n若, 则有\n\n即数列与是同阶的无穷小。故\n\n当  n  够大,  p  较小时有\n\n​    \n​    其中\n\n实际问题中,  n  次独立重复试验中, “稀有事件” 出现的次数可认为服从泊松分布.\n\n🍟2.3 连续型随机变量概率密度函数设随机变量的分布函数为, 若存在非负函数, 对于任意实数, 均有\n\n称随机变量是连续型随机变量, 称函数为的概率密度。\n\n连续型随机变量X的分布函数是连续函数\n\n是连续型随机变量，则对任意实数 , 有\n\n\n , 但是其逆不真\n\n\n概率密度函数的性质\n\n\n，即概率曲线下总面积为1\n\n满足上式的函数必是某个随机变量的概率密度函数。\n\n\n\n若在点处连续, 则有\n\n\n\n对于连续型随机变量，我们有\n\n连续型随机变量的分布函数是一个在上的连续函数\n\n设为连续型随机变量, 则对任一指定实数, 有\n\n故概率为0的事件不一定是不可能事件，同样的，概率为1的事件也不一定是必然事件。\n\n\n均匀分布设随机变量的概率密度函数为\n其他\n称随机变量在区间上服从均匀分布, 记为\n随机变量落在的子区间的概率与位置无关，仅与测度 (即长度) 成正比，即对于, 有\n\n\n\n\n\n\n\n\n\n\n注意均匀分布不满足可加性\n指数分布设随机变量的概率密度函数为\n其他\n称随机变量服从参数为的指数分布。指数分布具有无后效性， 即有\n\n正态分布（高斯分布）设随机变量的概率密度函数为\n\n其中是常数，则称随机变量服从参数为的正态分布(或高斯分布)，记为\n特别当时，其概率密度为\n\n称随机变量服从标准正态分布，即\n\n正态分布概率密度曲线的特征\n即概率曲线下总面积为 1 \n\n曲线关于直线对称, 即对任意实数有\n\n\n\n  曲线下直线两侧的面积各为, 并且\n  \n正态分布概率的计算\n若随机变量, 其分布函数为\n\n若随机变量服从标准正态分布,其分布函数为\n\n有\n\n若随机变量, 则\n\n​    \n\n若随机变量, 则\n\n​    \n\n分位数  \n, 若实数使\n\n\n​    \n​    则称为标准正态分布的对应于的上侧分位数。\n\n原则：\n正态随机变量在以位置参数为中心, 半径为的对称区间内取值的概率达以上, 几乎不在之外取值.\n\n线性可加性\n若是两个独立的正态分布随机变量，则\n\n\n\n\n\n\n\n\n\n\n\n二项分布、泊松分布、正态分布满足可加性\n😍3.1 二维随机变量及其分布设随机试验的样本空间为, 对于每一样本点, 有两个实数与之对应，称它们构成的有序数组为二维随机变量。\n联合分布函数记事件\n\n对任意实数对, 称二元函数\n\n为的联合分布函数，其几何意义就是与坐标轴包围的面积。\n\n\n一维随机变量、的分布函数和称为的边缘分布函数.由联合分布函数可确定边缘分布函数\n\n\n\n\n\n\n\n\n\n\n注意，无法仅由边缘分布函数确定联合分布函数\n多维随机变量的联合分布不仅与每个分量的边缘分布有关，而且还与每个分量之间的联系有关\n计算边缘分布函数需要验证：\n\n\n\n\n计算公式：\n\n联合分布函数的性质\n\n单调不减性  \n分别对 单调不减。\n当  \n当  \n\n\n  \n\n有界性 \n\n\n右连续性 \n分别关于或右连续。\n\n\n​    \n\n相容性\n\n​    对任意, 有\n​    \n若二元函数满足上述4条性质，则必存在二维随机变量以为分布函数。\n维随机变量的联合分布函数为\n\n由的联合分布函数，可确定其中任意个分量的联合分布函数，称为维边缘分布函数。\n\n联合分布律设二维随机变量至多取可列对数值:  \n\n\n若 \n\n\n\n\n称为二维离散型随机变量，称\n为\n的联合分布律。\n联合分布函数为\n\n由联合分布律确定随机变量的分布律\n\n\n联合概率密度二维随机变量的联合分布函数为, 如果存在非负的函数使得对任意实数对, 有\n\n称是连续型随机变量，称为的联合概率密度.\n性质\n\n\n\n\n\n前两条可作为判断一个二元函数是否是联合概率密度的标准\n\n\n若在处连续, 则\n\n\n​    \n\n若, 有\n\n​    \n\n关于和的边缘概率密度为\n\n\n\n二维均匀分布设, 面积为, 若二维随机变量的联合概率密度为\n其他\n则称在上服从均匀分布。\n\n在上服从均匀分布，设则有\n\n\n设则  \n的长度的长度\n\n\n注意，若满足均匀分布，但是本身不一定满足均匀分布。所以我们要求的分布一般从对求积分入手。\n二维正态分布二维随机变量联合概率密度为\n\n其中均为常数 , 且，称服从二维正态分布，记为：\n\n若，则\n😋3.2 二维随机变量的独立性随机事件与相互独立，若\n\n设是二维随机变量, 若对任意实数对均有\n\n成立，称 与相互独立。\n等价条件\n\n与相互独立对任意实数均成立\n\n离散型：    \n\n连续型：\n，在平面上除去 “面积” 为 0 的集合外成立\n\n\n多维随机变量的独立性设维随机变量的联合分布函数为 , 若对任意实数均有\n\n称相互独立。\n对任意实数向量, 个随机事件都相互独立\n若维随机变量相互独立，则任意个随机变量也相互独立。\n 随机变量相互独立则一定两两独立，但逆不真。\n若维随机变量相互独立，则\n\n随机变量也相互独立\n\n维随机向量与维随机向量也相互独立\n\n随机变量与也相互独立\n\n\n🥰3.3 条件分布设的联合分布律为:\n\n若, 则在事件发生的条件下事件发生的条件概率为\n\n此概率数列具有分布律的性质:\n\n\n\n\n称 的条件下，随机变量的条件分布律，可以等价地改写为乘法\n\n\n​    \n条件概率密度给定, 对任意有\n\n且对任意, 极限\n\n存在,称此极限函数为在的条件下，随机变量的条件分布函数。记作。\n设是连续型随机变量，且满足在附近连续, 且则有\n\n我们称\n\n为在的条件下随机变量的条件概率密度。\n判断两个离散型随机变量相互独立\n1)  2)  3)  4)  \n判断两个连续型随机变量相互独立\n1)  2)  3)  4)  \n🤤3.4 随机变量函数及其分布离散型随机变量的分布律为\n\n是随机变量, 则\n\n其中\n设随机变量是离散型随机变量,  相互独立,其分布律分别为\n\n则的分布律为\n\n二维离散型随机变量  (X, Y)  的联合分布律为\n\n是随机变量, 则\n\n其中\n设随机变量是离散型随机变量,  相互独立,其分布律分别为\n\n则的分布律为\n\n若相互独立, 且则\n反之若, 则存在相互独立的, 使\n\n随机变量相互独立\n具有相同类型的分布;\n\n若的分布除参数变化，而分布类型不变，称分布具有可加性（二项分布、泊松分布）。\n连续型随机变量的函数及其概率密度\n设是连续型随机变量，若也是连续型随机变量，则\n\n​    的连续点其他\n\n\n\n\n\n\n\n\n\n从分布函数定义出发\n将转换为关于的不等式：\n\n当为单调递增函数时\n\n从而有\n\n当为单调递减函数\n\n\n\n  有\n\n求二维连续型随机变量的函数的概率密度\n\n\n先求出的分布函数\n\n\n对微分得到\n\n\n设随机变量具有概率密度, 又设函数**处处可导而且恒有 (或恒有)**, 则是连续型随机变量, 其概率密度为\n其他\n其中是的反函数。\n应用公式时,必须仔细验证是否满足条件 “函数处处可导且恒有(或恒有 )”. 这是比较强的条件, 有许多函数不满足此条件，可考虑采用先求分布函数的基本方法。\n特殊函数分布\n若与相互独立, 有\n\n又若与有相同分布\n从而\n设随机变量的联合概率密度为\n\n做积分变量变换, 令\n\n由连续型随机变量定义\n\n得到公式\n\n类似可以得到：\n\n设随机变量的联合概率密度为\n\n\n\n\n\n做积分变量变换，令，有\n\n\n\n\n\n\n\n\n\n\n做这一块的题不要忘了其他情况为0，记得写成分段函数的样式\n😈一些概念&amp;结论\n概率的定义：非负性、归一性/规范性（）、可列可加性\n\n概率为 0 的事件不一定是不可能事件, 概率为 1 的事件不一定是必然事件。\n选一连续型随机变量但并非不可能事件,  但并非必然事件\n\n互不相容/互斥、对立、独立：\n\n互不相容/互斥：\n对立：\n独立事件：，以及分布函数和概率密度\n\n\n独立的等价：\n\n当时,  A, B  独立的充分必要条件是\n当时, 独立的充分必要条件是\n当时,  独立的充分必要条件是\n当时,  独立的充分必要条件是\n\n\n常见概型：\n\n古典概型：样本空间结果有限且等可能\n几何概型：二维的古典概型\nn重伯努利：二项分布\n\n\n离散型&amp;连续型：\n\n离散型\n二项分布、泊松分布\n只取有限个或可列无穷个数值\n没有概率密度函数\n分布函数为阶梯状\n间断点的概率为\n\n\n连续型\n正态分布、均匀分布、指数分布\n分布函数连续\n概率密度函数连续\n所有的点，可以与上面的间断点联系一下\n收变概率密度函数个别点的值不影响分布函数F (x) 的取值，从这个角度来讲: 同一个分布函数其概率密度并不唯一\n\n\n\n判断方法：\n\n不是离散型：\n不是阶梯型\n某区域严格单增\n\n\n不是连续型\n分布函数不连续（找分界点）\n某个点\n\n\n\n\n一个表格\n\n\n  名称与记号分布列或概率密度数学期望方差分布二项式分布分布几何分布均匀分布指数分布正态分布\n\n原则\n\n\n联合分布函数的性质：单调不减性、有界性、右连续性、相容性\n\n求参数用：\n以及右连续性\n\n求概率用：\n\n\n\n特殊函数分布公式\n\n：\n：\n\n\n可加性：\n\n若, 且相互独立, 则\n\n若, 且相互独立, 则\n\n若, 且相互独立, 则\n\n若, 且相互独立, 则\n\n\n\n\n🦈一些题目\n注意z的取值是怎么取的。\n\n这题需要注意均匀分布中，所以与之间的关系需要讨论。\n\n弯转过来就很简单了。woshishabi\n\n由于x的限制，需要对y的取值进行讨论。还要看清楚求的是概率分布还是概率密度（cao）。\n\n\n\n\n\n\n\n\n\n我们在做概率密度、分布函数相关题目是一定要先把各个变量的定义域先搞清楚，不然做题很容易出错\n在遇到积分有关的题目的时候，不要只局限于微积分的知识，还要注意观察式子是否满足一些特殊分布（比如看到e相关想想正态分布）\n设\n\n证明是概率密度函数证 \n\n显然成立\n\n\n\n\n所以\n\n","slug":"概率论公式整理-1","date":"2023-10-27T08:29:15.000Z","categories_index":"","tags_index":"课内,概率论与数理统计","author_index":"C4IN"},{"id":"c7a71862699349f10d6bd40f9dbcde05","title":"TinyOLE","content":"TinyOLE是一种实现无条件安全双方计算的有前景的方法。建立在OLE原语之上，该协议高效且可应用于广泛的应用场景。虽然该协议存在一些限制，但它代表了安全计算领域的重要进展。\n文章引入了一种基于不经意线性函数计算(OLE)的主动安全两方安全计算(2PC)的新方法，这是不经意传输(OT)的拓展。该协议在概念上简单，提供无条件的UC-安全性，并将OLE原始操作作为黑盒使用。\n在1-out-of-2 OT中，发送者输入两个消息和，接收者输入一个选择位b并只获取。OLE在有限域F上工作，其中发送者输入两个域元素a和b，接收者输入一个域元素并只获取。注意，如果我们设置和，那么和。因此，对于有两个元素的字段，OLE等同于比特的1-out-of-2 OT。因此，OLE可以被视为OT的拓展，适用于较大字段的情况。在多种假设下，可以有效地实现OLE，既有独立的安全性，也有UC-安全性。\n文章所提出的协议可以评估一个有限域F上的算术电路，前提是拥有OLE的黑盒访问机制。这种方法每个乘法门只消耗22个OLE。从概念上讲，文章所提出的方案采用了Nielsen等人在tinyOT中的技术，将基于OT的布尔电路的实际积极安全的2PC提升到算术设置。在此过程中，文章开发了几种新的方案，用于生成各种风格的OLE并组合它们。\n参考隐私计算研习社-TinyOLE\n论文链接\n","slug":"TinyOLE","date":"2023-10-27T08:10:18.000Z","categories_index":"","tags_index":"","author_index":"C4IN"},{"id":"9e7562adc34393738695af14263310c0","title":"Lattice-NTRU-2","content":"多项式卷积乘法多项式的卷积乘法可以看成一个矩阵操作。假设和在上相乘，表述为：\n\n那么就有（参考多项式乘法，用分配律也行）：\n\n由于的结果肯定也是个多项式（封闭性），所以先把上面结构调整到像一个多项式，即合并次数相同的项（注意和最高项只能是 ，所以不考虑模的时候乘起来最高项只能是，然后小于次的项和大于等于次的项分开处理）：\n\n最开始讲环的时候说到，是模的，所以，所以有：\n\n所以说未知数的指数部分需要模，可以继续化简：\n\n其中的即为的次项系数。 \n\n\n\n\n\n\n\n\n\n设则: \n\n检验通过\n以下用矩阵的形式表达，且记的第次项系数为，有：\n\n","slug":"多项式卷积乘法","date":"2023-09-25T00:54:38.000Z","categories_index":"Crypto","tags_index":"Lattice,Crypto","author_index":"C4IN"},{"id":"d702884c0497c30710829cd42dd95573","title":"Lattice-NTRU-1","content":"NTRU是一个带有专利保护的开源公开密钥加密系统，使用基于格的加密算法来加密数据。它包括两部分算法：NTRUEncrypt用来加密，NTRUSign用来进行数字签名。与其他流行的公钥加密系统不同，它可以防止被Shor算法破解，并显著提升了性能。\n多项式除法我们首先了解一下多项式除法。多项式除法是代数中的一种算法，用一个同次或低次的多项式去除另一个多项式。它可以很容易地手算，因为它将一个相对复杂的除法问题分解成更小的一些问题。多项式除法和我们小学学到的带余除法是有些相似的（算数的长除法）。\n下面有个例子：\n计算\n\n横线上多项式即为商，而剩下的（-123）就是余数。\n\n多项式除法-wiki\nNTRU我们先看三个卷积多项式环（Convolution Polynomial Rings）。\n\n其中是整数域上的多项式，比如这类的多项式，长横线是商环（Quotient Ring），分子上的多项式模上分母的就会落在，其中是NTRU的参数。\n\n\n\n\n\n\n\n\n\n比如说我们取，即，我们试着把换到上，模数是，有\n\n就是最后落在上的结果，即是上面说的多项式除法的余数。\n\n标记一下Sage这个东西\n\n类似，但是系数模的多项式，也就是多项式的系数需要模，使其落在中。说白了就是的另一种写法。\n\n\n\n\n\n\n\n\n\n同样的来看一个例子，设，把转换到中：\n\n上述是NTRU的公开参数，要求为素数，且\n\n\n\n\n\n\n\n\n\n\n更详细的参数设置建议（[HPS17]）：\n一般取，为了加快运算一般取2的幂次方，通用取素数。\n三元多项式和密钥生成输入为两个整数，输出一个三元多项式，三元即，函数会采样有个项系数为1，个项系数为-1，其余项系数为0（即没有）且落在上的多项式。\n然后利用采样密钥：\n\n私钥：\n可信方选择满足上述条件的公共参数，私钥由两个随机选择的多项式组成\n\n取的原因是不可逆。计算逆元\n\n是两个落在上的主要的私钥，把和事先存储起来可以加快运算速度，因为计算多项式环的逆元需要一段时间。\n\n公钥：\n\n或者\n\n\n\nCenter-Lift和加解密Center-lift是把和中的多项式转换回中，使得多项式系数的绝对值最小。Center-lift的定义可以看[HSP14]的7.9节，主要是针对多项式系数的操作，可以和补码类比。\n上面假设是多项式的Center-lift，即转换到。 上图的为上的一个多项式，为其Center-lift到后的结果， 为的次项系数，为的次项系数，结果是所有的系数会落在区间 ，而且还能保证。\nCenter-lift的方法也不难，和转补码相似\n\n然后看看加密：\n明文空间是做Center-Lift后的空间，加密使用的随机数在中采样，加密公式是：\n\n如果要解密的话，只需要将去除即可，由于，所以直观上把放入中就可以把去除，而明文空间是做Center-Lift的空间，所以把放入并不会改变的结构，即可以恢复明文。但实际上我们没办法保证，除非，但由于，所以这种情况并不存在，不能直接转换到上。\n前面说过可以转换到上，所以可以考虑把转换（Center-Lift）到上，然后再转到上。但同时也会有新的问题，直接把上的转换到上的结果不一定是原来的上的，比如说，除了把放在上运算后的系数就落在上，也即上的元素做Center-lift后的区间。\n参考：\n[HPS14]Hoffstein J, Pipher J, Silverman J H, et al. An introduction to mathematical cryptographyM]. New York: springer, 2008.\n[HPS17] [Hoffstein J, Pipher J, Schanck J M, et al. Choosing parameters for NTRUEncrypt[C]//Topics in Cryptology–CT-RSA 2017: The Cryptographers’ Track at the RSA Conference 2017, San Francisco, CA, USA, February 14–17, 2017, Proceedings. Springer International Publishing, 2017: 3-18.\nhttps://0xffff.one/d/1424-ntru-xue-xi-bi-ji\n","slug":"Lattcies-NRTU","date":"2023-09-19T13:46:45.000Z","categories_index":"Crypto","tags_index":"Lattice","author_index":"C4IN"},{"id":"f321673e1ae041d21d7612aab6d63663","title":"lattice-crypto-1","content":"线性独立空间上有集合，格 (Lattices) 就是这些向量的线性组合，用公式表示为: \n\n而其中任意一组可以生成格的线性无关的向量都称为格的基，格的维数等于格中向量的个数。某种意义上格可以理解为系数均为整数的向量空间。\n\n格的困难问题最短向量问题（SVP，The Shortest Vector Problem）寻找一个格中最短的非零向量。即，寻找一个满足其欧几里德范数最小。\n最接近向量问题（CVP，The Closest Vector Problem）对于一个非格中的向量，在格中寻找一个向量，使得  最小。 \n由于CVP和SVP都是NP完备问题，因此求解起来十分困难，因此这两个问题都是可以作为密钥体制的基础的。\ntoy model它是 lattice 可用于传统公钥密码分析的例证，另外也是 NTRU 公钥密码体系的一个低端版本。\n首先Alice选择一个大整数作为公共参数，然后选择两个比较小的整数满足\n\n亦即的长度大约小于 的一半；的长度大约在的一半到的一半之间。从而远远小于, 为。另外要求与都互质。接下来, Alice 计算\n\n注意到尽管很小, 其逆元仍然会很大, 于是是的级别。Alice 的公钥是 , 私钥是 。\n假设Bob有一个小于的明文，然后他随机选择整数，计算\n\n将作为密文发送给Alice，Alice解密：\n先计算\n，\n然后计算\n，\n特别注意这里的模数是。\n带入，得到\n\n\n于是我们断言。\n\n\n\n\n\n\n\n\n\n原因：\n首先我们有,\n注意到，所以，即就是的真实值。\n将模，分离出，然后乘以得到，我们可以知道，于是就是真实值。\n我们可以发现，假如一个敌手想攻破该密码体系，只需要伪造一组，使其解密时与相同即可。也就是说需要满足：\n\n然后按照上述步骤进行，就可以获得。也就是说只需要找到合法的，就可以攻破这个密码体系。\n将改写成，那么就可以转化为找到足够小的使得\n\n这个式子等价于这两个向量以为系数进行线性组合，如果我们能找到合适的，使得线性组合得到的向量足够短，那我们就攻破了该密码体系。\n上面的问题总结起来就是：有两个已知的向量，需要找出一套线性组合系数（必须是整数），来生成一个足够短的向量。\n对于敌手，已知长度均为向量，需要寻找长度为的线性组合来攻破密码体系。从格的角度来说，即在lattcie 寻找一个很短的向量：\n\n在二维的 lattice 里面找最短向量，是有高效算法的（Gauss 的工作）。于是攻破了这个密码体系。\n推荐https://www.ruanx.net/lattice-1/\nhttps://lazzzaro.github.io/2020/11/07/crypto-%E6%A0%BC%E5%AF%86%E7%A0%81/index.html\n","slug":"lattice-1","date":"2023-09-19T10:44:02.000Z","categories_index":"","tags_index":"Crypto,lattice","author_index":"C4IN"},{"id":"030d8a1cfb3d1c00a80edaa1d841a1b0","title":"MASCOT前置知识（二）","content":"SPDZ框架摘要SPDZ是一种MPC计算的协议框架，基于同态加密、秘密共享等技术实现安全多方计算，相关内容引自参考文献[1].\n\nSPDZ主要包括两个阶段，离线阶段（预计算）主要基于同态加密生成在现阶段需要的参数，在线阶段主要基于秘密共享完成各种计算。\nSPDZ可以计算有限域中的任何计算。\nSPDZ 满足 UC 安全框架下的静态恶意敌手(static adaptive adversay)攻击模型，即 n 个参与方中，即使最多 n-1 个参与方恶意违反协议或者合谋。\nSPDZ使用Message Authentication Code (MAC)，检测参与方是否诚实地进行计算，MAC参数在离线阶段生成。\nSPDZ不检测哪个参与方为恶意参与方，在检测到协议被违反情况即停止协议运行而防止数据泄漏。\n\n安全模型安全多方计算安全模型一般采用Universally composable（UC）模型[2]，按照攻击者能力可以划分为半诚实、恶意参与者，按照恶意参与者的门限可以划分为多数诚实、多数恶意协议。\n按照攻击者能力：\n\n半诚实模型：各参与方在计算过程中完全遵从 MPC 协议，既不会违反协议篡改数据也不会多个参与方之间进行合谋。\n恶意模型：攻击者允许随意篡改协议，可以联合他人进行合谋攻击。\n\n按照攻击者门限：\n\n多数诚实：恶意参与者不超过总参与方一半。\n多数恶意：恶意参与者至多可以有个（总参与方为）。\n\nSPDZ协议满足Universally composable（UC）框架下的静态恶意敌手(static adaptive adversary)攻击模型，最多允许个恶意参与方。\n基本定义秘密分享共有两种表示方法和，第一种主要用于表示输入的秘密分享值，第二种则主要用于表示全局密钥和随机数等参数。\n$表示\">表示有限域中的值的秘密分享值表示方法为：\n\n\\langle a \\rangle := (\\delta,(a_1,\\cdots,a_n),(\\gamma(a)_1,\\cdots,(a)_n))其中，\n各参与方持有，是公开值，为全局MAC密钥。\n秘密分享值计算具有以下性质：\n\n\n\n\n\n\n\n\n\n\n\n\n其中\n表示的秘密分享值表示方法为：\n各参与方持有\n\n(\\alpha_i,\\beta_i,\\gamma(\\alpha)_1^i,\\cdots,\\gamma(\\alpha)_n^i)其中为各参与方的密钥，主要验证MAC密钥和随机数秘密分享值的MAC验证。\nMAC密钥MAC密钥全局MAC密钥秘密分享值表示方法为，由于每个参与方持有\n\n(\\alpha_i,\\beta_i,\\gamma(\\alpha)_1^i,\\cdots,\\gamma(\\alpha)_n^i)因此各参与方可通过验证MAC密钥。为了打开，参与方将发送给，校验是否成立。\n三元组及乘法运算加法计算相对直接，直接利用秘密分享值的性质，计算加法，即可得到结果：\n乘法计算需要借助三元组（Beaver Triple[3]），三元组在离线阶段生成，表示为，且满足。\n由于在实际生成三元组过程中可能会引入误差，因此需要额外“消耗”(sacrificing)一组三元组用于校验三元组。\n给定一三元组，设输入为则乘法可按一下方式计算：\n\n打开得到，\n打开得到，\n然后计算\n\n正确性验证：\n\n\\begin{align}\n\\lang x \\rang \\cdot \\lang y \\rang &= \\lang c \\rang +\\epsilon\\lang b \\rang + \\delta \\lang a \\rang +\\epsilon\\delta \\\\\n&=\\lang ab \\rang + (\\lang x \\rang - \\lang a \\rang)\\lang b \\rang+(\\lang y \\rang - \\lang b \\rang )\\lang a \\rang + (\\lang x \\rang - \\lang a \\rang )(\\lang y \\rang - \\lang b \\rang)\\\\\n&=\\lang ab \\rang + \\lang bx\\rang-\\lang ab \\rang +\\lang ay \\rang -\\lang ab \\rang+\\lang xy \\rang-\\lang ay \\rang - \\lang bx \\rang +\\lang ab \\rang\\\\\n&=\\lang xy \\rang\n\\end{align}SPDZ协议SPDZ协议主要包括离线阶段和在线阶段。\n\n离线阶段\n离线阶段需要用到同态加密技术，产生的辅助数据包括：\n\n多元乘法三元组的秘密分享值；\n随机数秘密分享值；\n全局MAC密钥。\n\n这些辅助信息和在线计算阶段的输入数据无关，因此可以提前进行计算。\n以全局MAC密钥​为例，介绍离线阶段生成参数过程：\n\n各参与方联合生成同态加密公钥和私钥，以 BGV 方案[4]为例，私钥和公钥具有线性特性，因此解密过程中各方可利用进行部分解密，然后把解密结果汇总得到最终明文结果，解密过程中不泄漏各自部分的私钥； \n各参与方生成随机数，然后利用进行同态加密得到密文(表示$$\\alpha_i的同态密文)，并将密文发送给其他参与方; \n各参与方汇总得到，利用私钥进行联合解密，联合解密过程中会加入一个随机数进行混淆，然后reShare得到。\n\n\n在线阶段\n\n初始化。准备全局MAC密钥，随机数秘密分享值，乘法三元组等参数。\n输入阶段。设参与方的输入为，向打开，然后广播，各参与方计算。输入阶段主要是将输入值分片，产生对应的秘密分享值。\n加法计算。设输入为，计算。 \n乘法计算。设输入为，则计算分为两步：\n使用三元组校验；\n计算。 \n\n\n输出阶段。再输出最终结果前，需要对中间值、结果进行MAC校验，SPDZ 协议 MAC 验证时为了提高效率，可以在打开多个秘密分享值后通过一次MAC批量校验。\n\n\n\n协议离线阶段离线阶段主要借助同态加密、、、协议实现，其中同态加密主要保证秘密共享的同态加法、乘法性质，协议主要将秘密值进行分割，进行加法秘密共享，协议主要生成形式的秘密共享值，协议主要生成形式的秘密共享值。\n同态加密同态加密方案未提出具体方案，可参考BGV[1]等同态加密方案（在后续SPDZ改进论文中，使用了一层的BGV方案）。\n协议协议主要输入同态加密密文（明文为），以及一个参数，若，则输出为（由参与方持有)，且有；若，则输出一个新的密文，新的密文仍然包含。\n1.各参与方随机选择，记。\n2.各参与方计算，并将结果发送给其他参与方。\n3.各参与方生成的零知识证明，并发送给其他参与方进行验证（零知识证明为一种密码协议，可以在不泄漏秘密值的情况下证明秘密值的正确性）。\n4.所有参与方计算， 。（PS+不一定是简单相加）\n5.所有参与方运行分布式解密算法，解密，得到。\n6.参与方计算，其他参与方计算。\n7.若，则所有参与方计算。\nP Bracket协议P Bracket协议输入为各参与方的秘密份额，以及一个公共的秘密份额（密文中包含），输出形式的秘密分享值。\n1.对于， 所有参与方计算；各参与方计算，因此各参与方得到了的秘密值份额。\n2.输出。\nP Angle协议P Angle协议输入为各参与方的秘密份额，以及一个公共的秘密份额（密文中包含），输出形式的秘密分享值。\n1.所有参与方计算；\n2.各参与方计算，因此各参与方得到了的秘密值份额。\n3.输出。\n离线阶段完整协议初始化\n所有参与方运行分布式密钥生成算法，得到公钥；\n各参与方生成； \n各参与方生成，记，为全局MAC密钥；\n各参与方计算并广播密文,，其中；\n各参与方使用零知识证明协议验证为正确；\n所有参与方计算，生成秘密分享值。\n\n生成随机秘密共享值\n各参与方生成，记；\n各参与方计算并广播密文，记； \n各参与方使用零知识证明验证密文的正确性；\n所有参与方计算。\n\n生成乘法三元组\n各参与方生成记，；\n各参与方计算并广播密文；\n各参与方使用零知识证明协议验证密文的正确性； \n所有参与方计算；\n所有参与方计算； \n所有参与方计算； \n所有参与方计算；\n所有参与方计算。\n\n在线阶段完整协议在现阶段主要完成计算以及中间值和结果的MAC校验等，基础计算主要包括加法、乘法等。\n在线阶段主要过程如下：\n\n初始化。准备全局MAC密钥，随机数秘密分享值、，乘法三元组等参数。\n输入阶段。设参与方的输入为，向打开，然后广播，各参与方计算。输入阶段主要是将输入值分片，产生对应的秘密分享值。\n加法计算。设输入为，计算。\n乘法计算。设输入为，则计算分为两步：\n使用三元组校验；\n计算。\n\n\n输出阶段。再输出最终结果前，需要对中间值、结果进行MAC校验，SPDZ 协议 MAC 验证时为了提高效率，可以在打开多个秘密分享值后通过一次MAC批量校验。\n\n\n设在此次验证 MAC 前已有个秘密分享值被打开，即有个MAC 未验证，记为，其中对应的秘密分享值为，需要先打开一个随机值，然后各参与方计算，最后各参与方计算；\n各参与方使用对和输出值进行“承诺”，“承诺”函数包括承诺阶段和打开阶段，承诺阶段对秘密值进行“混淆”，生成承诺值，并发送给验证方；打开阶段，发送方将秘密值发送给验证方，验证方使用秘密值（通常也会加入随机数）验证承诺值。“承诺”函数可由Paillier加密、离散对数、哈希等方法构造。\n打开全局MAC密钥。\n各参与方通过承诺函数，打开，然后所有参与方验证，若公式成立，则验证通过，即输出结果正确，否则，终止协议。\n打开最终结果前，需要对的承诺值进行验证。验证通过后，计算，然后验证，验证通过，则即为最终正确结果。\n\n参考文献[1] I Damgård, Pastro V , Smart N , et al. Multiparty Computation from Somewhat Homomorphic Encryption[C]// Springer-Verlag New York, Inc. Springer-Verlag New York, Inc. 2012.\n[2] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable two-party and multi-party secure computation. In STOC, pages 494–503, 2002.\n[3] Beaver. Efficient multiparty protocols using circuit randomization. In J. Feigenbaum, editor, CRYPTO, volume 576 of Lecture Notes in Computer Science, pages 420–432. Springer, 1991.\n[4] Z. Brakerski, C. Gentry, and V. Vaikuntanathan. (leveled) fully homomorphic encryption without bootstrapping. In ITCS, pages 309–325. ACM, 2012.\nhttps://mp.weixin.qq.com/s/uwUnRc6j_ZpMxd6Dfnv3-w\n​       https://mp.weixin.qq.com/s/mR847vF1Djb-aINJTaFKAA\n","slug":"MASCOT前置知识（二）","date":"2023-09-19T08:29:14.000Z","categories_index":"Crypto,多方安全计算,MASCOT","tags_index":"Crypto,Basic","author_index":"C4IN"},{"id":"e7f9c8c700d84e1b335913cf1672fdbf","title":"aurora主题的latex配置","content":"如何给aurora主题配置latex公式支持最近换了个主题，然后latex公式怎么搞都搞不好。找了好久终于找到了解决方法。\n进入博客根目录，下载hexo-renderer-kramed、hexo-math、hexo-filter-mathjax\nnpm install hexo-math --save\n## 卸载默认 markdown 渲染引擎 hexo-renderer-marked；若不卸载，会和新的引擎发生冲突（conflict）\n$ npm uninstall hexo-renderer-marked --save\n## 安装新引擎 hexo-renderer-kramed \n$ npm install hexo-renderer-kramed --save\n\n$ npm install hexo-filter-mathjax\n$ hexo clean\n然后修改kramed配置，解决冲突：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,\n\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n只要改这俩就行啦。\n然后在根目录下的_config.yml开启渲染：\n# MathJax Support\nmathjax:\n  tags: none # or 'ams' or 'all'\n  single_dollars: true # enable single dollar signs as in-line math delimiters\n  cjk_width: 0.9 # relative CJK char width\n  normal_width: 0.6 # relative normal (monospace) width\n  append_css: true # add CSS to pages rendered by MathJax\n  every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter\n  packages: # extra packages to load\n  extension_options: {}\n    # you can put your extension options here\n    # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail\n # MathJax\nmath:\n  engine: 'mathjax'\n  mathjax:\n    src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML\n在你的文章markdown文件中加入：\nmathjax: true\n\n然后试试：\n// inline \n$p=P\\left(A_{1}\\right)+P\\left(A_{2}\\right)+\\ldots+P\\left(A_{n}\\right)=p_{1}+p_{2}+\\ldots+p_{n}$\n\n// block\n$\n\\begin{aligned}\np &amp; =P\\left(A_{1} \\cup A_{2} \\cup \\cdots \\cup A_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1} \\bar{A}_{2} \\cdots \\bar{A}_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1}\\right) P\\left(\\bar{A}_{2}\\right) \\cdots P\\left(\\bar{A}_{n}\\right)\n\\end{aligned}\n$\n结果：\n行内公式 inline equation\n公式块\n\n参考链接：\nhttps://cps.ninja/2019/03/16/hexo-with-latex/\nhttps://github.com/auroral-ui/hexo-theme-aurora/issues/55\nhttps://github.com/next-theme/hexo-filter-mathjax\n","slug":"aurora主题的latex配置","date":"2023-09-17T12:02:13.000Z","categories_index":"","tags_index":"头疼的配置问题","author_index":"C4IN"},{"id":"67a2e1ac4586a101302bb0a481c51db5","title":"MASCOT前置知识（一）","content":"这几天开始看MASCOT，先学学里面提到的一些基础知识。\n\n通用哈希函数(Universal Hash Function)通用哈希函数是指从具有一定数学特性的散列函数族中随机选择一个散列函数（见下文定义）。这样，即使数据是由对手选择的，也能保证较低的预期碰撞次数。\n假设我们想把某一个全集映射到m个“区”中（记为 ）。通常哈希是都需要减少发生哈希碰撞的几率（碰撞集合数据 ），一个确定性哈希函数往往不能保证在敌手模型（ ）下不被敌手精确选择作为哈希映射的前象。为了解决这个问题，我们随机选取哈希函数族中的一个函数称为通用哈希族（Universal family），且\nhttps://en.wikipedia.org/wiki/Universal_hashing\n剩余哈希引理(Leftover Hash Lemma)如果敌手获得了n比特密钥中的t个比特，我们可以生成一个比特左右的密钥，保证敌手对该密钥相关的信息一无所知。\n准确来说，我们可以提取一个长度渐进于（的最小熵）的均匀随机分布的变量。换句话说，敌手对X有一定的了解，但是对提取得到的值几乎一无所知。我们又称它为隐私放大，这是MASCOT的核心之一。\n令是在上的一个随机变量，且。令为一个2-universal哈希函数，如果则对于在上的且与无关，我们能得到：其中且与无关。\n是的最小熵，用来衡量的随机性，最小熵需要永远小于等于香农熵。注意是正确猜测的可能性。因此，最小熵衡量猜测的难度。\n是与的统计距离。\n\n\n\n\n\n\n\n\n\n香农熵：由热力学的熵引入到信息论中。\n香农把随机变量X的熵值定义如下，其值域为在这里b是对数所使用的底)，通常是2,自然常数e)，或是10。当b = 2，熵的单位是bit；当b = e，熵的单位是nat)；而当b = 10,熵的单位是Hart。\n熵（信息论）-wiki)\n","slug":"MASCOT前置知识","date":"2023-09-16T05:30:58.000Z","categories_index":"Crypto,多方安全计算,MASCOT","tags_index":"Crypto,Basic","author_index":"C4IN"},{"id":"02610888fe553149eda2045d277295dd","title":"多方安全计算介绍","content":"多方安全计算安全多方计算(MPC)已经从20世纪80年代的一种理论发展成为今天构建真实系统的工具。在过去的十年中，MPC已经成为理论和应用密码学中最活跃的研究领域之一。\n安全多方计算(MPC)的目标是使一组互不信任的独立数据所有者或任何公共第三方能够联合计算依赖于他们所有私人输入的函数。MPC与外包计算的不同之处在于，所有协议参与者都是参与执行协议的数据所有者。\n\nMPC支持保护隐私的应用程序，其中多个互不信任的数据所有者合作计算一个函数。在分布式的多方安全计算（Secure Multi-Party Computation , SMPC）环境中,含有隐私输入的两方或者多方参与者希望协作和交互式地计算一个目标函数f\\left(x_{1}, x_{2}, \\ldots, x_{n}\\right)=\\left(y_{1}, y_{2}, \\ldots, y_{n}\\right)，一旦计算完成，每一个参与者应该能够获取与之相对应的且不包含其他信息的输出。多方安全计算目的是构建一个安全协议，这个安全协议能允许多个互不信任的参与者在自己隐私输入上联合计算目标函数，同时确保输出的准确，甚至在面对不诚实行为时，能够保护和管控自己的隐私输入。\n\n\n\n\n\n\n\n\n\n\n\n姚氏百万富翁问题\n姚(1982)简单地介绍道:“两个百万富翁想知道谁更富有；然而，他们不希望无意中发现任何关于彼此财富的额外信息。”也就是说，目标是计算的布尔结果，其中是第一方的私有输入，是第二方的私有输入。\n\n拍卖安全问题\n在一次拍卖中，学习到的唯一出价信息是出价最高者的出价，显然可以得出所有其他出价都低于中标价，但无法得到其它竞标失败的出价。\n\n\n研究领域理论研究包括安全模型、可行性和复杂性等方面的研究。理论研究的目的是将来自理论研究的优雅的理论想法转化成解决现实世界安全问题的具体的SMPC协议。实用的多方安全协议注重于效率问题。SMPC理论协议涉及的研究和方法主要从计算成本、通信成本和交互轮数方面提高通用和特定协议的效率。\n面向应用的SMPC包括隐私集合计算、隐私保护机器学习、数据挖掘和安全基因组计算等领域的研究。\n所有这些协议都涉及到基本的构造块，如不经意传输、秘密共享、投币、同态加密、承诺方案、零知识证明等。这些构造块为理论和实用的SMPC奠定了基础。\nMPC的可行性在存在恶意的情况下依然可以安全地计算任何分布式计算任务。现在我们简要说明这些结果中最重要的部分，假设表示参与方的数量，表示可能被腐坏的计算方的数量的界限 (其中被腐坏方的身份未知)：\n\n对于 (即，当不到三分之一的参与方可能被腐坏时)，任何具有计算安全性的函数都可以实现具有公平性和有保证的输出的安全多方协议，假设一个具有认证信道的同步点到点网络，在信息论安全的前提下，假设信道也是私有的。\n对于 (即，在保证诚实多数的情况下)，对于任何具有计算和信息论安全性的函数，都可以实现具有公平性和保证输出的安全多方协议，假设各方也可以访问广播信道。\n对于(即当腐坏方的数量不受限制时)，可以实现安全的多方协议 (没有公平性或保证输出)。\n\n","slug":"多方安全计算基础","date":"2023-08-20T02:47:19.000Z","categories_index":"Crypto,多方安全计算","tags_index":"Crypto,MPC","author_index":"C4IN"},{"id":"2cbb891df5dd9e9d79cc9907faec0ead","title":"安洁莉卡&罗兰","content":"\n安洁莉卡最喜欢的诗\n\n痛苦啊，你便是我的唯一除了你，我皆无欲求痛苦啊，你忠实的陪伴我，直至现在也没有一丝改变当我的灵魂徘徊于深渊之底唯有你相伴在我身旁，守护着我我又怎能埋怨你呢痛苦啊，你绝不会从我身旁遁走我终于能表达对你的尊敬现在也认识到你的存在而你只是存于世，便那么美丽痛苦啊，你就像那从未离开我那贫苦的心之火炉旁的人一样比我那身为至爱的恋人还要多情我知道在我迈向死亡的那一天你会走进我内心的深处与我并排躺下\n\n小时候的罗兰，只有奶奶相伴。在奶奶的指导下，成为了都市里的一名收尾人。在千疮百孔的都市中，凭着“奇点”技术，人们克服了疾病，征服了大自然，却逐渐患上了心病，不再追求曾经炫目的梦想，任由自己的思想为”翼“所指导。在”翼“的庇佑下，巢中的羽过着安全、稳定的生活，而在巢之外的后巷，人们只为了活下去而活下去，人的生命根本不值一提，人们渴望着有朝一日能进入”翼“，能从眼前的地狱中解放。都市脆弱的秩序由收尾人来维持。这些收尾人或许受雇于巢，或许受雇于后巷势力，接手各种各样的工作，从送货到杀人，再到处理大型事件。在都市中，收尾人的工作机遇与危险并存，最忌讳的就是在收尾时产生情感。罗兰在查尔斯事务所中遇到了安洁莉卡。他来自后巷，而她来自翼的实验室。在一次次的生死中，两人相爱，并结了婚。罗兰兢兢业业干了那么多年，好不容易有了爱他的人，他们一定会很幸福不是……吗？\n\n\n\n\n\n\n\n\n\n“闯进我世界之人，最后成了我的全世界”\n“一码，归一码”\n早些年罗兰参加了烟霾战争，翼曾向他承诺，会优先安排巢的易居权。但，这是都市。翼玩了一次文字游戏，罗兰移居巢的梦想彻底破灭，只得住在相对安全的音之巷内。妻子怀孕了有了孩子，罗兰更加自责，害怕自己的妻子和孩子的安全会受到威胁。虽然没有住在巢中，安洁莉卡没有说什么，安洁莉卡非常爱罗兰，她看的透罗兰，她知道一旦出事罗兰便会怪自己。\n\n\n\n\n\n\n\n\n\n“说起来，那里的葱饼味道还不错？，回来的时候麻烦捎一个吧”“非常乐意为您效劳，在下去去就回”\n罗兰的老友奥利维耶打来通讯，说一个委托急缺人手，他便去帮忙了。等他带着妻子爱吃的葱饼回到家中时——只有坍塌的房子。一切都没了，他的妻子，与他的孩子，就这么没了。\n罗兰彻底崩溃了。\n\n\n\n\n\n\n\n\n\n“为什么，我那来之不易的幸福却能如此轻易地从我手中溜走……”\n“全都是我的错……”\n罗兰的世界破碎了。他开始调查实验室，屠杀了手指，向都市发起他最恶毒的诅咒。\n\n\n\n\n\n\n\n\n\n“越是沿往昔之路，尸山越发高耸。层峦叠嶂，不见前路”\n“不见前路。我仅是回首遥望。”\n墙对面传来的欢笑声，其中或许有属于我的风景，我遗落的风景。成团的漆黑独守空房。\n罗兰的故事，总给我一种触动。\n","slug":"Ruina","date":"2023-07-28T13:40:40.000Z","categories_index":"这都是些什么啊,Library of Ruina","tags_index":"闲","author_index":"C4IN"}]