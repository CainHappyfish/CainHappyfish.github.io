[{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"","slug":"test","date":"2023-09-17T12:56:56.000Z","categories_index":"","tags_index":"","author_index":"C4IN"},{"id":"e7f9c8c700d84e1b335913cf1672fdbf","title":"aurora主题的latex配置","content":"如何给aurora主题配置latex公式支持最近换了个主题，然后latex公式怎么搞都搞不好。找了好久终于找到了解决方法。\n进入博客根目录，下载hexo-renderer-kramed、hexo-math、hexo-filter-mathjax\nnpm install hexo-math --save\n## 卸载默认 markdown 渲染引擎 hexo-renderer-marked；若不卸载，会和新的引擎发生冲突（conflict）\n$ npm uninstall hexo-renderer-marked --save\n## 安装新引擎 hexo-renderer-kramed \n$ npm install hexo-renderer-kramed --save\n\n$ npm install hexo-filter-mathjax\n$ hexo clean\n然后修改kramed配置，解决冲突：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,\n\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n只要改这俩就行啦。\n然后在根目录下的_config.yml开启渲染：\n# MathJax Support\nmathjax:\n  tags: none # or 'ams' or 'all'\n  single_dollars: true # enable single dollar signs as in-line math delimiters\n  cjk_width: 0.9 # relative CJK char width\n  normal_width: 0.6 # relative normal (monospace) width\n  append_css: true # add CSS to pages rendered by MathJax\n  every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter\n  packages: # extra packages to load\n  extension_options: {}\n    # you can put your extension options here\n    # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail\n # MathJax\nmath:\n  engine: 'mathjax'\n  mathjax:\n    src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML\n在你的文章markdown文件中加入：\nmathjax: true\n\n然后试试：\n// inline \n$p=P\\left(A_{1}\\right)+P\\left(A_{2}\\right)+\\ldots+P\\left(A_{n}\\right)=p_{1}+p_{2}+\\ldots+p_{n}$\n\n// block\n$\n\\begin{aligned}\np &amp; =P\\left(A_{1} \\cup A_{2} \\cup \\cdots \\cup A_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1} \\bar{A}_{2} \\cdots \\bar{A}_{n}\\right) \\\\\n&amp; =1-P\\left(\\bar{A}_{1}\\right) P\\left(\\bar{A}_{2}\\right) \\cdots P\\left(\\bar{A}_{n}\\right)\n\\end{aligned}\n$\n结果：\n行内公式 inline equation\n公式块\n\n参考链接：\nhttps://cps.ninja/2019/03/16/hexo-with-latex/\nhttps://github.com/auroral-ui/hexo-theme-aurora/issues/55\nhttps://github.com/next-theme/hexo-filter-mathjax\n","slug":"aurora主题的latex配置","date":"2023-09-17T12:02:13.000Z","categories_index":"","tags_index":"头疼的配置问题","author_index":"C4IN"},{"id":"b3e44aa0e168a95d6665895a968d23a2","title":"随机变量的分布","content":"随机变量及分布函数变量的特点：\n\n变量的取值由随机试验的结果来确定;\n取各数值的可能性大小有确定的统计规律性.\n\n上述变量称为随机变量,它可以完整地描述试验结果，从而可用量化分析方法来研究随机现象的统计规律性。\n\n定义：设$E$的样本空间为$\\Omega$, 对于每一个 样本点$\\omega \\in \\Omega$, 都有唯一实数$X(\\omega)$与之对应, 且对于任意实数$  x $, 事件$\\{\\omega \\mid X(\\omega) \\leq x\\}$ 都有确定的概率，则称$  X(\\omega)  $ 为随机变量，简记为$X$ 。\n\n\n\n\n\n\n\n\n\n\\{\\omega: X(\\omega) \\leq x\\}=\\{X \\leq x\\} \\subset \\Omega且使$  P\\{X \\leq x\\}  $总有意义.\n随机变量的优越性：\n\n将样本空间数值化、变量化(但不同于通常非随机变量)\n可以完整地描述随机试验\n可用微积分等数学工具来解决随机问题\n\n分布函数从随机变量定义可见，对任一实数$  x  $都有实数$  P\\{\\omega \\mid X(\\omega) \\leq x\\}  $与之对应，即构造了一个函数。\n定义：设$X$是一个随机变量，$x$是任意实数，称函数\n\nF(x)=P\\{X \\leq x\\}=P\\{\\omega: X(\\omega) \\leq x\\}为随机变量$X$的分布函数，$F(x)$也记为$F_X(x)$。\n\n\n\n\n\n\n\n\n\n分布函数$ F(x) $的函数值表示事件 “随机点$  X  $落在$  (-\\infty, x]  $内” 的概率.\n\n$F(x) $的改变量\n\\Delta F=F(x+\\Delta x)-F(x)=P\\{x是事件“随机点X落在$ (x, x+\\Delta x] $ 内” 的概率。\n\n分布函数的性质：\n\n$F(x)  $为单调不降函数，即若$  x_{1}&lt;x_{2} $, 则有$  F\\left(x_{1}\\right) \\leq F\\left(x_{2}\\right) $。\n$ 0 \\leq F(x) \\leq 1$ , 且$\\lim _{x \\rightarrow+\\infty} F(x)=1, \\quad \\lim _{x \\rightarrow-\\infty} F(x)=0$\n$F(x)  $是右连续函数，即$F(x+0)=F(x)$\n\n从而有$  P\\{X=x\\}=F(x)-F(x-0) $\n离散型随机变量定义：如果随机变量$  X  $至多取可列无穷个数值:  $x_{1}, x_{2}, \\ldots $, 记$  p_{i}=P\\left\\{X=x_{i}\\right\\}$ , 且满足\n\n\\left\\{\\begin{array}{l}\n p_{i} \\geq 0, \\forall i \\\\\n \\\\\n\\sum_{i=1}^{\\infty} p_{i}=1\n\\end{array}\\right.称$X$是离散型随机变量。\n称$  \\quad p_{i}=P\\left\\{X=x_{i}\\right\\}, i=1,2, \\ldots $为 $X  $的分布律. 表示为\n\n\\begin{array}{c|c|c|c|c|c}\n X  &  x_{1}  &  x_{2}  &  \\ldots  &  x_{i}  &  \\ldots  \\\\\n\\hline P\\left\\{X=x_{i}\\right\\}  &  p_{1}  &  p_{2}  &  \\ldots  &  p_{i}  &  \\ldots \n\\end{array}贝努里试验和二项分布贝努里试验仅有两个基本事件 : $ A  $和$  \\bar{A}$ , 记$P(A)=p$\n令随机变量\n\nX=\\left\\{\\begin{array}{ll}\n1, & \\text { 若事件 } A \\text { 发生; } \\\\\n0, & \\text { 若事件 } A \\text { 不发生. }\n\\end{array}\\right.\n\\begin{array}{l}\n\\text { 则 } X \\text { 的分布律为 }\\\\\n\\begin{array}{c|c|c}\nX & 0 & 1 \\\\\n\\hline P\\left\\{X=x_{i}\\right\\} & 1-p & p\n\\end{array}\n\\end{array}定义：将试验E按下述条件重复进行n次\n\n每次试验的条件不变\n各次试验的结果互不影响。称这n次试验为n次重复独立试验。当试验E是贝努里试验，称这n次独立试验为n重贝努里试验，或称贝努里概型。\n\n在$  n  $重贝努里试验中,事件$  A  $发生概率为$  P(A)=p, 0&lt;p&lt;1 $, 则事件$  A  $发生的次数$ X  $的分布律为\n\nP\\{X=k\\}=C_{n}^{k} p^{k}(1-p)^{n-k}, \\quad k=0,1,2, \\cdots, n泊松分布定义：若随机变量  X  的分布律为\n\nP\\{X=k\\}=\\frac{\\lambda^{k}}{k !} \\mathrm{e}^{-\\lambda}, k=0,1,2, \\ldots ; \\quad(\\lambda>0)称  X  服从参数为$  \\lambda  $的泊松分布. 记为$  X \\sim P(\\lambda) $。 泊松分布的重要性在于：\n\n现实中大量随机变量服从泊松分布\n泊松分布可视为二项分布的极限分布   \n\n设随机变量序列$  X_{n} \\sim B\\left(n, p_{n}\\right), n=1,2, \\ldots $, 即有$P\\{X=k\\}=C_{n}^{k} p_{n}{ }^{k}\\left(1-p_{n}\\right)^{n-k}, \\quad k=0,1,2 \\cdots n$若$  \\lim _{n \\rightarrow \\infty} n p_{n}=\\lambda \\quad(\\lambda&gt;0) $, 则有$\\lim _{n \\rightarrow \\infty} P\\{X=k\\}=\\frac{\\lambda^{k}}{k !} e^{-\\lambda}, \\quad k=0,1,2, \\cdots$\n","slug":"随机变量的分布","date":"2023-09-14T02:14:41.000Z","categories_index":"概率论与数理统计","tags_index":"","author_index":"C4IN"},{"id":"8eccb33eadcfc07f260da794eb4df1d5","title":"随机事件的独立性","content":"事件的独立性\n$P(B \\mid A)=P(B\\mid \\bar A)$，则A与B相互独立。（充要条件）\n设A，B是试验E的两个事件,若满足\n\nP(AB)=P(A)P(B)则事件A与B相互独立。\n上述两个公式是等价的，第一个式子常用来判断事件的独立性，而第二个式子常用来计算概率。当然也可以将式子转化为第二个式子来证明事件相互独立。若A与B相互独立，则他们的对立事件也相互独立，即$A,\\bar B$等也相互独立。\n定义 设$  A_{1}, A_{2}, \\ldots, A_{n}  $为试验$  E  $的事件， 若对任意的$  s(1&lt;s \\leq n)  $及$  1 \\leq i_{1}&lt;i_{2}&lt;\\ldots&lt;i_{s} \\leq   n $, 有\n\nP\\left(A i_{1} A i_{2} \\ldots A i_{s}\\right)=P\\left(A i_{1}\\right) P\\left(A i_{2}\\right) \\ldots P\\left(A i_{s}\\right)成立，则称事件$  A_{1}, A_{2}, \\ldots, A_{n}  $相互独立.\n若对一切$  1 \\leq i_{1}&lt;i_{2} \\leq n $, 有\n\nP\\left(A i_{1} A i_{2}\\right)=P\\left(A i_{1}\\right) P\\left(A i_{2}\\right)成立，则称事件$  A_{1}, A_{2}, \\ldots, A_{n}  $两两独立。\n\n\n\n\n\n\n\n\n\nn个事件相互独立比两两独立更强的结论。\n定理：若n个事件$  A_{1} ， A_{2} ， \\ldots, A_{n}  $相互独立， 则将$  A_{1} ， A_{2} ， \\ldots, A_{n}  $中的任意多个事件换成它 们的对立事件后，所得到的个事件仍然相互独立。\n\n\n\n\n\n\n\n\n\n若  n  个事件$ A_{1}, A_{2} ， \\ldots, A_{n}  $相互独立，将这  n  个事件任意分成  k  组，同一个事件不能同时属于 两个不同的组，则对每组的事件进行求和、积、差、 对立等运算所得到的 k 个事件也相互独立.特别地，若  A ， B ， C  为三个相互独立的事件，则其中 任意两个事件的和、差、交及其逆与另一个事件 或其逆都是相互独立的。\n考虑$  A_{1}, A_{2}, \\ldots, A_{n} $至少有一个发生 的概率，其中  $0&lt;P\\left(A_{i}\\right)=p_{i}&lt;1 $，则：\n(1) 若$  A_{1}, A_{2}, \\ldots, A_{n}  $互不相容，由概率 的有限可加性可得\n$p=P\\left(A_{1}\\right)+P\\left(A_{2}\\right)+\\ldots+P\\left(A_{n}\\right)=p_{1}+p_{2}+\\ldots+p_{n}$\n(2) 若$  A_{1}, A_{2}, \\ldots, A_{n}  $相互独立，由对偶原理可得\n\n\n\\begin{aligned}\np & =P\\left(A_{1} \\cup A_{2} \\cup \\cdots \\cup A_{n}\\right) \\\\\n& =1-P\\left(\\bar{A}_{1} \\bar{A}_{2} \\cdots \\bar{A}_{n}\\right) \\\\\n& =1-P\\left(\\bar{A}_{1}\\right) P\\left(\\bar{A}_{2}\\right) \\cdots P\\left(\\bar{A}_{n}\\right)\n\\end{aligned}特别，当$  P\\left(A_{i}\\right)=p, i=1,2, \\ldots, n $, 有\n\n\\begin{array}{l}\n\\left.P\\left(A_{1} \\cup A_{2} \\cup \\ldots \\cup A_{n}\\right\\}\\right)=1-(1-p)^{n} \\\\\nP\\left\\{A_{1} \\cup A_{2} \\cup \\cdots \\cup A_{n}\\right\\}=\\lim _{n \\rightarrow \\infty}\\left[1-(1-p)^{n}\\right]=1\n\\end{array}","slug":"随机事件的独立性","date":"2023-09-12T00:41:58.000Z","categories_index":"概率论与数理统计","tags_index":"","author_index":"C4IN"},{"id":"e8805eec5bdd2acbc81f5c8e275b0c0a","title":"Java类和对象","content":"Java类和对象类的变量描述对象的属性，类的方法体现对象的行为。封装在类中的这些数据的变量和方法，为对象的创建提供了模板。对象之间的交互作用是通过对象的消息机制实现的。所谓消息是对象对其他或者自身方法的访问，一个消息的产生就是一个对象方法的调用。类和对象是面向对象程序设计中的基本概念，也是编程方法的基础。类就是Java的执行单位。Java运行的就是Java类本身。\nOOP的最重要的好处之一是对数据和操作该数据的代码的封装，通过类来完成封装性。在创建一个类时，你正在创建一种新的数据类型，不但要定义数据的属性，也要定义操作数据的代码。方法定义了对该类数据相一致的控制接口。通过类的方法来使用类，而没有必要担心它的实现细节或在类的内部数据实际上是如何被管理的。既然细节被隐蔽，当需要时，它的内部工作可以被改变。只要你的代码通过类的方法来使用它，内部的细节可以改变而不会对类的外部带来负面影响。\n\n对象对象是现实世界事物的模型化。用变量来表示状态，用方去来实现行为。对象的变量组成了对象的中心或核，而方法是围绕在变量四周的。\n封装:某一对象的变量对程序中的其它的对象而言是隐藏的，它是在这个对象方法的保护监理之下。\n\n消息消息是软件对象之间相互作用和互相联系。对象的行为由方法来实现，消息传递是对象之间进行交互的主要方式。\n\n接收消息的对象(目标对象)\n接收者采用的方法(目标方法)\n方法所需传递的参数\n\n类类定义了对象的类型。包括对象内部的数据，它是对象的寺性，和对象对自己的数据上的操作功能。因此类就是对象的模板。类是某种对象共有的状态和行为的原 型。一个类可以有许多的对象，每一个对象都是这个类的一个实例，它们也就都具有相同的特征。\n类的创建一个类包括三个部分：\n\n类声明\n\n类成员\n\n类的构造器（方法）\nclass &lt;Declaration&gt;&#123;\n\n    &lt;classBody&gt;\n\n&#125;\n\n\n类的一般声明形式：\n[public] class &lt;clsName&gt; extends &lt;supCls&gt; implements&lt;intf&gt;\nclass是表示创建类的关键字\n&lt;clsName&gt;是Java合法标识符[public]是可选项，表示该类是public类;类的可选项还有abstract, final等等;extends &lt;superCls&gt;则是继承性表示，该类继承了类&lt;superCls&gt;\nimplements &lt;intf&gt;则是对接口实现表示，该类实现了接口&lt;intf&gt;\n类体定义\n成员变量：在类中创建的变量，表示对象属性\n成员方法：类的方法表示对象的行为或能力\n类的构造器（方法）：为创建类的实例所使用\n\nclassDeclaration &#123;\n    &lt;memberVariableDeclaration&gt;\n    &lt;memberMethodDeclaration&gt;\n    &lt;classStructorDeclaration&gt;\n&#125;\n成员变量\n在类中创建的变量，表示对象属性\n\n作用域在类中是全局的，能被类中所有方法所访问\n\n在创建时有初始化值\n&lt;type&gt; variableList = initialValue;\n\n\n常用修饰符：\n\n访问权限控制：\npublic：公开，谁都能访问\nprotected：\nprivate：\n\n使用限制\nfinal：\n使用修饰符final修饰的变量就像常量一样地使用，称其为常量符号。常量符号数据只能读取，不能改变。通常常量符号标识符全用大写字母，单词间用“_”分隔。\nfinal int MAX_MONTH = 12;\nfinal int MAX_DAY = 31;\nfinal int MAX_WEEK = 7;\nstatic：\ntransient：\nvolatile：\n\n\n成员方法[accessControl] returnType methodName(paraList)\n[accessControl]是可选项，为访问控制修饰符，限定访问权限。\nreturnType是方法返回数据类型，它表示方法返回时返回数据的类型。\nmethodName是方法名，它是Java合法标识符\nparaList是方法参数列表，表示方法调用时所带参数。称为形式参数。\nint getMax(int a, int b)\nvoid setData(int x, int y)\n方法体由语句及语句块组成，包含有：\n\n局部变量声明\n流程控制语句\n语句块\nreturn（看情况）\n\n方法调用时的参数传递\n方法在被调用时，其参数的数据传递是值传递，即实际参数传值给形式参数。\n形式参数是简单类型，在方法调用时，实际参数将其存储单元的数据赋值给形式参数。\n形式参数是引用类型，在方法中，引用类型的参数没有发生引用的改变，则形式参数对引用中的变量值改变自然会影响到实际参数引用中变量的值。\nPoint pi=new Point(1,2);void setRefer1(Point p)    &#123;\n    p.x = 10;\n    p.y = 20;\n&#125;\nsetRefer1(pi)\n参数p是引用类型，其成员的x,y值发生改变，会影响调用的实参，即函数结束后成员x和y的值改变。\nPoint pi=new Point(1, 2)void setRefer2(Point p) &#123;\n    p= new Point();\n    p.x = 10;\n    p.y = 20;\n&#125;\nsetRefer2(pi)\n参数p是引用类型，改变引用，其变量x,y值发生改变，不会影响调用的实参，函数调用结束后pi的成员值不变。\n方法过载在同一个类中创建的具有相同方法名，但是参数不同的方法。方法过载中的方法由调用时的实参决定调用的方法是哪个。\n\n数量不同\n数量相同，但是对应的类型不同\n\n类的构造方法每一类都有自己的构造方法，或者称为类的构造器。构造方法是用来创建一个类的实例的。\n构造方法使用类名作构造方法名，构造方法具有有参数和语句体，但没有返回类型的声明。如果有返回类型声明，则此方法就再不是构造方法，而成为一个一般的成员方法。构造方法不是类的成员方法，所以不能用对象调用它。构造方法的调用是由new运算符实现。\n\n\n\n\n\n\n\n\n\n\n构造方法返回的是这个类的实例的引用\n\n构造方法中的语句实现对成员变量的初始化\n\n构造方法的方法过载。一个类可以有多个构造方法\n\n构造方法之间通过this()形式相互调用\n\n\n默认构造方法：指不带参数的构造方法，该方法可以有语句，也可以没有语句\n非默认构造方法：指带参数的构造方法\n类创建时没有创建构造器，则在编译时编译器自动为该类添加一个默认构造器，即没有创建构造器的类可以直接使用默认构造器。\n类创建时如果有任何构造器被创建，则在编译时编译器不再为该类创建默认构造器。即创建了构造方法的类，不自动有一个默认的构造方法，或者说默认构造器失效，除非也创建一个不带参数的构造器。\n类成员和实例成员类成员见另一篇文章 ’static的用法‘。\n实例成员：通过创建实例才能访问和使用的成员，创建对象，由对象访问，如p.x=10。实例成员不能用类名直接访问，比如Point.x访问是不合法的。\n对象创建和使用对象：是一个变量，它的存储开销是一个地址存储单元。\n实例：是在存储空间分配的存储堆。是垃圾回收的目标。\n引用：对象通过它存储的实例的起始地址对实例实现访问。\n对象的生命周期:创建、使用和销毁三个阶段。\n创建:分两步。\n\n声明:\nPoint p;\n\n实例化:通过new运算符调用构造器，通过赋值=对这个实例引用。\np = new Point();\n\n对象使用：\n通过对象名对成员的访问，注意这里是对象名不是类名：\np.x=100;\nint temp = p.getData();\n\n销毁：\n垃圾回收:实例开销的回收。\n由JVM自动完成。\n调用finalize()方法处理。\nJava程序运行时系统通过垃圾收集，周期性地释放不再被对象引用所占用的内存，完成对象的清除.\nfinalize方法：\nJava在对象作为垃圾被收集前，自动调用对象从Object类继承来的finalize()方法，清除自己所占用的资源。该方法声明的格式:\nprotected void finalize() throws throwable &#123;\n//clean up code for this class\n    super.finalize();\n&#125;\n\n\nclass Point &#123;\n    int x,y;\n    Point(int a, int b) &#123;\n        x = a;\n        y = b;\n    &#125;\n    Point() &#123; \n        this(0.0);\n    &#125;\n    void setData(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n        &#125;\n&#125;\n","slug":"Java类和对象","date":"2023-09-05T06:23:22.000Z","categories_index":"编程,java","tags_index":"","author_index":"C4IN"},{"id":"f8ba7f6ff4d891dad073909bcfae5e3c","title":"条件概率","content":"概率论笔记（\n\n事件的独立性$P(B \\mid A)=P(B\\mid \\bar A)$，则A与B相互独立。（充要条件）\n条件概率将已知事件B发生的条件下，事件A发生的可能性的客观度量称为条件概率，记为$P(A|B)$。\n定义:设A，B是随机试验E的两个随机事件，且$P(B) &gt;0$，称\n\nP(A \\mid B)=\\frac{P(A B)}{P(B)}为在事件B发生的条件下,事件A发生的条件概率。\n\n非负性：$1 \\geq P(B \\mid A) \\geq 0$\n归一性：$P(\\Omega \\mid A)=1$\n可列可加性：$P\\left(\\bigcup_{i=1}^{\\infty} B_{i} \\mid A\\right)=\\sum_{i=1}^{\\infty} P\\left(B_{i} \\mid A\\right)$\n\n\n\\begin{array}{l}\nP\\left(B_{1} \\cup B_{2} \\mid A\\right)=P\\left(B_{1} \\mid A\\right)+P\\left(B_{2} \\mid A\\right)-P\\left(B_{1} B_{2} \\mid A\\right) \\\\\nP(\\bar{B} \\mid A)=1-P(B \\mid A) \\\\\nP\\left(B_{1}-B_{2} \\mid A\\right)=P\\left(B_{1} \\mid A\\right)-P\\left(B_{1} B_{2} \\mid A\\right)\n\\end{array}一般来说，条件概率与无条件概率之间的大小无确定关系。若$B \\sub A$：\n\nP(B \\mid A)=\\frac{P(A B)}{P(A)}=\\frac{P(B)}{P(A)} \\geq P(B)对于条件概率$P(A|B)$，需要注意几点：\n\n条件概率较原来的概率发生了变化（$P(A) \\neq P(A \\mid B)$）。\n\n条件概率与积事件的概率有别。条件概率有先后次序之分，积事件无先后次序之分。\n\n条件概率可通过原来的概率计算得到:\n\nP(A \\mid B)=\\frac{P(A B)}{P(B)}, \\quad P(B \\mid A)=\\frac{P(A B)}{P(A)}\n\n乘法公式设$P(B)&gt;0$，有\n\nP(A B)=P(B) P(A \\mid B)同理，$P(A)&gt;0$，有\n\nP(A B)=P(A) P(B \\mid A)更一般，若$P\\left(A_{1} A_{2} \\ldots A_{n-1}\\right)&gt;0$，有\n\n\\begin{array}{l}\nP\\left(A_{1} A_{2} \\ldots A_{n-1} A_{n}\\right)=\nP\\left(A_{1}\\right) P\\left(A_{2} \\mid A_{1}\\right)\\cdot \\ldots \\cdot P\\left(A_{n} \\mid A_{1} A_{2} \\ldots A_{n-1}\\right)\n\\end{array}\n\n\n\n\n\n\n\n\n注：乘法公式是概率计算中的重要公式.关键是分清题目中所给数据是否为条件概率.。\n全概率公式事件的概率计算可能很复杂，有时可以采用借助于一组基本事件组的方法.。\n\n\n\n\n\n\n\n\n\n定义：设$\\Omega$为随机试验$E$的样本空间，$B_1,B_2,\\cdots,B_n$为E的一组事件，若\n\n(1)  B_{i} \\cap B_{j}=\\phi, i \\neq j\\\\\n(2)  B_{1} \\cup B_{2} \\cup \\ldots \\cup B_{n}=\\Omega称$B_1,B_2,\\cdots,B_n$为$\\Omega$的一个有限划分（或完备事件组）。\n全概率公式：\n设随机试验E的样本空间为$\\Omega,A\\sub\\Omega,B_1,B_2,\\cdots,B_n$为$\\Omega$的一个有限划分，且$P(B_i)&gt;0,i=1,2,\\cdots,n$，则有\n\nP(A)=\\sum_{i=1}^{n} P\\left(B_{i}\\right) P\\left(A \\mid B_{i}\\right)\n\n\n\n\n\n\n\n\n该公式常用在预测推断中，称为事前概率。\n解题步骤：\n\n假设事件，证明有限划分\n计算$P(B_i),P(A\\mid B_i)$（概率大于0）\n公式（4分）\n给出结果k\n\n贝叶斯公式事后概率：$P\\left(B_{i} / A\\right)=? \\quad i=1,2,3,4$\n贝叶斯问题：把事件A看成“结果”把事件$B_1,B_2,\\cdots，B_n$看成导致该结果的可能“原因”，在已知A发生的条件下，去找出最有可能导致它发生的“原因”。\n设随机试验E的样本空间为$\\Omega,a\\sub \\Omega,B_1,B_2,\\cdots,B_n$为$\\Omega$的一个有限划分，且$P\\left(B_{i}\\right)&gt;0, i=1,2, \\ldots, n$，则有\n\nP\\left(B_{j} \\mid A\\right)=\\frac{P\\left(B_{j}\\right) P\\left(A \\mid B_{j}\\right)}{\\sum_{i=1}^{n} P\\left(B_{i}\\right) P\\left(A \\mid B_{i}\\right)}\n\n\n\n\n\n\n\n\n分子是分母中的一种情况\n例题\n$P(A)=P(B)=\\frac 1 3,P(A|B)=\\frac 1 6,$求$P(\\bar A \\mid \\bar B)$。\n\n\n\n\n\n\n\n\n\n注意 ，没有说明A，B相互独立，计算乘法时不能简单的将概率相乘\n\nP(\\bar B)=1-P(B)=\\frac 2 3\\\\\n根据乘法公式, P(AB)=P(A)P(A|B)=\\frac 1 {18}\\\\\nP(\\bar A \\bar B)=P({\\bar A\\cup \\bar B)})\\\\\n=1-P(A\\cup B)=1-(P(A)+P(B)-P(AB))\\\\\n=1-\\frac {11} {18}=\\frac 7{18}\\\\所以有\n\nP(\\bar A \\mid \\bar B)=\\frac {P(\\bar A \\bar B)}{P( \\bar B)}=\\frac 7 {12}\n\n","slug":"条件概率","date":"2023-09-05T00:16:13.000Z","categories_index":"概率论与数理统计","tags_index":"概率论","author_index":"C4IN"},{"id":"ee304ea14cdfef400724bb1ab6bff757","title":"java异常处理","content":"Java异常处理在Java中，异常处理是一种机制，用于处理程序运行时可能出现的错误或异常情况，以便程序能够优雅地处理这些问题而不会崩溃。\n\ntry-catchtry 用于包装可能会引发异常的代码块，而 catch 用于捕获并处理异常。在 try 块中放置的代码如果发生异常，程序将跳转到匹配的 catch 块来处理异常。可以使用多个 catch 块来捕获不同类型的异常，以便根据异常类型采取不同的处理措施。\nfinally 块用于包装一些无论是否发生异常都必须执行的代码。通常在这里执行资源的释放或清理操作。\n throw 关键字用于手动抛出异常，通常在自定义异常类中使用。\ntry &#123;\n    // 可能引发异常的代码\n&#125; catch (ExceptionType e) &#123;\n    // 处理异常的代码\n&#125; finally &#123;\n    // 是否发生异常都必须执行的代码\n&#125;\n异常类（Exception）异常是由Java提供的预定义异常类或自定义的异常类表示的。例如，ArithmeticException 表示数学运算异常，IOException 表示输入输出异常等。\n我们也可以自定义异常类：\npublic class CustomException extends Exception &#123;\n    public CustomException(String message) &#123;\n        super(message);\n    &#125;\n&#125;\n示例代码这是一次java作业的代码：\n\n\n","slug":"java异常处理","date":"2023-09-03T02:32:19.000Z","categories_index":"编程,java","tags_index":"","author_index":"C4IN"},{"id":"f166a5c525f4808e553d5963a7e1b89d","title":"概率论初步","content":"概率论初步随机现象的各个结果出现的可能性大小不依人们的主观意志转移.结果的不确定性：试验的结果不止一个，即每次试验的结果可能不同。进行大量重复观察时，可观察出出现各种结果呈现某种规律：统计规律性.\n概率论与数理统计：研究随机现象的统计规律性的一门数学学科.\n\n确定性现象的特点 可事前预言\n非确定性现象的特点：不可事前预言\n随机事件与随机变量随机事件与随机变量随机试验是对随机现象所进行的观察和实验，具有如下特征：\n\n可在相同条件下重复进行\n事前可明确试验的全部可能结果\n试验前不能预言将出现哪一个结果\n\n在一定条件下基于一定的试验目的进行试验，称试验的每一个可能发生也可能不发生的事情为随机事件，简称事件，通常用大写字母来表示。\n\n必然事件 \n随机试验中肯定发生的事件,记为\n\n不可能事件 \n随机试验中肯定不发生的事件,记为\n\n基本事件 \n在一次试验中必发生一个且仅发生一个的最简单事件（不能再分解）\n\n复合事件\n由若干基本事件组合而成的事件\n\n\n样本空间和随机变量将联系于试验的每一个基本事件，用包含一个元素ω 的单点集来表示（一一对应）\n\n基本事件的对应元素全体所组成的集合：\n  \n称为试验的样本空间，样本空间的元素称为样本点.\n若一个基本事件对应的样本点是，对任意事件A，若 , 称事件A发生，否则称 A 没有发生。\n复合事件：由若干基本事件组成的随机事件。\n\n\n\n\n\n\n\n\n\n复合事件是样本空间的子集\n样本空间Ω对应的事件是必然事件空集 \\empty对应的事件是不可能事件\n随机事件的关系及运算随机事件的关系及运算实质上对应集合的关系及运算\n\n包含关系\n若即事件A 发生,必然导致事件B发生，则称事件B 包含事件A , 或A 是 B 的子事件\n\n\n\n\n\n\n\n\n\n从集合角度来看：\n对任意事件，有\n如果两个事件互相包含,称为两事件相等。\n\n和事件\n事件A与B的和事件记为 。\n从集合角度：或\n从事件角度： 是事件与至少有一个发生。\n\n表示事件组至少有一个发生。\n\n积事件\n事件A与B 的积事件记为 或。\n从集合角度：且\n从事件角度：是事件与同时发生\n\n\n\n​        表示事件组同时发生。\n\n互不相容事件\n若 ,称A、B为互不相容或互斥事件,即A、B不可能同时发生。显然, 与任何事件互不相容。\n中任意两个互不相容，称互不相容（两两互斥），其中任意有限个事件互不相容。\n\n对立事件（逆事件）\n若, 且 Cannot read properties of null (reading '4')Math input error,称 A、B 互为对立事件（逆事件）, 记为\n从集合角度：\n从事件角度：是事件不发生\n显然，在一次事件中和必发生且仅发生一个，非此即彼。\n\n差事件\n事件A与B 之差 记为－。\n从集合角度：但\n从事件角度：是事件发生并且不发生\n\n\n\n\n\n\n\n\n\n有\n\n完备事件组\n若两两互斥，且，则称为完备事件组，或称为的一个有限划分。\n\n随机事件（集合）运算律\n\n交换律：\n\n结合律：\n\n分配律：\n\n德 · 摩根律：\n\n吸收律：则于是有\n\n\n\n\n概率随机事件发生的可能性大小是一个客观存在的量，概率是对随机事件发生可能性大小的客观度量，事件A 出现的概率（Probability）记为。\n频率在相同条件下，进行n次试验，事件A 发生了m次，称比值为事件A 发生的频率。频率在一定程度上反映了事件发生可能性的大小，可能因人因时或试验次数的变化而改变。在一定条件下，频率稳定于概率（稳定性）。\n古典概率设E是一个随机试验,若它满足以下两个条件：\n\n仅有有限多个基本事件\n每个基本事件发生的可能性相等\n\n则称E为古典概型试验。\n\n\n\n\n\n\n\n\n\n设试验E 为古典概型试验。是基本事件，则由：所含的基本事件个数基本事件总数所含样本点的数目样本空间的样本点总数所确定的概率称为事件A 的古典概率。在古典概率的计算中常用到排列组合的知识，如乘法原理、加法原理等等。\n古典概型有三个性质：\n\n对任意事件，有\n\n\n\n若互补相容，则\n\n\n概率的公理化定义设E的样本空间为W，对于E =的每个事件A 均对应于唯一一个实数，记为其对应规则为\n\n非负性：对任一事件A，有\n\n\n\n若互补相容，则\n\n\n则称是A的概率。\n古典概率是公理化定义的特例。\n\n\n\n\n\n\n\n\n\n由公理化定义可以得到：\n\n不可能事件的概率为0\n\n有限可加性：若试验E的事件组互不相容，则有\n\n对立事件的概率之和为1\n\n概率单调性：若事件A和B满足A\\sub B, 则有\n\n一些结论\n\n\n概率加法原理\n 对试验E的任意两个事件A和B有：\n例题\n将两颗均匀骰子抛掷一次,求两颗骰子点数之和不为7,11的概率。\n\n\n\n\n\n\n\n\n\n错解：将样本空间定义为：\n错因是每个样本点出现的概率不等，比如2和3的概率就不相同。\n设： ，A={两颗骰子点数之和为7，11}\n，所求概率。\n\n\n\n一个鸽场养了n 只鸽子，每只鸽子都等可能的飞入N 个鸽笼中的任意一个去住（）求以下事件发生的概率。\n\nA={指定的n 个鸽笼各有一只鸽子去住}\nB={恰好有n 个鸽笼，每个各有一只鸽子}\nC={某指定的鸽笼中有只鸽子}\n\n由乘法定理可以知道基本事件的总数为。\n（1）n个位置给n只鸽子，每个鸽笼有且只有一只鸽子，第i个位置有n-i+1种选择，故（2）因为恰好有n个鸽笼，故从N中选择n个的选法有种，住法和（1）相同，故（3）从n只鸽子中选m只有种选法，剩下的鸽笼可住可不住，剩下的鸽子有种住法所以\n\n\n","slug":"概率论初步","date":"2023-09-02T12:20:14.000Z","categories_index":"概率论与数理统计","tags_index":"","author_index":"C4IN"},{"id":"af5b7b140c3f656ff60a269d72084da5","title":"java流程控制和数组","content":"Java语言中的流程控制语句提供了控制程序执行顺序的手段。流程控制是程序代码的重要部分。流程控制语句分为：分支语句、循环语句、异常处理语句和跳转语句。\n\n\n分支语句if-else\nif (condition1) &#123;\n    // 如果 condition1 为真，执行这里的代码块\n&#125; else if (condition2) &#123;\n    // 如果 condition2 为真，执行这里的代码块\n&#125; else if (condition3) &#123;\n    // 如果 condition3 为真，执行这里的代码块\n&#125; else &#123;\n    // 如果以上条件都不满足，执行这里的代码块\n&#125;\nswitchswitch (intexpression)&#123;\ncase int1:\n    &lt;statement or block (1)&gt;\n    break;\ncase int2:\n    &lt;statement or block (2)&gt;\n    break;\ndefault:\n    &lt;statement or block(d)&gt;\n    break;\n&#125;\n循环语句whilewhile (expressBool)&#123;\n    statements;\n    [iteration;]\n&#125;\ndo-whiledo &#123;\n    statements;\n    [iteration;]\n&#125;while (expressBool);\n执行顺序是：\n\n执行初始化initalization(如果有);执行循环体statements\n先执行迭代部分iteration(如果有)，再计算表达式expressBool的值\n若expressBool值为true，则返回到2\n若expressBool值为false，则终止do-while循环\n\nforfor(initalize; condit; iterat) &#123;\n    statements;\n&#125;\nbreak, continuebreak语句用于循环结构中，当程序执行break语句时，程序流程就结束循环break语句也可以带语句标记，它的作用是结束该语句标记的语句块。break语句使用格式如下:\nbreak [outerLabel];\ncontinue语句用于循环结构中，当程序执行contiune语句时，程序流程就结束本次循环，充当了循环体的最后一条语句作用。continue语句也可以带语句标记，它的作用是结束该语句标记的外层循环的本次循环。continue语句使用格式如下:\ncontinue [outerLabel];\n\n使用标签 outerLoop 跳出外层循环，从而结束整个循环的执行。\nouterLoop:\nfor (int i = 0; i &lt; 5; i++) &#123;\n    innerLoop:\n    for (int j = 0; j &lt; 5; j++) &#123;\n        if (i * j &gt; 6) &#123;\n            break outerLoop; // 使用标签跳出外层循环\n        &#125;\n        System.out.println(i + &quot; * &quot; + j + &quot; = &quot; + (i * j));\n    &#125;\n&#125;\n\n数组在Java中，数组是引用类型。数组类型是一种有序数据的集合，数组中在每一维上的元素具有相同的数据类型。数组通过数组名和它的下标对数组元素访问，数组元素的下标不能越界。数组是一个对象，数组声明不能创建对象本身，而创建一个引用。数组元素由new语句或数组初始化软件动态分配。\n数组声明Java的数组声明采用与C语言类似的形式。数组可分为一维数组和多维数组。它们的声明的形式为:\ntype arrayName[][].….[];\n或另一等价形式:\ntype[][..][] arrayName;\ne.g.\nint count[];            //  一维整型数组count\nchar ch[][];            //  二维字符型数组ch\nfloat[] fNum;            //  一维浮点型数组fNum\n数组实例化在Java语言中，数组的声明是不能确定数组大小。数组的实例化即存储单元的分配是由new运算符实现。\narrayName = new type [arraySize1][][]…[];\n数组通过数组名和它的下标对数组元素访问，数组元素的下标不能越界。数组实例化示例:\nint[]a = new int[3];\n数组a有元素：a[0], a[1], a[2]，三个元素的值都为0。\n数组在创建时，也可显式初始化。例: \nint[]a = &#123;1,2,3&#125;;\n数组a的三个元素的值分别为1，2，3。\n数组实例化后就有了确定的元素,每个数组有一个属性length,其值就是这个数组的元素的数量。例: a.length的值为3。\n多维数组Java编程语言没有提供多维数组。它是通过创建数组的数组(和数组的数组的数组)。数组通过数组名和它的下标对数组元素访问，数组元素的下标不能越界。数组是一个对象，数组声明不能创建对象本身，而创建一个引用。数组元素由new语句或数组初始化软件动态分配。\n虽然在声明数组的格式中，允许方括号在数组名的左边或者石边，但这种方式不适合数组句法的其它部分，必须首先将低位维初始化，再能对它后面的各位依次初始化。利用对每维元素的分步初始化，可以创建非知矩形数组的数组。\n// 声明一个三维整数数组\nint[][][] threeDArray = new int[2][3][4];\n\n// 初始化三维数组\nthreeDArray[0][0][0] = 1;\nthreeDArray[0][0][1] = 2;\n// ...\n\n// 声明并初始化三维数组\nint[][][] anotherThreeDArray = &#123;&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;, &#123;&#123;5, 6&#125;, &#123;7, 8&#125;&#125;&#125;;\n\n// 访问三维数组\nint value = threeDArray[1][2][3]; // 访问第二维度的第三行第四列的元素\n字符串字符串是一串字符组成的数据，并用&quot;&quot;包括起来。字符串常量是String类型的对象，类String是Java语言的基础数据类型，它具有一定的特殊性。Java编译器在对字符串数据与其它类型数据使用“+”运算符连接操作编译时，总是首先将其它类型数据转换为字符串类型，然后再进行字符串连接。\n&quot;Age: &quot;+18 == &quot;Age: 18&quot;\n相关方法char charAt(int where)\nvoid getChars(int sourceStart, int sourceEnd, char target[], int targetstart)byte[] getBytes()\nchar[] tocharArray( )boolean equals(Object str)\nboolean equalslgnorecase(String str)boolean startsWith(String str)\nboolean endsWith(String str)int indexof(int ch)\nint lastindexOf(int ch)\nstring substring(int startIndex)\nstring substring(int startIndex, int endIndex)\n字符串与基本数据的转化：\nString to lnteger\npublic static int parselnt(String s)\nlnteger to String\npublic static String valueOf(int n)\nStringBuffer在Java中，StringBuffer 是一个用于操作可变字符串的类。与 String 不同，StringBuffer 允许你修改字符串的内容，而不必创建新的字符串对象。这对于需要频繁修改字符串的情况非常有用，因为 String 对象是不可变的，每次修改都会创建一个新的字符串对象。\n以下是 StringBuffer 类的基本用法和一些常用方法：\n创建 StringBuffer 对象：\njavaCopy code\nStringBuffer sb = new StringBuffer();\n或者使用初始字符串创建 StringBuffer 对象：\njavaCopy code\nStringBuffer sb = new StringBuffer(&quot;Hello&quot;);\n常用方法：\n\nappend(String str)： 将指定的字符串追加到 StringBuffer 的末尾。\n\njavaCopy code\nsb.append(&quot;World&quot;);\n\ninsert(int offset, String str)： 在指定位置插入字符串。\n\njavaCopy code\nsb.insert(5, &quot;Java&quot;);\n\ndelete(int start, int end)： 删除指定范围内的字符。\n\njavaCopy code\nsb.delete(0, 5); // 删除前五个字符\n\ndeleteCharAt(int index)： 删除指定位置的字符。\n\njavaCopy code\nsb.deleteCharAt(5); // 删除第六个字符\n\nreplace(int start, int end, String str)： 用新的字符串替换指定范围内的字符。\n\njavaCopy code\nsb.replace(0, 5, &quot;Hola&quot;); // 将前五个字符替换为 &quot;Hola&quot;\n\nlength()： 返回当前字符串的长度。\n\njavaCopy code\nint len = sb.length();\n\ntoString()： 将 StringBuffer 对象转换为 String 对象。\n\njavaCopy code\nString result = sb.toString();\n","slug":"java流程控制和数组","date":"2023-09-01T12:49:52.000Z","categories_index":"编程,java","tags_index":"java","author_index":"C4IN"},{"id":"a8aa18bf0cb5c42542c071a3bedb754a","title":"java语言基础","content":"我超，java\n\nJava程序的基本结构Java语言的源程序是一个或多个以.java为扩展名的文件，Java源程序中可包含三个基本部分:\n\n一个包声明package语句(可选)\npackage database;\n\n包是类和接口的集合，即为类库\n用类库管理类，方便对类和接口管理，减少类名、接口名之间的重名问题\nJava的类都包含在类库中,package语句为类、接口(或者说是字节码文件)来指定所属的类库(包)。\n在一个源程序中，只能有一个包声明语句，且是程序的第一条语句。\n\n\n任意数量的引入import语句(可选)\nimport java.applet.Applet;\n\n源程序中可以有任意条import引入语句\n\n当源程序在编译时，会将需要的在引入语句中的类引入到程序中\n\nimport语句在包语句后，所有类或接口之前import语句有两种形式:\n import &lt;packagename&gt;.&lt;classname&gt;        // 引入&lt;classname&gt;\n import &lt;packagename&gt;.*                    // 引入所有类\n\n\n\n类和接口声明\nclass Hello&#123; ... &#125;\ninterface DataCollect&#123; ...&#125;\n\n类和接口是程序的基本组成单元\n类是由成员变量和成员方法等组成，表示了对象的基本属性和行为\n接口表现了对象所具有的行为规范\n源程序中至少有一个类或接口创建\n\n\n\n在一个源程序中，只能有一个包声明语句，而源程序中可以有任意个import引入语句。当源程序在编译时,对不需要引入的类不会引入。类的体是由成员变量和成员方法等组成的，在一个Java源程序中，只能有一个类可以被声明为public(公共)类。若某个类中有main()方法，则声明该类为public类。若想创建多个public类，应该为每一类单独地创建一个源程序。应该用public修饰的类，即公共类作为源程序的文件名，并需要注意的是文件名要和该类名的大小写保持一致。\n在应用程序Application中，main()方法是程序运行的入口：\npublic static void main(String args[])\n比如九九乘法表：\npublic class MultiplicationTable &#123;\n    public static void main(String[] args) &#123;\n        for (int i = 1; i &lt;= 9; i++) &#123;\n            for (int j = 1; j &lt;= i; j++) &#123;\n                System.out.print(j + &quot; * &quot; + i + &quot; = &quot; + (i * j) + &quot;\\t&quot;);\n            &#125;\n            System.out.println();\n        &#125;\n    &#125;\n&#125;\n\nJava中的注释和C/C++一样，但在javadoc多了一种注释：\n/** */\nJava字符集符号集符号是构成程序的基本单位。Java采用的是Unicode码，又称统一码字符集，使用16位存储空间，支持多种语言，更具有国际化特性。当Unicode中的高8位为0时，则低8位的编码与ASCII码相同。ASCII码是用8位存储空间。\n关键字\n48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。\n2个保留字（现在没用以后可能用到作为关键字）：goto、const。\n3个特殊直接量：true、false、null。 \n\n\n\n\n\n关键字\n意思\n备注，常用\n\n\n\n\npublic\n公有的\n可跨包，（默认选择）\n\n\nprotected\n受保护的\n当前包内可用\n\n\nprivate\n私有的\n当前类可用\n\n\nclass\n类\npublic class A()&#123;&#125; 花括号里有已实现方法体，类名需要与文件名相同\n\n\ninterface\n接口\npublic interface B()&#123;&#125; 花括号里有方法体，但没有实现，方法体句子后面是英文分号“:”结尾\n\n\nabstract\n声明抽象\npublic abstract class C()&#123;&#125; 介于类与接口中间，可以有也可以没有已经实现的方法体\n\n\nimplements\n实现\n用于类或接口实现接口public class A interface B()&#123;&#125;\n\n\nextends\n继承\n用于类继承类 public class A extends D()&#123;&#125;\n\n\nnew\n创建新对象\nA a=new A(); A表示一个类\n\n\nimport\n引入包的关键字\n当使用某个包的一些类时，仅需类名 然后使用ctrl+shift+o或者选定类名（类或属性或方法）按住ctrl+单击 即可自动插入类所在的包。如：JFrame 快捷键之后自动加入import javax.swing.JFrame;\n\n\npackage\n定义包的关键字\n将所有有关的类放在一个包类以便查找修改等。如：package javake.flycat.draw002;\n\n\nbyte\n字节型\n8bit\n\n\nchar\n字符型\n16bit\n\n\nboolean\n布尔型\n—（注意，这里的值只能为true和false，不能是0和1）\n\n\nshort\n短整型\n16bit\n\n\nint\n整型\n32bit\n\n\nfloat\n浮点型\n32bit\n\n\nlong\n长整型\n64bit\n\n\ndouble\n双精度\n64bit\n\n\nvoid\n无返回\npublic void A(){}  其他需要返回的经常与return连用\n\n\nnull\n空值\n\n\n\ntrue\n真\n\n\n\nfalse\n假\n\n\n\nif\n如果\nif(){} 如果小括号里面怎么怎么样 花括号就怎么怎么样\n\n\nelse\n否则，或者\n常与if连用，用法相同\n\n\nwhile\n当什么的时候\nwhile 怎么样就do什么  while(){}\n\n\nfor\n满足三个条件时\nfor ( ; ; ){}\n\n\nswitch\n开关\nswitch(表达式) { case 常量表达式1:语句1; …. case 常量表达式2:语句2; default:语句; }\n\n\ncase\n返回开关里的结果\n\n\n\ndefault\n默认\n\n\n\ndo\n运行\n长与while连用\n\n\nbreak\n跳出循环\n\n\n\ncontinue\n继续\n中断本次循环，并开始下一次\n\n\nreturn\n返回\nreturn 一个返回值类型\n\n\ninstanceof\n实例\n一个二元操作符，和==，&gt;，&lt;是同一类的。测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据\n\n\nstatic\n静态的\n属性和方法都可以用static修饰，直接使用类名.属性和方法名。 只有内部类可以使用static关键字修饰，调用直接使用类名.内部类类名进行调用。  static可以独立存在。静态块\n\n\nfinal\n最终的不可被改变的\n方法和类都可以用final来修饰  final修饰的类是不能被继承的  final修饰的方法是不能被子类重写。常量的定义：final修饰的属性就是常量。\n\n\nsuper\n调用父类的方法\n常见public void paint(Graphics g)&#123;super.paint(g); ··· &#125;\n\n\nthis\n当前类的父类的对象\n调用当前类中的方法（表示调用这个方法的对象）this.addActionListener(al):等等\n\n\nnative\n本地\n用于表示一个方法是由本地代码（通常是由其他编程语言如C或C++编写的）实现的，使用本地方法可以在Java程序中调用底层操作系统或其他外部库中的功能。这在需要与底层系统交互或利用现有C/C++库的情况下很有用。\n\n\nstrictfp\n严格,精准\n\n\n\nsynchronized\n线程,同步\n用于同步代码块\n\n\ntransient\n短暂\n表明该变量在对象的序列化过程中应该被忽略，不会被持久化保存被 transient 修饰的变量不会被写入到输出流，因此在反序列化时也不会恢复该变量的值。\n\n\nvolatile\n易失\n用于修饰变量以保证线程可见性\n\n\ncatch\n处理异常\n1.try+catch 程序的流程是：运行到try块中，如果有异常抛出，则转到catch块去处理。然后执行catch块后面的语句2.try+catch+finally程序的流程是：运行到try块中，如果有异常抛出，则转到catch块,catch块执行完毕后，执行finally块的代码，再执行finally块后面的代码。如果没有异常抛出，执行完try块，也要去执行finally块的代码。然后执行finally块后面的语句3.try+finally程序的流程是：运行到try块中,如果有异常抛出的话，程序转向执行finally块的代码。那末finally块后面的代码还会被执行吗？不会！因为你没有处理异常，所以遇到异常后，执行完finally后，方法就已抛出异常的方式退出了。这种方式中要注意的是，由于你没有捕获异常，所以要在方法后面声明抛出异常\n\n\ntry\n捕获异常\n\n\n\nfinally\n有没有异常都执行\n\n\n\nthrow\n抛出一个异常对象\n一些可以导致程序出问题的因素,比如书写错误,逻辑错误或者是api的应用错误等等. 为了防止程序的崩溃就要预先检测这些因素,所以java 使用了异常这个机制.在java中异常是靠 “抛出” 也就是英语的”throw” 来使用的,意思是如果发现到什么异常的时候就把错误信息 “抛出”\n\n\nthrows\n声明一个异常可能被抛出\n用于指定该方法可能抛出的异常类型。当一个方法可能引发异常，但实际的异常处理将由调用该方法的代码处理\n\n\nenum\n枚举，列举型别\n\n\n\nassert\n断言\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrue, false和null为小写,不能大写。严格地讲，它们不是关键字，而是一种值。但是仍然把它们作为关键字使用。sizeof不是关键字goto、const不是关键字，是保留字关键字不能作为一般的标识符使用，即一般的标识符(变量名、类名、方法名等)不能与其同名。\n标识符\n取名规则\n必须由字母、下划线或美元符开头的\n并由字母、数字、下划线和美元符组成的\n不能与关键字同名\n\n\n\nJava数据类型\n简单数据类型\nJava语言数据中的数值类型都是有符号(正负号)的，在贮存数值类型的数据时，其最高位用来表示数据的正负号。简单类型的变量被声明时，存储空间也同时被分配。该贮存空间只占用一个单一贮存单元。对简单类型变量访问则直接可以得到它的数据。\n引用数据类型引用类型(数组、class或interface)声明变量时，是不会为变量(即对象)分配存储空间。它们声明的变量不是数据本身，而是数据的引用(reference)，需用new运算符来为引用类型的变量分配贮存空间;引用：类似C/C++中的指针，但又不同于C/C++中的指针，它的引用必须由Java的虚拟机创建和管理。Java语言本身不支持指针;引用类型变量的值是一个数据的引用(即地址)。它是对占有由多个贮存单元构成的贮存空间的引用。引用类型的变量通过点””运算符访问它的成员。\n常量与变量常量常量是指直接用于放入程序中的固定不变的值。它的表现形式有两种:数值和字符。\n\n整数型常量\nJava整数类型常量有三种形式:十进制、八进制、十六进制。\n十进制整数是由不以0开头，0~9数字组成数据:12;\n八进制整数是由以0开头，0~7数字组成的数据：012;\n十六进制整数是由以0x或0X开头，0～9数字及A～F的字母组成的数据:0x12AB。\n整型数常量均为int类型，除非在其后有字母“L”来表示是长整型long的值。\n\n浮点型常量\n浮点数类型有float单精度浮点数,double双精度浮点数。在数字后面带有字母F或f (float) 、D或d (double)分别表示单/双精度的浮点数值。在数值后面不带有任何大小写字母f或d时，表示为double数值。\n\n\n\n\n\n\n\n\n\n例如:如下形式表示的单/双精度型数值3.12E20 一个带指数的大浮点数值1.567F                                                一个单精度浮点数值42.314E+307D                                  一个带指数的双精度浮点数值。\n\n字符型常量\n由单引号”包括的单个Unicode字符例: ‘A’, 9’,’@’16位无符号在字符型常量中，也有用带””来表示的特殊字符，是其中的一些不可显示或有特殊意义的字符。例:’\\n’, ‘\\t’\n\n\n布尔型常量\n布尔型关键字是boolean，它有两个常量false和true,以表示“假”和“真”两种状态。要注意的是在整型类型和boolean类型之间不能相互转换。\n\n\n变量变量是语言编程中用来标识存储地址的名称，程序通过变量名访问所标识贮存空间的数据。变量必须显式地声明变量的类型。遵循“先声明、后使用”原则。\n变量的分类及作用域依变量创建所在处可分为：\n\n成员变量\n方法的变量(包含参数)\n语句块的变量\n异常处理的变量\n\n依变量作用域可分为：\n\n全局变量:成员变量\n\n全局变量 (Global Variables):\n在Java中，通常没有严格意义上的全局变量。Java中的成员变量（Instance Variables 和 Static Variables）是与类或对象关联的变量，它们在类级别声明，但在对象级别使用。\n\n作用域（Scope）： 成员变量的作用域在整个类内，实例变量对于每个类的对象实例是独立的，而静态变量对于整个类是共享的。\n生命周期： 成员变量的生命周期与类或对象的生命周期相关联。实例变量的生命周期与对象的生命周期相同，而静态变量的生命周期与类的生命周期相同。\n可见性： 成员变量可以被类内的所有方法访问，它们对于整个类的代码都是可见的。实例变量对于每个对象的方法都是可见的，静态变量对于整个类的所有对象和方法都是可见的。\n\n\n\n\n局部变量:方法的变量(包含参数)\n\n局部变量 (Local Variables):\n作用域（Scope）： 局部变量的作用域仅限于声明它们的代码块、方法、或构造方法内部。它们只能在这些地方被访问和使用，超出这些范围就无法访问。\n生命周期： 局部变量的生命周期仅限于包含它们的代码块的执行期间。一旦代码块执行完毕，局部变量就会被销毁，其内存被释放。\n可见性： 局部变量通常用于保存临时数据或方法内部的中间结果。它们对于方法外的其他代码块是不可见的，因此具有良好的封装性。\n\n\n\n\n\n\n运算符和表达式运算符单目(一元)运算符：有一个操作数\ni++\n双目(二元)运算符：有两个操作数\na + b\n三目(三元)运算符：有三个操作数\nx &gt; y ? a : b\n\n位运算符\n\ne.g.\n右移：\n左移：执行一个左移位。移位的结果是第一个操作数乘以2的幂，而这个幂的指数就是第二个操作数。左移位时，高位被截去，低位填充0。\n\n\n\n\n\n\n\n\n\n\n布尔运算符优化\n&amp;&amp;运算符：opB18&amp;opB2如果opB1值为false，则运算式的值就是false，无论opB2的值是什么。程序不会访问opB2;如果opB1值为true，则需要opB2的值才能确定运算式的值，程序需要访问opB2。||运算符：opB1||opB2如果opB1值为true，则运算式的值就是true，无论opB2的值是什么。程序不会访问opB2;如果opB1值为false，则需要opB2的值才能确定运算式的值，程序需要访问opB2。\n赋值运算符赋值运算符“=”的作用是将数据写入到变量的贮存单元中。在“=”运算符的左边是变量，右边则是待写入的数据值。赋值操作必须注意:\n\n必须是将右边的数值赋给左边的变量\n\n右边的数值类型要与左边的变量类型一致或相容\n\n当它们的类型相同时，才能将右边的数值写入变量的贮存单元\n\n\n\n类型转换“拓宽类型”是指把值范围小类型的数据转换成值范围大类型的数据；“缩窄类型”是指把值范围大类型的数据转换成值范围小类型的数据。\n\n自动转换：\nint a = 10; long b = a;\n\n强制转换：\nlong b = 10; int a = (int)b;\n\n\n三目运算符expreBool?expression1:expression2\nexpreBool表达式是boolean类型，expression1和expression2表达式是相同类型。当expreBool为true时，取expression1的值；当expreBool为false时，取expression2的值。\n表达式表达式是变量、常量、运算符、方法等按照一定的运算规则组成的序列，并返回一个值。表达式是运算符运算的表述，它返回值不仅与表达式中的操作数有关，而且还是运算符操作顺序有关。\n\n\n\n\n\n\n\n\n\n表达式有时也称为运算式。\n\n","slug":"java语言基础","date":"2023-09-01T02:01:41.000Z","categories_index":"编程,java","tags_index":"java","author_index":"C4IN"},{"id":"ac1892c7e69c5d72eb21bb4d76af07c9","title":"java概述","content":"JAVA\nJava 技术的多功能性、有效性、平台的可移植性以及安全性已经使它成为网络计算领域最完美的技术。\n\nJAVA语言特点平台无关性\n编译器所生成的可执行代码是基于抽象处理器─Java虚拟机(JVM：Java Virtual Machine)来实现。\n\nJava虚拟机就是虚拟运行Java代码的假想计算机，其定义为：运行经过编译的Java目标代码的计算机的实现。\n\n编译生成的代码不针对任何具体的硬件体系结构和软件平台的代码—“字节码”。\n\n\n简洁性\n由C++衍生而来，其语言风格与C++类似，但进行了很大的简化和改进。\n抛弃了C++中一些不是绝对必要的东西，如头文件、指针、结构、联合、隐式的类型转换和操作符重载等。\njava支持单重继承，接口（interface）实现多继承，没有多继承混乱、复杂的问题。\n\n安全性\n对内存访问是通过对象实例变量实现的，防止在网络系统或分布系统环境下特洛伊木马等手段访问对象的私有成员。\n不支持指针，避免指针的安全隐患。\nJava语言提供的内存管理机制,有自动搜集“内存垃圾”程序。\n\n动态性\n分布式系统中动态地维护应用程序和对支持类库间一致性，就可避免像类库升级问题。\n在类库中可以自由地加入新的方法和实例变量而不会影响用户程序的执行。\n\n高性能\nJava字节码格式设计中充分考虑到它的机器码执行效率，很容易直接转换成对应于特定处理器的高性能机器码。\n\n多线程\n自身的多线程利用系统的空闲执行一些常规处理等。\n提供对多线程的语言级支持，提高程序执行效率。\n\n分布式\nJava是一个适用于网络的语言，它的设计使分布式计算变得容易起来。\n提供的类库支持对TCP/IP协议处理，可以通过URL地址访问网络上其它的对象。\nJava支持WWW的C/S和B/S的计算机网络模型，它可以支持分布式的数据分布和操作分布。\n\n面向对象（OOP，Object Oriented Programming）\n\n\n\n\n\n\n\n\n 计算机程序是由单个能够起到子程序作用的单元或对象组合而成。\n\n比如一辆车就可以表示为对象：\nclass Car &#123;\n    int color;  \n    int number;\n    int speed;\n\n    void brake() &#123; … &#125;\n    void speedUp() &#123;…&#125;;\n    void slowDown() &#123; …  &#125;\n&#125;\n\n类是Java语言的最基本概念，是组成Java程序的基本要素\n类是Java的执行单位，Java运行的就是Java类本身类封装了该类对象的变量和方法\n对象是类的实例化，对象的创建是通过对象构造方法来实现的\n我们可以生成多个对象，通过消息传递来进行交互，最终完成复杂的任务\n\nJava语言具有真正的面向对象语言的特点，除了数值、布尔和字符三种基本的数据类型外，其它类型都是对象，支持封装、多态和继承。\n\n\n\n\n\n\n\n\n\n\n封装就是将对象内的数据和代码联编起来，形成一个对象;\n多态性是指一个接口，有多个内在实现形式表示;\n继承是指某一对象直接使用另一对象的所有属性和方法的过程,\n\nJava程序基本结构\nJava源程序是以.java为扩展名的文件\n这些文件就是Java编译器javac的编译单元，组成为：\n最多有一条package语句\n任意条import语句\n至少有一个类class声明或接口interface声明构成\n\n\n\n// 源程序：&lt;name&gt;.java\npackage &lt;packagename&gt;;\nimport &lt;otherClassName&gt;;\nclass ClassName &#123;\npublic static void main (string args[]) &#123;\n    /*code*/\n    &#125;\n&#125;\nJava程序类型Application：Java应用程序\n\n\n\n\n\n\n\n\n由Java解释器控制执行的，它可以在任何装有JVM的计算机上运行。\n\nApplication是可独立运行的Java程序，它由一个或多个类组成,其中必须有一个类中定义了main()方法，main()方法是Application运行的起始点实现Application编程需要三个步骤:\n\n使用字符编辑器上输入并保存Java源程序代码;\n\n使用编译器javac对源程序(.java)进行编译，生成对应的字节代码程序(.class);\n\n使用解释器java对Java字节码程序(.class)解释执行。\n\napplet：java小应用程序\n\n\n\n\n\n\n\n\n嵌入到Web页面中，由Java兼容浏览器控制执行是一种“寄生”运行方式，它要依赖HTML文件以及Web浏览器。\nApplet程序是在Java兼容浏览器上执行。实现Applet编程需要四步：\n\n前两步同Application:&gt;使用字符编辑器上输入并保存Java源程序代码\n使用编译器javac对源程序(.java)进行编译，生成对应的字节代码程序(.class)\n将Applet的字节码嵌入到HTML文件中\n使用Web浏览器(支持Java)或appletviewer观察器来对Java字节码程序(.class)解释执行\n\n\nApplication&amp;Applet\n\n运行方式不同\nJava Applet程序不能单独运行，它必须依附于一个用HTML语言编写的网页并嵌入其中\n\n运行工具不同Java Application程序被编译以后，用普通的Java解释器就可以使其边解释边执行，而Java Applet必须通过网络浏览器或者Applet观察器才能执行程序\n\n结构不同每个Java Application程序必定含有一个并且只有一个main方法;Applet没有含main方法的主类\n\n受到的限制不同Java Application程序可以设计成能进行各种操作的程序，包括读/写文件的操作\n\n\nJava虚拟机解释器在JVM字节码运行中，分三个阶段:\n\n代码的装入，是由类装载器(class loader)完成\n\n代码的校验，用于发现各种可能出现的错误\n\n代码的运行，在代码校验后就可以执行\n\n\n代码的运行有两种执行方式：\n\n即时编译方式:由代码生成器先将字节码转换成机器码，再全速执行该机器码\n\n解释执行方式:由解释器通过每次翻译并执行一小段代码来完成字节码程序的所有操作。\n\n\n\n\n","slug":"java概述","date":"2023-08-31T10:07:29.000Z","categories_index":"编程,java","tags_index":"java","author_index":"C4IN"},{"id":"745fa9d0dd7564f8475d86a8b9ad72f3","title":"java","content":"\n反射Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。通过反射，Java 代码可以发现有关已加载类的字段，方法和构造函数的信息，并可以在安全限制内对这些字段，方法和构造函数进行操作。\n反射机制的相关类与Java反射相关的类如下：\n\n\n\n\n类名\n用途\n\n\n\n\nClass类\n代表类的实体，在运行的Java应用程序中表示类和接口\n\n\nField类\n代表类的成员变量（成员变量也称为类的属性）\n\n\nMethod类\n代表类的方法\n\n\nConstructor类\n代表类的构造方法\n\n\n\n\nclass\n获得类相关的方法\n| 方法                      | 用途                                                   || ————————————- | ——————————————————————————— || asSubclass(Class clazz)   | 把传递的类的对象转换成代表其子类的对象                 || Cast                      | 把对象转换成代表类或是接口的对象                       || getClassLoader()          | 获得类的加载器                                         || getClasses()              | 返回一个数组，数组中包含该类中所有公共类和接口类的对象 || getDeclaredClasses()      | 返回一个数组，数组中包含该类中所有类和接口类的对象     || forName(String className) | 根据类名返回类的对象                                   || getName()                 | 获得类的完整路径名字                                   || newInstance()             | 创建类的实例                                           || getPackage()              | 获得类的包                                             || getSimpleName()           | 获得类的名字                                           || getSuperclass()           | 获得当前类继承的父类的名字                             || getInterfaces()           | 获得当前类实现的类或是接口                             |\n\n获得类中属性相关的方法\n\n\n\n\n\n\n方法\n用途\n\n\n\n\ngetField(String name)\n获得某个公有的属性对象\n\n\ngetFields()\n获得所有公有的属性对象\n\n\ngetDeclaredField(String name)\n获得某个属性对象\n\n\ngetDeclaredFields()\n获得所有属性对象\n\n\n\n\n\n获得类中注解相关的方法\n\n\n\n\n\n方法\n用途\n\n\n\n\ngetAnnotation(Class annotationClass)\n返回该类中与参数类型匹配的公有注解对象\n\n\ngetAnnotations()\n返回该类所有的公有注解对象\n\n\ngetDeclaredAnnotation(Class annotationClass)\n返回该类中与参数类型匹配的所有注解对象\n\n\ngetDeclaredAnnotations()\n返回该类所有的注解对象\n\n\n\n\n","slug":"java反射","date":"2023-08-02T01:19:09.000Z","categories_index":"编程,java","tags_index":"java","author_index":"C4IN"}]