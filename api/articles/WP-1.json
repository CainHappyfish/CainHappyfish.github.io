{"title":"buuoj-reverse WP-1","uid":"ec97abd0452c3383ae6efc5f2ebc40f7","slug":"WP-1","date":"2023-11-05T06:31:12.000Z","updated":"2023-11-05T09:42:53.385Z","comments":true,"path":"api/articles/WP-1.json","keywords":null,"cover":[],"content":"<h1 id=\"Buuoj-Reverse-WP-1\"><a href=\"#Buuoj-Reverse-WP-1\" class=\"headerlink\" title=\"Buuoj-Reverse WP-1\"></a>Buuoj-Reverse WP-1</h1><p>来学学逆向工程，顺便学学计组</p>\n<h2 id=\"reverse1\"><a href=\"#reverse1\" class=\"headerlink\" title=\"reverse1\"></a>reverse1</h2><p>在<code>strings</code>窗口发现flag，但直接输入发现flag错误。</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fed61c458853aef662f97.png\" alt=\"\"></p>\n<p>进行反汇编，发现</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fed61c458853aef662fef.png\" alt=\"\"></p>\n<p>该<code>for</code>循环将所有的o替换成0，所以最后的flag是<code>flag&#123;hell0_w0rld&#125;</code>。</p>\n<h2 id=\"reverse2\"><a href=\"#reverse2\" class=\"headerlink\" title=\"reverse2\"></a>reverse2</h2><p>打开<code>strings</code>窗口，发现flag的一部分</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fed60c458853aef662ea5.png\" alt=\"\"></p>\n<p>类似<code>reverse1</code>，该题将 flag 中的 i 和 r 都替换成 1。</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fed60c458853aef662eb2.png\" alt=\"\"></p>\n<h2 id=\"内涵的软件\"><a href=\"#内涵的软件\" class=\"headerlink\" title=\"内涵的软件\"></a>内涵的软件</h2><p>打开<code>strings</code>窗口即可发现flag。</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fedaec458853aef6695f0.png\" alt=\"\"></p>\n<h2 id=\"新年快乐\"><a href=\"#新年快乐\" class=\"headerlink\" title=\"新年快乐\"></a>新年快乐</h2><p><img src=\"https://pic.imgdb.cn/item/650fedadc458853aef6694e8.png\" alt=\"\"></p>\n<p>exe 被 upx 压缩，使用命令 <code>upx.exe -d xnkl.exe -o xnkl_unpack.exe</code> 解压。</p>\n<h2 id=\"XOR\"><a href=\"#XOR\" class=\"headerlink\" title=\"XOR\"></a>XOR</h2><p>反汇编，发现flag应该和<code>global</code>有关</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fedadc458853aef669505.png\" alt=\"\"></p>\n<p>找到对应的数据</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c2a7.png\" alt=\"\"></p>\n<p>查看反汇编的代码，发现对flag进行了异或操作，编写脚本：</p>\n<pre><code>&quot;&quot;&quot;\n__global\n__cstring:0000000100000F6E aFKWOXZUPFVMDGH db &#39;f&#39;,0Ah              ; DATA XREF: __data:_global↓o\n__cstring:0000000100000F6E                 db &#39;k&#39;,0Ch,&#39;w&amp;O.@&#39;,11h,&#39;x&#39;,0Dh,&#39;Z;U&#39;,11h,&#39;p&#39;,19h,&#39;F&#39;,1Fh,&#39;v&quot;M#D&#39;,0Eh,&#39;g&#39;\n__cstring:0000000100000F6E                 db 6,&#39;h&#39;,0Fh,&#39;G2O&#39;,0\n&quot;&quot;&quot;\n\nstr_xor = [&#39;f&#39;, 0x0A, &#39;k&#39;, 0x0C, &#39;w&#39;, &#39;&amp;&#39;, &#39;O&#39;, &#39;.&#39;, &#39;@&#39;, 0x11, &#39;x&#39;, 0x0D, &#39;Z&#39;, &#39;;&#39;, &#39;U&#39;, 0x11, &#39;p&#39;, 0x19, &#39;F&#39;, 0x1F,\n           &#39;v&#39;, &#39;&quot;&#39;, &#39;M&#39;, &#39;#&#39;, &#39;D&#39;, 0x0E, &#39;g&#39;, 6, &#39;h&#39;, 0x0F, &#39;G&#39;, &#39;2&#39;, &#39;O&#39;, 0]\n\nprint(len(str_xor))\n\nfor i in range(0, len(str_xor)):\n    if isinstance(str_xor[i], int):\n        str_xor[i] = chr(str_xor[i])\n\nfor i in range(0, len(str_xor) - 1):\n    print(str_xor[i], end=&quot; &quot;)\n\nprocess = &#39;&#39;.join(str_xor)\n\nprint(process)\n\nflag = &#39;&#39;\nfor i in range(0, len(str_xor)-1):\n    flag += chr(ord(str_xor[i]) ^ ord(str_xor[i - 1]))\n\nprint(flag)\n</code></pre><p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c2c1.png\" alt=\"\"></p>\n<h2 id=\"reverse3\"><a href=\"#reverse3\" class=\"headerlink\" title=\"reverse3\"></a>reverse3</h2><p>首先先找到flag</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c30a.png\" alt=\"\"></p>\n<p>进行反编译：</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c34d.png\" alt=\"\"></p>\n<p>发现重要函数<code>sub_4110BE</code>，而该函数返回的是<code>sub_411AB0</code>：</p>\n<pre><code>void *__cdecl sub_411AB0(char *a1, unsigned int a2, int *a3)\n&#123;\n  int v4; // [esp+D4h] [ebp-38h]\n  int v5; // [esp+D4h] [ebp-38h]\n  int v6; // [esp+D4h] [ebp-38h]\n  int v7; // [esp+D4h] [ebp-38h]\n  int i; // [esp+E0h] [ebp-2Ch]\n  unsigned int v9; // [esp+ECh] [ebp-20h]\n  int v10; // [esp+ECh] [ebp-20h]\n  int v11; // [esp+ECh] [ebp-20h]\n  void *v12; // [esp+F8h] [ebp-14h]\n  char *v13; // [esp+104h] [ebp-8h]\n\n  if ( !a1 || !a2 )\n    return 0;\n  v9 = a2 / 3;\n  if ( (int)(a2 / 3) % 3 )\n    ++v9;\n  v10 = 4 * v9;\n  *a3 = v10;\n  v12 = malloc(v10 + 1);\n  if ( !v12 )\n    return 0;\n  j_memset(v12, 0, v10 + 1);\n  v13 = a1;\n  v11 = a2;\n  v4 = 0;\n  while ( v11 &gt; 0 )\n  &#123;\n    byte_41A144[2] = 0;\n    byte_41A144[1] = 0;\n    byte_41A144[0] = 0;\n    for ( i = 0; i &lt; 3 &amp;&amp; v11 &gt;= 1; ++i )\n    &#123;\n      byte_41A144[i] = *v13;\n      --v11;\n      ++v13;\n    &#125;\n    if ( !i )\n      break;\n    switch ( i )\n    &#123;\n      case 1:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v5 = v4 + 1;\n        *((_BYTE *)v12 + v5) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];\n        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];\n        v4 = v5 + 1;\n        break;\n      case 2:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v6 = v4 + 1;\n        *((_BYTE *)v12 + v6) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | (4 * (byte_41A144[1] &amp; 0xF))];\n        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[64];\n        v4 = v6 + 1;\n        break;\n      case 3:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v7 = v4 + 1;\n        *((_BYTE *)v12 + v7) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | (4 * (byte_41A144[1] &amp; 0xF))];\n        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[byte_41A144[2] &amp; 0x3F];\n        v4 = v7 + 1;\n        break;\n    &#125;\n  &#125;\n  *((_BYTE *)v12 + v4) = 0;\n  return v12;\n&#125;\n</code></pre><p>查看<code>aAbcdefghijklmn</code>：</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c367.png\" alt=\"\"></p>\n<p>发现是常用的base64编码表，编写脚本：</p>\n<pre><code>import base64\n\n_str = &#39;e3nifIH9b_C@n@dH&#39;\n\nrawDest = &quot;&quot;\nfor i in range(len(_str)):\n    rawDest += chr(ord(_str[i]) - i)\nprint(rawDest)\n\nflag = base64.b64decode(rawDest)\nprint(flag)\n</code></pre><p>得到flag：</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fee19c458853aef66d3c0.png\" alt=\"\"></p>\n<h2 id=\"SimpleRev\"><a href=\"#SimpleRev\" class=\"headerlink\" title=\"SimpleRev\"></a>SimpleRev</h2><p>将文件拖进IDA，查看关键函数及数据</p>\n<p><code>Decry</code>:</p>\n<pre><code>unsigned __int64 Decry()\n&#123;\n  char v1; // [rsp+Fh] [rbp-51h]\n  int v2; // [rsp+10h] [rbp-50h]\n  int v3; // [rsp+14h] [rbp-4Ch]\n  int i; // [rsp+18h] [rbp-48h]\n  int v5; // [rsp+1Ch] [rbp-44h]\n  char src[8]; // [rsp+20h] [rbp-40h] BYREF\n  __int64 v7; // [rsp+28h] [rbp-38h]\n  int v8; // [rsp+30h] [rbp-30h]\n  __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF\n  int v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  *(_QWORD *)src = 0x534C43444ELL;\n  v7 = 0LL;\n  v8 = 0;\n  v9[0] = 0x776F646168LL;\n  v9[1] = 0LL;\n  v10 = 0;\n  text = (char *)join(key3, v9);\n  strcpy(key, key1);\n  strcat(key, src);\n  v2 = 0;\n  v3 = 0;\n  getchar();\n  v5 = strlen(key);\n  for ( i = 0; i &lt; v5; ++i )\n  &#123;\n    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )\n      key[i] = key[v3 % v5] + 32;\n    ++v3;\n  &#125;\n  printf(&quot;Please input your flag:&quot;);\n  while ( 1 )\n  &#123;\n    v1 = getchar();\n    if ( v1 == 10 )\n      break;\n    if ( v1 == 32 )\n    &#123;\n      ++v2;\n    &#125;\n    else\n    &#123;\n      if ( v1 &lt;= 96 || v1 &gt; 122 )\n      &#123;\n        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )\n        &#123;\n          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n          ++v3;\n        &#125;\n      &#125;\n      else\n      &#123;\n        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n        ++v3;\n      &#125;\n      if ( !(v3 % v5) )\n        putchar(32);\n      ++v2;\n    &#125;\n  &#125;\n  if ( !strcmp(text, str2) )\n    puts(&quot;Congratulation!\\n&quot;);\n  else\n    puts(&quot;Try again!\\n&quot;);\n  return __readfsqword(0x28u) ^ v11;\n&#125;\n</code></pre><p>数据：</p>\n<pre><code>src: NDCLS\nv9: hadow\nkey1: ADSFK\nkey3: kills\n</code></pre><p>注意<code>v9， key1</code>的数据类型是<code>__int64</code>，是以大端存储的，我们要将其倒过来读取，所以<code>strcpy(key, key1); strcat(key, src);</code>将字符串拼接到<code>key</code>中，得到<code>ADSFKNDCLS</code>，<code>text</code>为<code>killshadow</code>。</p>\n<p>接下来我们分析代码：</p>\n<p>大写转小写：</p>\n<pre><code>  for ( i = 0; i &lt; v5; ++i )\n  &#123;\n    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )\n      key[i] = key[v3 % v5] + 32;\n    ++v3;\n  &#125;\n</code></pre><p>输入处理：</p>\n<pre><code>printf(&quot;Please input your flag:&quot;);\n  while ( 1 )\n  &#123;\n    v1 = getchar();\n    if ( v1 == 10 )            // 换行停止\n      break;\n    if ( v1 == 32 )            // 过滤空格\n    &#123;\n      ++v2;\n    &#125;\n    else\n    &#123;\n      if ( v1 &lt;= 96 || v1 &gt; 122 )\n      &#123;\n        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )        // 处理大写字母\n        &#123;\n          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n          ++v3;\n        &#125;\n      &#125;\n      else                                // 处理小写字母\n      &#123;\n        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n        ++v3;\n      &#125;\n      if ( !(v3 % v5) )\n        putchar(32);\n      ++v2;\n    &#125;\n  &#125;\n  if ( !strcmp(text, str2) )\n    puts(&quot;Congratulation!\\n&quot;);\n  else\n    puts(&quot;Try again!\\n&quot;);\n  return __readfsqword(0x28u) ^ v11;\n&#125;\n</code></pre><p>我们需要将处理后的输入与<code>text</code>比较。采用爆破方式编写解密脚本：</p>\n<pre><code>import string\n\nkey = &quot;ADSFKNDCLS&quot;.lower()\nkey = list(map(ord, key))  # 转化为ASCII表示\ntext = &quot;killshadow&quot;\ntext = list(map(ord, text))  \n\nflag = &#39;&#39;\ncharSet = string.ascii_uppercase + string.ascii_lowercase  \ncharSet = list(map(ord, charSet))  \nfor i in range(len(key)):\n    for char in charSet:\n        if text[i] == (char - 39 - key[i] + ord(&#39;a&#39;)) % 26 + ord(&#39;a&#39;):\n            flag += chr(char)\n            break\nprint(flag)\n</code></pre><p>得到：<code>KLDQCUDFZO</code></p>\n<h2 id=\"JavaRev\"><a href=\"#JavaRev\" class=\"headerlink\" title=\"JavaRev\"></a>JavaRev</h2><p>拖进jadx中，在<code>defpackage/Reverse</code>找到对应源码：</p>\n<pre><code>package defpackage;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/* loaded from: Reverse.class */\npublic class Reverse &#123;\n    public static void main(String[] args) &#123;\n        Scanner s = new Scanner(System.in);\n        System.out.println(&quot;Please input the flag ：&quot;);\n        String str = s.next();\n        System.out.println(&quot;Your input is ：&quot;);\n        System.out.println(str);\n        char[] stringArr = str.toCharArray();\n        Encrypt(stringArr);\n    &#125;\n\n    public static void Encrypt(char[] arr) &#123;\n        ArrayList&lt;Integer&gt; Resultlist = new ArrayList&lt;&gt;();\n        for (char c : arr) &#123;\n            int result = (c + &#39;@&#39;) ^ 32;\n            Resultlist.add(Integer.valueOf(result));\n        &#125;\n        int[] KEY = &#123;180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65&#125;;\n        ArrayList&lt;Integer&gt; KEYList = new ArrayList&lt;&gt;();\n        for (int i : KEY) &#123;\n            KEYList.add(Integer.valueOf(i));\n        &#125;\n        System.out.println(&quot;Result:&quot;);\n        if (Resultlist.equals(KEYList)) &#123;\n            System.out.println(&quot;Congratulations！&quot;);\n        &#125; else &#123;\n            System.err.println(&quot;Error！&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre><p>我们对<code>Encrypt</code>函数进行分析：</p>\n<p>对于数组 <code>arr</code> 中的每个字符 <code>c</code>，首先将字符 <code>c</code> 转换为其对应的ASCII码值，再加上 <code>@</code> 字符的ASCII码值（64）并对结果与32进行异或。将处理后的结果转换为整数，并将其加到 <code>Resultlist</code> 中，然后与<code>KEY</code>进行比较。</p>\n<p>编写解密脚本：</p>\n<pre><code>Key = [180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65]\nflag = &quot;&quot;\n\nfor i in range(0, len(Key)):\n\n    flag += chr((Key[i] ^ 32) - 64)\n\nprint(flag)\n</code></pre><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，异或运算的优先级低于加减</p></blockquote>\n<h2 id=\"GXYCTF2019-luck-guy\"><a href=\"#GXYCTF2019-luck-guy\" class=\"headerlink\" title=\"[GXYCTF2019]luck_guy\"></a>[GXYCTF2019]luck_guy</h2><p>将文件拖进IDA中，打开字符串窗口，发现<code>GXY&#123;do_not_</code>。</p>\n<p>找到关键代码<code>get_flag()</code>，分析：</p>\n<pre><code>unsigned __int64 get_flag()\n&#123;\n  unsigned int v0; // eax\n  int i; // [rsp+4h] [rbp-3Ch]\n  int j; // [rsp+8h] [rbp-38h]\n  __int64 s; // [rsp+10h] [rbp-30h] BYREF\n  char v5; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  v0 = time(0LL);\n  srand(v0);\n  for ( i = 0; i &lt;= 4; ++i )\n  &#123;\n    switch ( rand() % 200 )\n    &#123;\n      case 1:\n        puts(&quot;OK, it&#39;s flag:&quot;);\n        memset(&amp;s, 0, 0x28uLL);\n        strcat((char *)&amp;s, f1);\n        strcat((char *)&amp;s, &amp;f2);\n        printf(&quot;%s&quot;, (const char *)&amp;s);\n        break;\n      case 2:\n        printf(&quot;Solar not like you&quot;);\n        break;\n      case 3:\n        printf(&quot;Solar want a girlfriend&quot;);\n        break;\n      case 4:\n        s = 0x7F666F6067756369LL;\n        v5 = 0;\n        strcat(&amp;f2, (const char *)&amp;s);\n        break;\n      case 5:\n        for ( j = 0; j &lt;= 7; ++j )\n        &#123;\n          if ( j % 2 == 1 )\n            *(&amp;f2 + j) -= 2;\n          else\n            --*(&amp;f2 + j);\n        &#125;\n        break;\n      default:\n        puts(&quot;emmm,you can&#39;t find flag 23333&quot;);\n        break;\n    &#125;\n  &#125;\n  return __readfsqword(0x28u) ^ v6;\n&#125;\n</code></pre><p>首先我们先排除没用的2,3，然后对剩下的进行排序：</p>\n<ul>\n<li><code>case 4</code>初始化<code>s, f2</code>，放在第一个执行</li>\n<li><code>case 5</code>对<code>f2</code>进行一系列操作，放在第二个执行</li>\n<li><code>case 1</code>输出<code>flag</code>，放在最后执行</li>\n</ul>\n<p>我们得到正确的执行顺序应该为<code>case4-&gt;case5-&gt;case1</code>。</p>\n<p>方法一：直接编写python脚本</p>\n<p>按上面那个顺序写就可以了。</p>\n<pre><code>flag = &quot;GXY&#123;do_not_&quot;\nf2 = [0x69, 0x63, 0x75, 0x67, 0x60, 0x6f, 0x66, 0x7f]  # 注意大端序\nfor i in range(0, len(f2)):\n    if i % 2 == 1:\n        f2[i] -= 2\n        flag += chr(f2[i])\n    else:\n        f2[i] -= 1\n        flag += chr(f2[i])\n\nprint(flag)\n</code></pre><p>方法二：patch</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>牛魔酬宾什么鬼东西，给骗了    我有jumpout恐惧症</p></blockquote>\n<ul>\n<li><p>我们先进入<code>case 4</code></p>\n</li>\n<li><p>我们删除<code>case 4</code>中的<code>jmp</code>指令，选中后右键菜单选择<code>nop</code></p>\n</li>\n<li><p>同样把<code>case 5</code>的跳转改为<code>case 1</code>的地址</p>\n</li>\n<li><p>我们再回到<code>case 1</code>，将<code>case 1</code>运行结束后跳转至整个程序的结束。</p>\n</li>\n</ul>\n<p>我们只要在反汇编中找到对应的jmp，然后修改跳转的地址就行了，修改后反编译的结果如下：</p>\n<pre><code>int get_flag()\n&#123;\n  unsigned int v0; // eax\n  int i; // [rsp+8h] [rbp-38h]\n  __int64 s; // [rsp+10h] [rbp-30h] BYREF\n  char v6; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v7; // [rsp+38h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  v0 = time(0LL);\n  srand(v0);\n  s = 0x7F666F6067756369LL;\n  v6 = 0;\n  strcat(&amp;f2, (const char *)&amp;s);\n  __asm &#123; insb &#125;\n  for ( i = 0; i &lt;= 7; ++i )\n  &#123;\n    if ( i % 2 == 1 )\n      *(&amp;f2 + i) -= 2;\n    else\n      --*(&amp;f2 + i);\n  &#125;\n  puts(&quot;OK, it&#39;s flag:&quot;);\n  memset(&amp;s, 0, 0x28uLL);\n  strcat((char *)&amp;s, f1);\n  strcat((char *)&amp;s, &amp;f2);\n  return printf(&quot;%s&quot;, (const char *)&amp;s);\n&#125;\n</code></pre>","feature":true,"text":"Buuoj-Reverse WP-1来学学逆向工程，顺便学学计组 reverse1在strings窗口发现flag，但直接输入发现flag错误。 进行反汇编，发...","permalink":"/post/WP-1","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":1,"path":"api/tags/CTF.json"},{"name":"Reverse","slug":"Reverse","count":1,"path":"api/tags/Reverse.json"},{"name":"buuoj","slug":"buuoj","count":1,"path":"api/tags/buuoj.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Buuoj-Reverse-WP-1\"><span class=\"toc-text\">Buuoj-Reverse WP-1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reverse1\"><span class=\"toc-text\">reverse1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reverse2\"><span class=\"toc-text\">reverse2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%B6%B5%E7%9A%84%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">内涵的软件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90\"><span class=\"toc-text\">新年快乐</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XOR\"><span class=\"toc-text\">XOR</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reverse3\"><span class=\"toc-text\">reverse3</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SimpleRev\"><span class=\"toc-text\">SimpleRev</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaRev\"><span class=\"toc-text\">JavaRev</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GXYCTF2019-luck-guy\"><span class=\"toc-text\">[GXYCTF2019]luck_guy</span></a></li></ol></li></ol>","author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"这里是破酥的个人博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"联邦学习出门","uid":"d99770e1923876729b03e08dda13a753","slug":"联邦学习出门","date":"2023-11-03T09:57:05.000Z","updated":"2023-11-03T09:58:18.639Z","comments":true,"path":"api/articles/联邦学习出门.json","keywords":null,"cover":[],"text":"联邦学习初识本质：联邦学习本质上是一种分布式机器学习技术，或机器学习框架。 目标：联邦学习的目标是在保证数据隐私安全及合法合规的基础上，实现共同建模，提升AI模...","permalink":"/post/联邦学习出门","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"联邦学习","slug":"联邦学习","count":1,"path":"api/tags/联邦学习.json"}],"author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"这里是破酥的个人博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}