{"title":"buuoj-reverse WP-1","uid":"ec97abd0452c3383ae6efc5f2ebc40f7","slug":"WP-1","date":"2023-11-14T08:44:12.000Z","updated":"2023-11-14T08:43:12.291Z","comments":true,"path":"api/articles/WP-1.json","keywords":null,"cover":[],"content":"<h1 id=\"Buuoj-Reverse-WP-1\"><a href=\"#Buuoj-Reverse-WP-1\" class=\"headerlink\" title=\"Buuoj-Reverse WP-1\"></a>Buuoj-Reverse WP-1</h1><p>来学学逆向工程，顺便学学计组</p>\n<h2 id=\"reverse1\"><a href=\"#reverse1\" class=\"headerlink\" title=\"reverse1\"></a>reverse1</h2><p>在<code>strings</code>窗口发现flag，但直接输入发现flag错误。</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fed61c458853aef662f97.png\" alt=\"\"></p>\n<p>进行反汇编，发现</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fed61c458853aef662fef.png\" alt=\"\"></p>\n<p>该<code>for</code>循环将所有的o替换成0，所以最后的flag是<code>flag&#123;hell0_w0rld&#125;</code>。</p>\n<h2 id=\"reverse2\"><a href=\"#reverse2\" class=\"headerlink\" title=\"reverse2\"></a>reverse2</h2><p>打开<code>strings</code>窗口，发现flag的一部分</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fed60c458853aef662ea5.png\" alt=\"\"></p>\n<p>类似<code>reverse1</code>，该题将 flag 中的 i 和 r 都替换成 1。</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fed60c458853aef662eb2.png\" alt=\"\"></p>\n<h2 id=\"内涵的软件\"><a href=\"#内涵的软件\" class=\"headerlink\" title=\"内涵的软件\"></a>内涵的软件</h2><p>打开<code>strings</code>窗口即可发现flag。</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fedaec458853aef6695f0.png\" alt=\"\"></p>\n<h2 id=\"新年快乐\"><a href=\"#新年快乐\" class=\"headerlink\" title=\"新年快乐\"></a>新年快乐</h2><p><img src=\"https://pic.imgdb.cn/item/650fedadc458853aef6694e8.png\" alt=\"\"></p>\n<p>exe 被 upx 压缩，使用命令 <code>upx.exe -d xnkl.exe -o xnkl_unpack.exe</code> 解压。</p>\n<h2 id=\"XOR\"><a href=\"#XOR\" class=\"headerlink\" title=\"XOR\"></a>XOR</h2><p>反汇编，发现flag应该和<code>global</code>有关</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fedadc458853aef669505.png\" alt=\"\"></p>\n<p>找到对应的数据</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c2a7.png\" alt=\"\"></p>\n<p>查看反汇编的代码，发现对flag进行了异或操作，编写脚本：</p>\n<pre><code>&quot;&quot;&quot;\n__global\n__cstring:0000000100000F6E aFKWOXZUPFVMDGH db &#39;f&#39;,0Ah              ; DATA XREF: __data:_global↓o\n__cstring:0000000100000F6E                 db &#39;k&#39;,0Ch,&#39;w&amp;O.@&#39;,11h,&#39;x&#39;,0Dh,&#39;Z;U&#39;,11h,&#39;p&#39;,19h,&#39;F&#39;,1Fh,&#39;v&quot;M#D&#39;,0Eh,&#39;g&#39;\n__cstring:0000000100000F6E                 db 6,&#39;h&#39;,0Fh,&#39;G2O&#39;,0\n&quot;&quot;&quot;\n\nstr_xor = [&#39;f&#39;, 0x0A, &#39;k&#39;, 0x0C, &#39;w&#39;, &#39;&amp;&#39;, &#39;O&#39;, &#39;.&#39;, &#39;@&#39;, 0x11, &#39;x&#39;, 0x0D, &#39;Z&#39;, &#39;;&#39;, &#39;U&#39;, 0x11, &#39;p&#39;, 0x19, &#39;F&#39;, 0x1F,\n           &#39;v&#39;, &#39;&quot;&#39;, &#39;M&#39;, &#39;#&#39;, &#39;D&#39;, 0x0E, &#39;g&#39;, 6, &#39;h&#39;, 0x0F, &#39;G&#39;, &#39;2&#39;, &#39;O&#39;, 0]\n\nprint(len(str_xor))\n\nfor i in range(0, len(str_xor)):\n    if isinstance(str_xor[i], int):\n        str_xor[i] = chr(str_xor[i])\n\nfor i in range(0, len(str_xor) - 1):\n    print(str_xor[i], end=&quot; &quot;)\n\nprocess = &#39;&#39;.join(str_xor)\n\nprint(process)\n\nflag = &#39;&#39;\nfor i in range(0, len(str_xor)-1):\n    flag += chr(ord(str_xor[i]) ^ ord(str_xor[i - 1]))\n\nprint(flag)\n</code></pre><p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c2c1.png\" alt=\"\"></p>\n<h2 id=\"reverse3\"><a href=\"#reverse3\" class=\"headerlink\" title=\"reverse3\"></a>reverse3</h2><p>首先先找到flag</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c30a.png\" alt=\"\"></p>\n<p>进行反编译：</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c34d.png\" alt=\"\"></p>\n<p>发现重要函数<code>sub_4110BE</code>，而该函数返回的是<code>sub_411AB0</code>：</p>\n<pre><code>void *__cdecl sub_411AB0(char *a1, unsigned int a2, int *a3)\n&#123;\n  int v4; // [esp+D4h] [ebp-38h]\n  int v5; // [esp+D4h] [ebp-38h]\n  int v6; // [esp+D4h] [ebp-38h]\n  int v7; // [esp+D4h] [ebp-38h]\n  int i; // [esp+E0h] [ebp-2Ch]\n  unsigned int v9; // [esp+ECh] [ebp-20h]\n  int v10; // [esp+ECh] [ebp-20h]\n  int v11; // [esp+ECh] [ebp-20h]\n  void *v12; // [esp+F8h] [ebp-14h]\n  char *v13; // [esp+104h] [ebp-8h]\n\n  if ( !a1 || !a2 )\n    return 0;\n  v9 = a2 / 3;\n  if ( (int)(a2 / 3) % 3 )\n    ++v9;\n  v10 = 4 * v9;\n  *a3 = v10;\n  v12 = malloc(v10 + 1);\n  if ( !v12 )\n    return 0;\n  j_memset(v12, 0, v10 + 1);\n  v13 = a1;\n  v11 = a2;\n  v4 = 0;\n  while ( v11 &gt; 0 )\n  &#123;\n    byte_41A144[2] = 0;\n    byte_41A144[1] = 0;\n    byte_41A144[0] = 0;\n    for ( i = 0; i &lt; 3 &amp;&amp; v11 &gt;= 1; ++i )\n    &#123;\n      byte_41A144[i] = *v13;\n      --v11;\n      ++v13;\n    &#125;\n    if ( !i )\n      break;\n    switch ( i )\n    &#123;\n      case 1:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v5 = v4 + 1;\n        *((_BYTE *)v12 + v5) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];\n        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[64];\n        v4 = v5 + 1;\n        break;\n      case 2:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v6 = v4 + 1;\n        *((_BYTE *)v12 + v6) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | (4 * (byte_41A144[1] &amp; 0xF))];\n        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[64];\n        v4 = v6 + 1;\n        break;\n      case 3:\n        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(int)(unsigned __int8)byte_41A144[0] &gt;&gt; 2];\n        v7 = v4 + 1;\n        *((_BYTE *)v12 + v7) = aAbcdefghijklmn[((byte_41A144[1] &amp; 0xF0) &gt;&gt; 4) | (16 * (byte_41A144[0] &amp; 3))];\n        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[((byte_41A144[2] &amp; 0xC0) &gt;&gt; 6) | (4 * (byte_41A144[1] &amp; 0xF))];\n        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[byte_41A144[2] &amp; 0x3F];\n        v4 = v7 + 1;\n        break;\n    &#125;\n  &#125;\n  *((_BYTE *)v12 + v4) = 0;\n  return v12;\n&#125;\n</code></pre><p>查看<code>aAbcdefghijklmn</code>：</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fede0c458853aef66c367.png\" alt=\"\"></p>\n<p>发现是常用的base64编码表，编写脚本：</p>\n<pre><code>import base64\n\n_str = &#39;e3nifIH9b_C@n@dH&#39;\n\nrawDest = &quot;&quot;\nfor i in range(len(_str)):\n    rawDest += chr(ord(_str[i]) - i)\nprint(rawDest)\n\nflag = base64.b64decode(rawDest)\nprint(flag)\n</code></pre><p>得到flag：</p>\n<p><img src=\"https://pic.imgdb.cn/item/650fee19c458853aef66d3c0.png\" alt=\"\"></p>\n<h2 id=\"SimpleRev\"><a href=\"#SimpleRev\" class=\"headerlink\" title=\"SimpleRev\"></a>SimpleRev</h2><p>将文件拖进IDA，查看关键函数及数据</p>\n<p><code>Decry</code>:</p>\n<pre><code>unsigned __int64 Decry()\n&#123;\n  char v1; // [rsp+Fh] [rbp-51h]\n  int v2; // [rsp+10h] [rbp-50h]\n  int v3; // [rsp+14h] [rbp-4Ch]\n  int i; // [rsp+18h] [rbp-48h]\n  int v5; // [rsp+1Ch] [rbp-44h]\n  char src[8]; // [rsp+20h] [rbp-40h] BYREF\n  __int64 v7; // [rsp+28h] [rbp-38h]\n  int v8; // [rsp+30h] [rbp-30h]\n  __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF\n  int v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  *(_QWORD *)src = 0x534C43444ELL;\n  v7 = 0LL;\n  v8 = 0;\n  v9[0] = 0x776F646168LL;\n  v9[1] = 0LL;\n  v10 = 0;\n  text = (char *)join(key3, v9);\n  strcpy(key, key1);\n  strcat(key, src);\n  v2 = 0;\n  v3 = 0;\n  getchar();\n  v5 = strlen(key);\n  for ( i = 0; i &lt; v5; ++i )\n  &#123;\n    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )\n      key[i] = key[v3 % v5] + 32;\n    ++v3;\n  &#125;\n  printf(&quot;Please input your flag:&quot;);\n  while ( 1 )\n  &#123;\n    v1 = getchar();\n    if ( v1 == 10 )\n      break;\n    if ( v1 == 32 )\n    &#123;\n      ++v2;\n    &#125;\n    else\n    &#123;\n      if ( v1 &lt;= 96 || v1 &gt; 122 )\n      &#123;\n        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )\n        &#123;\n          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n          ++v3;\n        &#125;\n      &#125;\n      else\n      &#123;\n        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n        ++v3;\n      &#125;\n      if ( !(v3 % v5) )\n        putchar(32);\n      ++v2;\n    &#125;\n  &#125;\n  if ( !strcmp(text, str2) )\n    puts(&quot;Congratulation!\\n&quot;);\n  else\n    puts(&quot;Try again!\\n&quot;);\n  return __readfsqword(0x28u) ^ v11;\n&#125;\n</code></pre><p>数据：</p>\n<pre><code>src: NDCLS\nv9: hadow\nkey1: ADSFK\nkey3: kills\n</code></pre><p>注意<code>v9， key1</code>的数据类型是<code>__int64</code>，是以大端存储的，我们要将其倒过来读取，所以<code>strcpy(key, key1); strcat(key, src);</code>将字符串拼接到<code>key</code>中，得到<code>ADSFKNDCLS</code>，<code>text</code>为<code>killshadow</code>。</p>\n<p>接下来我们分析代码：</p>\n<p>大写转小写：</p>\n<pre><code>  for ( i = 0; i &lt; v5; ++i )\n  &#123;\n    if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 )\n      key[i] = key[v3 % v5] + 32;\n    ++v3;\n  &#125;\n</code></pre><p>输入处理：</p>\n<pre><code>printf(&quot;Please input your flag:&quot;);\n  while ( 1 )\n  &#123;\n    v1 = getchar();\n    if ( v1 == 10 )            // 换行停止\n      break;\n    if ( v1 == 32 )            // 过滤空格\n    &#123;\n      ++v2;\n    &#125;\n    else\n    &#123;\n      if ( v1 &lt;= 96 || v1 &gt; 122 )\n      &#123;\n        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )        // 处理大写字母\n        &#123;\n          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n          ++v3;\n        &#125;\n      &#125;\n      else                                // 处理小写字母\n      &#123;\n        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n        ++v3;\n      &#125;\n      if ( !(v3 % v5) )\n        putchar(32);\n      ++v2;\n    &#125;\n  &#125;\n  if ( !strcmp(text, str2) )\n    puts(&quot;Congratulation!\\n&quot;);\n  else\n    puts(&quot;Try again!\\n&quot;);\n  return __readfsqword(0x28u) ^ v11;\n&#125;\n</code></pre><p>我们需要将处理后的输入与<code>text</code>比较。采用爆破方式编写解密脚本：</p>\n<pre><code>import string\n\nkey = &quot;ADSFKNDCLS&quot;.lower()\nkey = list(map(ord, key))  # 转化为ASCII表示\ntext = &quot;killshadow&quot;\ntext = list(map(ord, text))  \n\nflag = &#39;&#39;\ncharSet = string.ascii_uppercase + string.ascii_lowercase  \ncharSet = list(map(ord, charSet))  \nfor i in range(len(key)):\n    for char in charSet:\n        if text[i] == (char - 39 - key[i] + ord(&#39;a&#39;)) % 26 + ord(&#39;a&#39;):\n            flag += chr(char)\n            break\nprint(flag)\n</code></pre><p>得到：<code>KLDQCUDFZO</code></p>\n<h2 id=\"JavaRev\"><a href=\"#JavaRev\" class=\"headerlink\" title=\"JavaRev\"></a>JavaRev</h2><p>拖进jadx中，在<code>defpackage/Reverse</code>找到对应源码：</p>\n<pre><code>package defpackage;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/* loaded from: Reverse.class */\npublic class Reverse &#123;\n    public static void main(String[] args) &#123;\n        Scanner s = new Scanner(System.in);\n        System.out.println(&quot;Please input the flag ：&quot;);\n        String str = s.next();\n        System.out.println(&quot;Your input is ：&quot;);\n        System.out.println(str);\n        char[] stringArr = str.toCharArray();\n        Encrypt(stringArr);\n    &#125;\n\n    public static void Encrypt(char[] arr) &#123;\n        ArrayList&lt;Integer&gt; Resultlist = new ArrayList&lt;&gt;();\n        for (char c : arr) &#123;\n            int result = (c + &#39;@&#39;) ^ 32;\n            Resultlist.add(Integer.valueOf(result));\n        &#125;\n        int[] KEY = &#123;180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65&#125;;\n        ArrayList&lt;Integer&gt; KEYList = new ArrayList&lt;&gt;();\n        for (int i : KEY) &#123;\n            KEYList.add(Integer.valueOf(i));\n        &#125;\n        System.out.println(&quot;Result:&quot;);\n        if (Resultlist.equals(KEYList)) &#123;\n            System.out.println(&quot;Congratulations！&quot;);\n        &#125; else &#123;\n            System.err.println(&quot;Error！&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre><p>我们对<code>Encrypt</code>函数进行分析：</p>\n<p>对于数组 <code>arr</code> 中的每个字符 <code>c</code>，首先将字符 <code>c</code> 转换为其对应的ASCII码值，再加上 <code>@</code> 字符的ASCII码值（64）并对结果与32进行异或。将处理后的结果转换为整数，并将其加到 <code>Resultlist</code> 中，然后与<code>KEY</code>进行比较。</p>\n<p>编写解密脚本：</p>\n<pre><code>Key = [180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65]\nflag = &quot;&quot;\n\nfor i in range(0, len(Key)):\n\n    flag += chr((Key[i] ^ 32) - 64)\n\nprint(flag)\n</code></pre><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，异或运算的优先级低于加减</p></blockquote>\n<h2 id=\"GXYCTF2019-luck-guy\"><a href=\"#GXYCTF2019-luck-guy\" class=\"headerlink\" title=\"[GXYCTF2019]luck_guy\"></a>[GXYCTF2019]luck_guy</h2><p>将文件拖进IDA中，打开字符串窗口，发现<code>GXY&#123;do_not_</code>。</p>\n<p>找到关键代码<code>get_flag()</code>，分析：</p>\n<pre><code>unsigned __int64 get_flag()\n&#123;\n  unsigned int v0; // eax\n  int i; // [rsp+4h] [rbp-3Ch]\n  int j; // [rsp+8h] [rbp-38h]\n  __int64 s; // [rsp+10h] [rbp-30h] BYREF\n  char v5; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  v0 = time(0LL);\n  srand(v0);\n  for ( i = 0; i &lt;= 4; ++i )\n  &#123;\n    switch ( rand() % 200 )\n    &#123;\n      case 1:\n        puts(&quot;OK, it&#39;s flag:&quot;);\n        memset(&amp;s, 0, 0x28uLL);\n        strcat((char *)&amp;s, f1);\n        strcat((char *)&amp;s, &amp;f2);\n        printf(&quot;%s&quot;, (const char *)&amp;s);\n        break;\n      case 2:\n        printf(&quot;Solar not like you&quot;);\n        break;\n      case 3:\n        printf(&quot;Solar want a girlfriend&quot;);\n        break;\n      case 4:\n        s = 0x7F666F6067756369LL;\n        v5 = 0;\n        strcat(&amp;f2, (const char *)&amp;s);\n        break;\n      case 5:\n        for ( j = 0; j &lt;= 7; ++j )\n        &#123;\n          if ( j % 2 == 1 )\n            *(&amp;f2 + j) -= 2;\n          else\n            --*(&amp;f2 + j);\n        &#125;\n        break;\n      default:\n        puts(&quot;emmm,you can&#39;t find flag 23333&quot;);\n        break;\n    &#125;\n  &#125;\n  return __readfsqword(0x28u) ^ v6;\n&#125;\n</code></pre><p>首先我们先排除没用的2,3，然后对剩下的进行排序：</p>\n<ul>\n<li><code>case 4</code>初始化<code>s, f2</code>，放在第一个执行</li>\n<li><code>case 5</code>对<code>f2</code>进行一系列操作，放在第二个执行</li>\n<li><code>case 1</code>输出<code>flag</code>，放在最后执行</li>\n</ul>\n<p>我们得到正确的执行顺序应该为<code>case4-&gt;case5-&gt;case1</code>。</p>\n<p>方法一：直接编写python脚本</p>\n<p>按上面那个顺序写就可以了。</p>\n<pre><code>flag = &quot;GXY&#123;do_not_&quot;\nf2 = [0x69, 0x63, 0x75, 0x67, 0x60, 0x6f, 0x66, 0x7f]  # 注意大端序\nfor i in range(0, len(f2)):\n    if i % 2 == 1:\n        f2[i] -= 2\n        flag += chr(f2[i])\n    else:\n        f2[i] -= 1\n        flag += chr(f2[i])\n\nprint(flag)\n</code></pre><p>方法二：patch</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>牛魔酬宾什么鬼东西，给骗了    我有jumpout恐惧症</p></blockquote>\n<ul>\n<li><p>我们先进入<code>case 4</code></p>\n</li>\n<li><p>我们删除<code>case 4</code>中的<code>jmp</code>指令，选中后右键菜单选择<code>nop</code></p>\n</li>\n<li><p>同样把<code>case 5</code>的跳转改为<code>case 1</code>的地址</p>\n</li>\n<li><p>我们再回到<code>case 1</code>，将<code>case 1</code>运行结束后跳转至整个程序的结束。</p>\n</li>\n</ul>\n<p>我们只要在反汇编中找到对应的jmp，然后修改跳转的地址就行了，修改后反编译的结果如下：</p>\n<pre><code>int get_flag()\n&#123;\n  unsigned int v0; // eax\n  int i; // [rsp+8h] [rbp-38h]\n  __int64 s; // [rsp+10h] [rbp-30h] BYREF\n  char v6; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v7; // [rsp+38h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  v0 = time(0LL);\n  srand(v0);\n  s = 0x7F666F6067756369LL;\n  v6 = 0;\n  strcat(&amp;f2, (const char *)&amp;s);\n  __asm &#123; insb &#125;\n  for ( i = 0; i &lt;= 7; ++i )\n  &#123;\n    if ( i % 2 == 1 )\n      *(&amp;f2 + i) -= 2;\n    else\n      --*(&amp;f2 + i);\n  &#125;\n  puts(&quot;OK, it&#39;s flag:&quot;);\n  memset(&amp;s, 0, 0x28uLL);\n  strcat((char *)&amp;s, f1);\n  strcat((char *)&amp;s, &amp;f2);\n  return printf(&quot;%s&quot;, (const char *)&amp;s);\n&#125;\n</code></pre><h2 id=\"BJDCTF2020-JustRE\"><a href=\"#BJDCTF2020-JustRE\" class=\"headerlink\" title=\"[BJDCTF2020]JustRE\"></a>[BJDCTF2020]JustRE</h2><p>我们将文件拖入RH中，查看“测试你的手速”弹窗代码：</p>\n<p><img src=\"https://pic.imgdb.cn/item/65477e80c458853aef778072.jpg\" alt=\"\"></p>\n<p>发现对应的机器码是129。</p>\n<p>我们再将文件拖入IDA中，查看<code>WinMain</code>：</p>\n<p><img src=\"https://pic.imgdb.cn/item/654780cfc458853aef7fc531.jpg\" alt=\"\"></p>\n<p><code>WinMain</code>里调用<code>sub_4010C0</code>注册<code>RE2</code>类：</p>\n<p><img src=\"https://pic.imgdb.cn/item/65478180c458853aef81ff0b.jpg\" alt=\"\"></p>\n<p>查看相应的函数，我们发现“测试你的手速”框口对应的函数是<code>sub_4011C0</code>，再通过之前得到的机器码找到对应的操作函数<code>DialogFunc</code>：</p>\n<p><img src=\"https://pic.imgdb.cn/item/65479c4ec458853aeff58939.jpg\" alt=\"\"></p>\n<p>129的十六进制<code>0x81</code>：</p>\n<p><img src=\"https://pic.imgdb.cn/item/65479c4ec458853aeff58939.jpg\" alt=\"\"></p>\n<p>查看<code>DialogFunc</code>:</p>\n<p><img src=\"https://pic.imgdb.cn/item/65479dc6c458853aeffb298d.jpg\" alt=\"\"></p>\n<p>得到<code>flag</code>，注意这里的格式化。</p>\n<h2 id=\"刮开有奖\"><a href=\"#刮开有奖\" class=\"headerlink\" title=\"刮开有奖\"></a>刮开有奖</h2><p>拖进RH，删除“刮开有奖字样”，修改参数：</p>\n<p><img src=\"https://pic.imgdb.cn/item/6549daa1c458853aef12fe20.jpg\" alt=\"\"></p>\n<p>处理后的效果是这样的：</p>\n<p><img src=\"https://pic.imgdb.cn/item/6549dad3c458853aef138dba.jpg\" alt=\"\"></p>\n<p>把程序拖进IDA，查看<code>DiaglogFunc</code>：</p>\n<pre><code>INT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)\n&#123;\n  const char *v4; // esi\n  const char *v5; // edi\n  int v7[2]; // [esp+8h] [ebp-20030h] BYREF\n  int v8; // [esp+10h] [ebp-20028h]\n  int v9; // [esp+14h] [ebp-20024h]\n  int v10; // [esp+18h] [ebp-20020h]\n  int v11; // [esp+1Ch] [ebp-2001Ch]\n  int v12; // [esp+20h] [ebp-20018h]\n  int v13; // [esp+24h] [ebp-20014h]\n  int v14; // [esp+28h] [ebp-20010h]\n  int v15; // [esp+2Ch] [ebp-2000Ch]\n  int v16; // [esp+30h] [ebp-20008h]\n  CHAR String[65536]; // [esp+34h] [ebp-20004h] BYREF\n  char v18[65536]; // [esp+10034h] [ebp-10004h] BYREF\n\n  if ( a2 == 272 )\n    return 1;\n  if ( a2 != 273 )\n    return 0;\n  if ( (_WORD)a3 == 1001 )\n  &#123;\n    memset(String, 0, 0xFFFFu);\n    GetDlgItemTextA(hDlg, 1000, String, 0xFFFF);\n    if ( strlen(String) == 8 )\n    &#123;\n      v7[0] = 90;\n      v7[1] = 74;\n      v8 = 83;\n      v9 = 69;\n      v10 = 67;\n      v11 = 97;\n      v12 = 78;\n      v13 = 72;\n      v14 = 51;\n      v15 = 110;\n      v16 = 103;\n      sub_4010F0(v7, 0, 10);\n      memset(v18, 0, 0xFFFFu);\n      v18[0] = String[5];\n      v18[2] = String[7];\n      v18[1] = String[6];\n      v4 = (const char *)sub_401000(v18, strlen(v18));\n      memset(v18, 0, 0xFFFFu);\n      v18[1] = String[3];\n      v18[0] = String[2];\n      v18[2] = String[4];\n      v5 = (const char *)sub_401000(v18, strlen(v18));\n      if ( String[0] == v7[0] + 34\n        &amp;&amp; String[1] == v10\n        &amp;&amp; 4 * String[2] - 141 == 3 * v8\n        &amp;&amp; String[3] / 4 == 2 * (v13 / 9)\n        &amp;&amp; !strcmp(v4, &quot;ak1w&quot;)\n        &amp;&amp; !strcmp(v5, &quot;V1Ax&quot;) )\n      &#123;\n        MessageBoxA(hDlg, &quot;U g3t 1T!&quot;, &quot;@_@&quot;, 0);\n      &#125;\n    &#125;\n    return 0;\n  &#125;\n  if ( (_WORD)a3 != 1 &amp;&amp; (_WORD)a3 != 2 )\n    return 0;\n  EndDialog(hDlg, (unsigned __int16)a3);\n  return 1;\n&#125;\n</code></pre><p>以及函数<code>sub_4010F0</code>：</p>\n<pre><code>int __cdecl sub_4010F0(int a1, int a2, int a3)\n&#123;\n  int result; // eax\n  int i; // esi\n  int v5; // ecx\n  int v6; // edx\n\n  result = a3;\n  for ( i = a2; i &lt;= a3; a2 = i )\n  &#123;\n    v5 = 4 * i;\n    v6 = *(_DWORD *)(4 * i + a1);\n    if ( a2 &lt; result &amp;&amp; i &lt; result )\n    &#123;\n      do\n      &#123;\n        if ( v6 &gt; *(_DWORD *)(a1 + 4 * result) )\n        &#123;\n          if ( i &gt;= result )\n            break;\n          ++i;\n          *(_DWORD *)(v5 + a1) = *(_DWORD *)(a1 + 4 * result);\n          if ( i &gt;= result )\n            break;\n          while ( *(_DWORD *)(a1 + 4 * i) &lt;= v6 )\n          &#123;\n            if ( ++i &gt;= result )\n              goto LABEL_13;\n          &#125;\n          if ( i &gt;= result )\n            break;\n          v5 = 4 * i;\n          *(_DWORD *)(a1 + 4 * result) = *(_DWORD *)(4 * i + a1);\n        &#125;\n        --result;\n      &#125;\n      while ( i &lt; result );\n    &#125;\nLABEL_13:\n    *(_DWORD *)(a1 + 4 * result) = v6;\n    sub_4010F0(a1, a2, i - 1);\n    result = a3;\n    ++i;\n  &#125;\n  return result;\n&#125;\n</code></pre><p>我们先来看那一堆的数字：</p>\n<pre><code>v7[0] = 90 对应字符 &quot;Z&quot;\nv7[1] = 74 对应字符 &quot;J&quot;\nv8 = 83 对应字符 &quot;S&quot;\nv9 = 69 对应字符 &quot;E&quot;\nv10 = 67 对应字符 &quot;C&quot;\nv11 = 97 对应字符 &quot;a&quot;\nv12 = 78 对应字符 &quot;N&quot;\nv13 = 72 对应字符 &quot;H&quot;\nv14 = 51 对应字符 &quot;3&quot;\nv15 = 110 对应字符 &quot;n&quot;\nv16 = 103 对应字符 &quot;g&quot;\n</code></pre><p><code>sub_4010F0</code>对这十个字符进行处理，C语言代码为：</p>\n<pre><code>#include&lt;stdio.h&gt;\n\nint __cdecl sub_4010F0(char* a1, int a2, int a3)\n&#123;\n  int result; // eax\n  int i; // esi\n  int v5; // ecx\n  int v6; // edx\n\n  result = a3;\n  for ( i = a2; i &lt;= a3; a2 = i )\n  &#123;\n    v5 = i;             // 源代码是v5 = 4 * i;  其实这个4指的是4个内存单位，也就是int占4个字节，如果是char的话就不需要了\n    v6 = i[a1];\n    if ( a2 &lt; result &amp;&amp; i &lt; result )\n    &#123;\n      do\n      &#123;\n        if ( v6 &gt; a1[result] )\n        &#123;\n          if ( i &gt;= result )\n            break;\n          ++i;\n          v5[a1] = a1[result];\n          if ( i &gt;= result )\n            break;\n          while ( a1[i] &lt;= v6 )\n          &#123;\n            if ( ++i &gt;= result )\n              goto LABEL_13;\n          &#125;\n          if ( i &gt;= result )\n            break;\n          v5 = i;\n          a1[result] = i[a1];\n        &#125;\n        --result;\n      &#125;\n      while ( i &lt; result );\n    &#125;\nLABEL_13:\n    a1[result] = v6;\n    sub_4010F0(a1, a2, i - 1);\n    result = a3;\n    ++i;\n  &#125;\n  return result;\n&#125;\n\n\nint main() &#123;\n\n    char *str = &quot;ZJSECaNH3ng&quot;;\n    sub_4010F0(str, 0, 10);\n    printf(&quot;%s&quot;, str);\n\n    return 0;\n&#125;\n</code></pre><p>运行得到<code>3CEHJNSZagn</code>。</p>\n<p>然后我们接下来看<code>sub_4010F0</code></p>\n<pre><code>_BYTE *__cdecl sub_401000(int a1, int a2)\n&#123;\n  int v2; // eax\n  int v3; // esi\n  size_t v4; // ebx\n  _BYTE *v5; // eax\n  _BYTE *v6; // edi\n  int v7; // eax\n  _BYTE *v8; // ebx\n  int v9; // edi\n  int v10; // edx\n  int v11; // edi\n  int v12; // eax\n  int i; // esi\n  _BYTE *result; // eax\n  _BYTE *v15; // [esp+Ch] [ebp-10h]\n  _BYTE *v16; // [esp+10h] [ebp-Ch]\n  int v17; // [esp+14h] [ebp-8h]\n  int v18; // [esp+18h] [ebp-4h]\n\n  v2 = a2 / 3;\n  v3 = 0;\n  if ( a2 % 3 &gt; 0 )\n    ++v2;\n  v4 = 4 * v2 + 1;\n  v5 = malloc(v4);\n  v6 = v5;\n  v15 = v5;\n  if ( !v5 )\n    exit(0);\n  memset(v5, 0, v4);\n  v7 = a2;\n  v8 = v6;\n  v16 = v6;\n  if ( a2 &gt; 0 )\n  &#123;\n    while ( 1 )\n    &#123;\n      v9 = 0;\n      v10 = 0;\n      v18 = 0;\n      do\n      &#123;\n        if ( v3 &gt;= v7 )\n          break;\n        ++v10;\n        v9 = *(unsigned __int8 *)(v3 + a1) | (v9 &lt;&lt; 8);\n        ++v3;\n      &#125;\n      while ( v10 &lt; 3 );\n      v11 = v9 &lt;&lt; (8 * (3 - v10));\n      v12 = 0;\n      v17 = v3;\n      for ( i = 18; i &gt; -6; i -= 6 )\n      &#123;\n        if ( v10 &gt;= v12 )\n        &#123;\n          *((_BYTE *)&amp;v18 + v12) = (v11 &gt;&gt; i) &amp; 0x3F;\n          v8 = v16;\n        &#125;\n        else\n        &#123;\n          *((_BYTE *)&amp;v18 + v12) = 64;\n        &#125;\n        *v8++ = byte_407830[*((char *)&amp;v18 + v12++)];\n        v16 = v8;\n      &#125;\n      v3 = v17;\n      if ( v17 &gt;= a2 )\n        break;\n      v7 = a2;\n    &#125;\n    v6 = v15;\n  &#125;\n  result = v6;\n  *v8 = 0;\n  return result;\n&#125;\n</code></pre><p>我们发现里面有个表<code>byte_407830</code>：</p>\n<p><img src=\"https://pic.imgdb.cn/item/654c8c57c458853aefe87fab.jpg\" alt=\"\"></p>\n<p>发现是标准<code>base64</code>，这里对<code>string</code>的5,6,7以及2,3,4位进行加密，加密的结果是<code>ak1w</code>以及<code>V1Ax</code>，解密得到：</p>\n<pre><code>jMp\nWP1\n</code></pre><p>结合<code>if</code>里面的判断条件：</p>\n<pre><code>if ( String[0] == v7[0] + 34\n        &amp;&amp; String[1] == v10\n        &amp;&amp; 4 * String[2] - 141 == 3 * v8\n        &amp;&amp; String[3] / 4 == 2 * (v13 / 9)\n        &amp;&amp; !strcmp(v4, &quot;ak1w&quot;)\n        &amp;&amp; !strcmp(v5, &quot;V1Ax&quot;) )\n</code></pre><p>我们可以知道<code>string</code>的值为（注意v7是加密后的）：</p>\n<pre><code>UJWP1jMp\n</code></pre><h2 id=\"简单注册机\"><a href=\"#简单注册机\" class=\"headerlink\" title=\"简单注册机\"></a>简单注册机</h2><p>拖进jadx，找到关键代码：</p>\n<pre><code>if (flag == 1) &#123;\n                    char[] x = &quot;dd2940c04462b4dd7c450528835cca15&quot;.toCharArray();\n                    x[2] = (char) ((x[2] + x[3]) - 50);\n                    x[4] = (char) ((x[2] + x[5]) - 48);\n                    x[30] = (char) ((x[31] + x[9]) - 48);\n                    x[14] = (char) ((x[27] + x[28]) - 97);\n                    for (int i = 0; i &lt; 16; i++) &#123;\n                        char a = x[31 - i];\n                        x[31 - i] = x[i];\n                        x[i] = a;\n                    &#125;\n                    String bbb = String.valueOf(x);\n                    textview.setText(&quot;flag&#123;&quot; + bbb + &quot;&#125;&quot;);\n                    return;\n                &#125;\n</code></pre><p>稍微改一下跑跑就能得到flag啦</p>\n<pre><code>temp = &quot;dd2940c04462b4dd7c450528835cca15&quot;\nx = []\nfor i in range(0, len(temp)):\n    x.append(ord(temp[i]))\n\nprint(x)\n\nx[2] = ((x[2] + x[3]) - 50)\nx[4] = ((x[2] + x[5]) - 48)\nx[30] = ((x[31] + x[9]) - 48)\nx[14] = ((x[27] + x[28]) - 97)\n\na = []\nfor i in range(0, 16):\n    a = x[31 - i]\n    x[31 - i] = x[i]\n    x[i] = a\n\nflag = &quot;&quot;\nfor i in range(0, len(x)):\n    flag += chr(x[i])\n\nprint(flag)\n</code></pre><h2 id=\"PyRE\"><a href=\"#PyRE\" class=\"headerlink\" title=\"PyRE\"></a>PyRE</h2><p>使用python反编译<a href=\"https://tool.lu/pyc/\">网站</a>或者工具。<a href=\"https://bbs.huaweicloud.com/blogs/377841\">python反编译相关看这里。</a></p>\n<p>反编译后的代码是python2.7版本的，由于我的python版本是3.xx，还需要进一步处理：</p>\n<pre><code>print(&#39;Welcome to Re World!&#39;)\nprint(&#39;Your input1 is your flag~&#39;)\ninput1 = input(&#39;Enter your input1 value: &#39;)\nl = len(input1)\ncode = []\nfor i in range(l):\n    num = ((ord(input1[i]) + i) % 128 + 128) % 128\n    code.append(num)\n\nfor i in range(l - 1):\n    code[i] = code[i] ^ code[i + 1]\n\nprint(code)\ncode = [\n    &#39;%1f&#39;,\n    &#39;%12&#39;,\n    &#39;%1d&#39;,\n    &#39;(&#39;,\n    &#39;0&#39;,\n    &#39;4&#39;,\n    &#39;%01&#39;,\n    &#39;%06&#39;,\n    &#39;%14&#39;,\n    &#39;4&#39;,\n    &#39;,&#39;,\n    &#39;%1b&#39;,\n    &#39;U&#39;,\n    &#39;?&#39;,\n    &#39;o&#39;,\n    &#39;6&#39;,\n    &#39;*&#39;,\n    &#39;:&#39;,\n    &#39;%01&#39;,\n    &#39;D&#39;,\n    &#39;;&#39;,\n    &#39;%&#39;,\n    &#39;%13&#39;]\n</code></pre><p>解密脚本</p>\n<pre><code>code = [&#39;\\x1f&#39;, &#39;\\x12&#39;, &#39;\\x1d&#39;, &#39;(&#39;, &#39;0&#39;, &#39;4&#39;, &#39;\\x01&#39;,\n        &#39;\\x06&#39;, &#39;\\x14&#39;, &#39;4&#39;, &#39;,&#39;, &#39;\\x1b&#39;, &#39;U&#39;, &#39;?&#39;, &#39;o&#39;,\n        &#39;6&#39;, &#39;*&#39;, &#39;:&#39;, &#39;\\x01&#39;, &#39;D&#39;, &#39;;&#39;, &#39;%&#39;, &#39;\\x13&#39;]\n\nl = len(code)\nfor i in range(0, l - 1):\n    code[l-i-2]=chr(ord(code[l-i-2])^ord(code[l-i-1]))\n\nflag = &quot;&quot;\nprint(code)\nfor i in range(0, len(code)):\n    num = ((ord(code[i]) - i) % 128) % 128\n    flag += (chr(num))\n\nprint(flag)\n</code></pre><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里有一个问题就是第7行如果去掉<code>chr</code>就会报错</p>\n<pre><code>code[l-i-2]=(ord(code[l-i-2])^ord(code[l-i-1]))\n                               ^^^^^^^^^^^^^^^^\nTypeError: ord() expected string of length 1, but int found\n</code></pre><p>我们发现这个时候<code>code[l-i-1])</code>已经是个整型了。这是python3中<code>ord()</code>的一个bug（？）</p>\n<p><del>有没有人告诉我为什么加上<code>chr</code>就可以了啊</del></p></blockquote>\n","feature":true,"text":"Buuoj-Reverse WP-1来学学逆向工程，顺便学学计组 reverse1在strings窗口发现flag，但直接输入发现flag错误。 进行反汇编，发...","permalink":"/post/WP-1","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":1,"path":"api/tags/CTF.json"},{"name":"Reverse","slug":"Reverse","count":1,"path":"api/tags/Reverse.json"},{"name":"buuoj","slug":"buuoj","count":1,"path":"api/tags/buuoj.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Buuoj-Reverse-WP-1\"><span class=\"toc-text\">Buuoj-Reverse WP-1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reverse1\"><span class=\"toc-text\">reverse1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reverse2\"><span class=\"toc-text\">reverse2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%B6%B5%E7%9A%84%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">内涵的软件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90\"><span class=\"toc-text\">新年快乐</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XOR\"><span class=\"toc-text\">XOR</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reverse3\"><span class=\"toc-text\">reverse3</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SimpleRev\"><span class=\"toc-text\">SimpleRev</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaRev\"><span class=\"toc-text\">JavaRev</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GXYCTF2019-luck-guy\"><span class=\"toc-text\">[GXYCTF2019]luck_guy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BJDCTF2020-JustRE\"><span class=\"toc-text\">[BJDCTF2020]JustRE</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96\"><span class=\"toc-text\">刮开有奖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E6%B3%A8%E5%86%8C%E6%9C%BA\"><span class=\"toc-text\">简单注册机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PyRE\"><span class=\"toc-text\">PyRE</span></a></li></ol></li></ol>","author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"这里是破酥的个人博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"主存储的组织","uid":"d6f1871fd5f6793b4b505709f6e722ba","slug":"主存储的组织","date":"2023-11-13T12:22:17.000Z","updated":"2023-11-13T12:22:50.314Z","comments":true,"path":"api/articles/主存储的组织.json","keywords":null,"cover":[],"text":"主存储器的组织 本节PPT内容位于书本P260 一些概念： 主存容量=字数位数 字数：可编址存储单元数 位数：每个编址存储单元的位数 地址译码方法 全地址译码方...","permalink":"/post/主存储的组织","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","count":1,"path":"api/tags/计算机组成原理.json"}],"author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"这里是破酥的个人博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}