{"title":"Java类和对象","uid":"e8805eec5bdd2acbc81f5c8e275b0c0a","slug":"Java类和对象","date":"2023-09-05T06:23:22.000Z","updated":"2023-09-17T11:28:30.204Z","comments":true,"path":"api/articles/Java类和对象.json","keywords":null,"cover":[],"content":"<h2 id=\"Java类和对象\"><a href=\"#Java类和对象\" class=\"headerlink\" title=\"Java类和对象\"></a>Java类和对象</h2><p>类的变量描述对象的属性，类的方法体现对象的行为。封装在类中的这些数据的变量和方法，为对象的创建提供了模板。<br>对象之间的交互作用是通过对象的消息机制实现的。所谓消息是对象对其他或者自身方法的访问，一个消息的产生就是一个对象方法的调用。<br>类和对象是面向对象程序设计中的基本概念，也是编程方法的基础。类就是Java的执行单位。Java运行的就是Java类本身。</p>\n<p>OOP的最重要的好处之一是对数据和操作该数据的代码的封装，通过类来完成封装性。<br>在创建一个类时，你正在创建一种新的数据类型，不但要定义数据的属性，也要定义操作数据的代码。<br>方法定义了对该类数据相一致的控制接口。<br>通过类的方法来使用类，而没有必要担心它的实现细节或在类的内部数据实际上是如何被管理的。<br>既然细节被隐蔽，当需要时，它的内部工作可以被改变。只要你的代码通过类的方法来使用它，内部的细节可以改变而不会对类的外部带来负面影响。</p>\n<span id=\"more\"></span>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象是现实世界事物的模型化。用变量来表示状态，用方去来实现行为。对象的变量组成了对象的中心或核，而方法是围绕在变量四周的。</p>\n<p>封装:某一对象的变量对程序中的其它的对象而言是隐藏的，它是在这个对象方法的保护监理之下。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64f9997b661c6c8e5459da8a.png\" alt=\"\"></p>\n<h3 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h3><p>消息是软件对象之间相互作用和互相联系。对象的行为由方法来实现，消息传递是对象之间进行交互的主要方式。</p>\n<ul>\n<li>接收消息的对象(目标对象)</li>\n<li>接收者采用的方法(目标方法)</li>\n<li>方法所需传递的参数</li>\n</ul>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>类定义了对象的类型。包括对象内部的数据，它是对象的寺性，和对象对自己的数据上的操作功能。因此类就是对象的模板。类是某种对象共有的状态和行为的原 型。<br>一个类可以有许多的对象，每一个对象都是这个类的一个实例，它们也就都具有相同的特征。</p>\n<h2 id=\"类的创建\"><a href=\"#类的创建\" class=\"headerlink\" title=\"类的创建\"></a>类的创建</h2><p>一个类包括三个部分：</p>\n<ul>\n<li><p>类声明</p>\n</li>\n<li><p>类成员</p>\n</li>\n<li><p>类的构造器（方法）</p>\n<pre><code>class &lt;Declaration&gt;&#123;\n\n    &lt;classBody&gt;\n\n&#125;\n</code></pre></li>\n</ul>\n<p>类的一般声明形式：</p>\n<pre><code>[public] class &lt;clsName&gt; extends &lt;supCls&gt; implements&lt;intf&gt;\n</code></pre><p><code>class</code>是表示创建类的关键字</p>\n<p><code>&lt;clsName&gt;</code>是Java合法标识符<br><code>[public]</code>是可选项，表示该类是<code>public</code>类;类的可选项还有<code>abstract, final</code>等等;<br><code>extends &lt;superCls&gt;</code>则是继承性表示，该类继承了类<code>&lt;superCls&gt;</code></p>\n<p><code>implements &lt;intf&gt;</code>则是对接口实现表示，该类实现了接口<code>&lt;intf&gt;</code></p>\n<h3 id=\"类体定义\"><a href=\"#类体定义\" class=\"headerlink\" title=\"类体定义\"></a>类体定义</h3><ul>\n<li><strong>成员变量</strong>：在类中创建的变量，表示对象属性</li>\n<li><strong>成员方法</strong>：类的方法表示对象的行为或能力</li>\n<li><strong>类的构造器（方法）</strong>：为创建类的实例所使用</li>\n</ul>\n<pre><code>classDeclaration &#123;\n    &lt;memberVariableDeclaration&gt;\n    &lt;memberMethodDeclaration&gt;\n    &lt;classStructorDeclaration&gt;\n&#125;\n</code></pre><h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><ul>\n<li><p>在类中创建的变量，表示对象属性</p>\n</li>\n<li><p>作用域在类中是全局的，能被类中所有方法所访问</p>\n</li>\n<li><p>在创建时有初始化值</p>\n<pre><code>&lt;type&gt; variableList = initialValue;\n</code></pre></li>\n</ul>\n<p>常用修饰符：</p>\n<ul>\n<li><p>访问权限控制：</p>\n<p><code>public</code>：公开，谁都能访问</p>\n<p><code>protected</code>：</p>\n<p><code>private</code>：</p>\n</li>\n<li><p>使用限制</p>\n<p><code>final</code>：</p>\n<p>使用修饰符final修饰的变量就像常量一样地使用，称其为常量符号。<br>常量符号数据只能读取，不能改变。通常常量符号标识符全用大写字母，单词间用“_”分隔。</p>\n<pre><code>final int MAX_MONTH = 12;\nfinal int MAX_DAY = 31;\nfinal int MAX_WEEK = 7;\n</code></pre><p><code>static</code>：</p>\n<p><code>transient</code>：</p>\n<p><code>volatile</code>：</p>\n</li>\n</ul>\n<h3 id=\"成员方法\"><a href=\"#成员方法\" class=\"headerlink\" title=\"成员方法\"></a>成员方法</h3><pre><code>[accessControl] returnType methodName(paraList)\n</code></pre><p><code>[accessControl]</code>是可选项，为访问控制修饰符，限定访问权限。</p>\n<p><code>returnType</code>是方法返回数据类型，它表示方法返回时返回数据的类型。</p>\n<p><code>methodName</code>是方法名，它是Java合法标识符</p>\n<p><code>paraList</code>是方法参数列表，表示方法调用时所带参数。称为形式参数。</p>\n<pre><code>int getMax(int a, int b)\nvoid setData(int x, int y)\n</code></pre><p>方法体由语句及语句块组成，包含有：</p>\n<ul>\n<li>局部变量声明</li>\n<li>流程控制语句</li>\n<li>语句块</li>\n<li><code>return</code>（看情况）</li>\n</ul>\n<p><strong>方法调用时的参数传递</strong></p>\n<p>方法在被调用时，其参数的数据传递是值传递，即实际参数传值给形式参数。</p>\n<p>形式参数是简单类型，在方法调用时，实际参数将其存储单元的数据赋值给形式参数。</p>\n<p>形式参数是引用类型，在方法中，引用类型的参数没有发生引用的改变，则形式参数对引用中的变量值改变自然会影响到实际参数引用中变量的值。</p>\n<pre><code>Point pi=new Point(1,2);void setRefer1(Point p)    &#123;\n    p.x = 10;\n    p.y = 20;\n&#125;\nsetRefer1(pi)\n</code></pre><p>参数p是引用类型，其成员的x,y值发生改变，会影响调用的实参，即函数结束后成员x和y的值改变。</p>\n<pre><code>Point pi=new Point(1, 2)void setRefer2(Point p) &#123;\n    p= new Point();\n    p.x = 10;\n    p.y = 20;\n&#125;\nsetRefer2(pi)\n</code></pre><p>参数p是引用类型，改变引用，其变量x,y值发生改变，不会影响调用的实参，函数调用结束后pi的成员值不变。</p>\n<h2 id=\"方法过载\"><a href=\"#方法过载\" class=\"headerlink\" title=\"方法过载\"></a>方法过载</h2><p>在同一个类中创建的具有相同方法名，但是参数不同的方法。方法过载中的方法由调用时的实参决定调用的方法是哪个。</p>\n<ul>\n<li>数量不同</li>\n<li>数量相同，但是对应的类型不同</li>\n</ul>\n<h2 id=\"类的构造方法\"><a href=\"#类的构造方法\" class=\"headerlink\" title=\"类的构造方法\"></a>类的构造方法</h2><p>每一类都有自己的构造方法，或者称为类的构造器。构造方法是用来创建一个类的实例的。</p>\n<p>构造方法使用类名作构造方法名，构造方法具有有参数和语句体，但没有返回类型的声明。如果<strong>有返回类型声明</strong>，则此方法就再不是构造方法，而成为一个一般的成员方法。构造方法不是类的成员方法，所以不能用对象调用它。构造方法的调用是由new运算符实现。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li><p>构造方法返回的是这个类的实例的引用</p>\n</li>\n<li><p>构造方法中的语句实现对成员变量的初始化</p>\n</li>\n<li><p>构造方法的方法过载。一个类可以有多个构造方法</p>\n</li>\n<li><p>构造方法之间通过this()形式相互调用</p>\n</li>\n</ul></blockquote>\n<p><strong>默认构造方法</strong>：指不带参数的构造方法，该方法可以有语句，也可以没有语句</p>\n<p><strong>非默认构造方法</strong>：指带参数的构造方法</p>\n<p>类创建时没有创建构造器，则在编译时编译器自动为该类添加一个默认构造器，即没有创建构造器的类可以直接使用默认构造器。</p>\n<p>类创建时如果有任何构造器被创建，则在编译时编译器不再为该类创建默认构造器。即创建了构造方法的类，不自动有一个默认的构造方法，或者说默认构造器失效，除非也创建一个不带参数的构造器。</p>\n<h2 id=\"类成员和实例成员\"><a href=\"#类成员和实例成员\" class=\"headerlink\" title=\"类成员和实例成员\"></a>类成员和实例成员</h2><p>类成员见另一篇文章 ’static的用法‘。</p>\n<p><strong>实例成员</strong>：通过创建实例才能访问和使用的成员，创建对象，由对象访问，如<code>p.x=10</code>。实例成员不能用类名直接访问，比如<code>Point.x</code>访问是不合法的。</p>\n<h2 id=\"对象创建和使用\"><a href=\"#对象创建和使用\" class=\"headerlink\" title=\"对象创建和使用\"></a>对象创建和使用</h2><p>对象：是一个变量，它的存储开销是一个地址存储单元。</p>\n<p>实例：是在存储空间分配的存储堆。是垃圾回收的目标。</p>\n<p>引用：对象通过它存储的实例的起始地址对实例实现访问。</p>\n<p>对象的生命周期:创建、使用和销毁三个阶段。</p>\n<p>创建:分两步。</p>\n<ul>\n<li><p>声明:</p>\n<pre><code>Point p;\n</code></pre></li>\n<li><p>实例化:<br>通过new运算符调用构造器，通过赋值=对这个实例引用。</p>\n<pre><code>p = new Point();\n</code></pre></li>\n<li><p>对象使用：</p>\n<p>通过对象名对成员的访问，注意这里是对象名不是类名：</p>\n<pre><code>p.x=100;\nint temp = p.getData();\n</code></pre></li>\n<li><p>销毁：</p>\n<p>垃圾回收:实例开销的回收。</p>\n<p>由JVM自动完成。</p>\n<p>调用<code>finalize()</code>方法处理。</p>\n<p>Java程序运行时系统通过垃圾收集，周期性地释放不再被对象引用所占用的内存，完成对象的清除.</p>\n<p><code>finalize</code>方法：</p>\n<p>Java在对象作为垃圾被收集前，自动调用对象从Object类继承来的finalize()方法，清除自己所占用的资源。该方法声明的格式:</p>\n<pre><code>protected void finalize() throws throwable &#123;\n//clean up code for this class\n    super.finalize();\n&#125;\n</code></pre></li>\n</ul>\n<pre><code>class Point &#123;\n    int x,y;\n    Point(int a, int b) &#123;\n        x = a;\n        y = b;\n    &#125;\n    Point() &#123; \n        this(0.0);\n    &#125;\n    void setData(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n        &#125;\n&#125;\n</code></pre>","text":"Java类和对象类的变量描述对象的属性，类的方法体现对象的行为。封装在类中的这些数据的变量和方法，为对象的创建提供了模板。对象之间的交互作用是通过对象的消息机制...","permalink":"/post/Java类和对象","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"编程","slug":"编程","count":8,"path":"api/categories/编程.json"},{"name":"java","slug":"编程/java","count":6,"path":"api/categories/编程/java.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">Java类和对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">消息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">类的创建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%BD%93%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">类体定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">成员变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">成员方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E8%BF%87%E8%BD%BD\"><span class=\"toc-text\">方法过载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">类的构造方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%88%90%E5%91%98%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98\"><span class=\"toc-text\">类成员和实例成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">对象创建和使用</span></a></li></ol>","author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"matlab基础入门","uid":"cb09ea597c4ce0f4355fa56a3ee4d067","slug":"matlab基础入门","date":"2023-09-11T00:56:02.000Z","updated":"2023-09-16T02:56:07.890Z","comments":true,"path":"api/articles/matlab基础入门.json","keywords":null,"cover":null,"text":"matlab基础入门学数值计算学的（悲 使用的是 MATLAB R2016a 版本。 矩阵和数组矩阵运算是 MATLAB 最厉害的部分，其主要用于处理整个的矩阵...","permalink":"/post/matlab基础入门","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":8,"path":"api/categories/编程.json"},{"name":"matlab","slug":"编程/matlab","count":1,"path":"api/categories/编程/matlab.json"}],"tags":[],"author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"java异常处理","uid":"ee304ea14cdfef400724bb1ab6bff757","slug":"java异常处理","date":"2023-09-03T02:32:19.000Z","updated":"2023-09-07T09:51:03.538Z","comments":true,"path":"api/articles/java异常处理.json","keywords":null,"cover":null,"text":"Java异常处理在Java中，异常处理是一种机制，用于处理程序运行时可能出现的错误或异常情况，以便程序能够优雅地处理这些问题而不会崩溃。 try-catchtr...","permalink":"/post/java异常处理","photos":[],"count_time":{"symbolsCount":698,"symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":8,"path":"api/categories/编程.json"},{"name":"java","slug":"编程/java","count":6,"path":"api/categories/编程/java.json"}],"tags":[],"author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}