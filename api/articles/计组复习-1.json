{"title":"计组复习-1","uid":"66c8c18b39717219057479840ba6c9df","slug":"计组复习-1","date":"2023-12-13T11:53:39.000Z","updated":"2023-12-24T01:24:05.314Z","comments":true,"path":"api/articles/计组复习-1.json","keywords":null,"cover":[],"content":"<h1 id=\"计算机中的信息表示\"><a href=\"#计算机中的信息表示\" class=\"headerlink\" title=\"计算机中的信息表示\"></a>计算机中的信息表示</h1><p><strong>一、基本概念及应用（注明：应用是指基本概念的应用）</strong></p>\n<ol>\n<li>一个数值型数据的完整表示需三个方面？</li>\n<li>权、基数？</li>\n<li>真值？机器数的定义？分类？</li>\n<li>数的定点表示与浮点表示？</li>\n<li>指令？指令系统？</li>\n<li>地址码？寻址方式？地址结构？</li>\n<li>寻址方式：</li>\n</ol>\n<p>大致可将众多的寻址方式归纳为以下四大类，其它的寻址方式则是它们的变型或组合。</p>\n<p>① 立即寻址。在读取指令时也就从指令之中获得了操作数，即操作数包含在指令中。</p>\n<p>② 直接寻址类。直接给出主存地址或寄存器编号，从CPU内或主存单元内读取操作数。</p>\n<p>③ 间接寻址类。先从某寄存器中或主存中读取地址，再按这个地址访问主存以读取操作数。</p>\n<p>④ 变址类。指令给出的是形式地址（不是最终地址），经过某种变换（例如相加、相减、高低位地址拼接等），才获得有效地址，据此访问主存储器以读取操作数。</p>\n<p>8.何谓隐式I/O指令？其主要特点是什么？</p>\n<p>9.主机调用外围设备，外设编制可采用那几种方式？</p>\n<p><strong>二、计算题                                                    </strong></p>\n<p>1.扩展操作码：根据条件计算指令条数？</p>\n<p>2.根据寻址方式寻找操作数？</p>\n<p>3.IEEE754短浮点数格式表示？</p>\n<h2 id=\"进位计数值及其相互转换\"><a href=\"#进位计数值及其相互转换\" class=\"headerlink\" title=\"进位计数值及其相互转换\"></a>进位计数值及其相互转换</h2><p>多位数码中<strong>每一位数码的构成方法</strong>及从<strong>低位向高位的进位规则</strong>称为进位计数制，简称<strong>数制</strong>。</p>\n<p><strong>基数</strong>：每个数位中所允许的最大数码值+1或每个数位中所允许的最多数码个数。</p>\n<p><strong>权</strong>：是一个与所在数位相关的常数。</p>\n<p>权与基数的关系：相邻两位的权值之比等于基数值。</p>\n<p><img src=\"https://pic.imgdb.cn/item/6579a44cc458853aefdedaa5.jpg\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/6579a53ec458853aefe31522.jpg\" alt=\"\"></p>\n<h3 id=\"十进制\"><a href=\"#十进制\" class=\"headerlink\" title=\"十进制\"></a>十进制</h3><p>十进制转二进制：</p>\n<ul>\n<li>整数：除基取余（<strong>倒序排列</strong>）直至商为0（转R进制也相同）</li>\n<li>小数：乘基取整（<strong>顺序排列</strong>）直至小数为0或达到指定位数（转R进制也相同）</li>\n</ul>\n<p>二进制转十进制：按权展开各部分相加（转R进制也相同）</p>\n<h3 id=\"二进制\"><a href=\"#二进制\" class=\"headerlink\" title=\"二进制\"></a>二进制</h3><p>八进制：从小数点起分别向左向右<strong>三位一组</strong>，不够三位时整数不够在前面添0，小数不够在后面添0。八进制转二进制则相反。</p>\n<p>十六进制：从小数点起分别向左向右<strong>四位一组</strong>，不够三位时整数不够在前面添0，小数不够在后面添0。十六进制转二进制则相反。</p>\n<h2 id=\"带符号数的表示\"><a href=\"#带符号数的表示\" class=\"headerlink\" title=\"带符号数的表示\"></a>带符号数的表示</h2><p><strong>真值</strong>：用正负号与绝对值表示数值</p>\n<p><strong>机器数表示</strong>：</p>\n<p>机器数：在计算机内部使用，将<strong>符号数值化</strong></p>\n<p>机器数由<strong>符号位+有效位</strong>构成，<strong>最高位表示符号</strong>（正0负1）。</p>\n<h3 id=\"原码\"><a href=\"#原码\" class=\"headerlink\" title=\"原码\"></a>原码</h3><p>正数原码符号为0，负数原码符号为1；<strong>有效位与真值有效位相同</strong>。</p>\n<p>真值0有两种表示：</p>\n<p>$\\begin{array}{l}<br>{[+0]_{\\text {原 }}=00000000 \\mathrm{~B} ;} \\\\<br>{[-0]_{\\text {原 }}=10000000 \\mathrm{~B} ;}<br>\\end{array}$</p>\n<p>n位整数原码（含一位符号）的表示范围：$-\\left(2^{n-1}-1\\right) \\sim+\\left(2^{n-1}-1\\right)$</p>\n<p>n位纯小数原码（含一位符号）的表示范围：$-\\left(1-2^{-(n-1)}\\right) \\sim+\\left(1-2^{-(n-1)}\\right)$</p>\n<h3 id=\"反码\"><a href=\"#反码\" class=\"headerlink\" title=\"反码\"></a>反码</h3><p><strong>正数</strong>：反码符号为0，有效位与真值有效位<strong>相同</strong></p>\n<p><strong>负数：</strong>反码符号为1，有效位为真值有效位各位<strong>取反</strong></p>\n<p>真值0有两种表示：</p>\n<p>$\\begin{array}{l}<br>{[+0]_{反}=00000000 \\mathrm{~B} ;} \\\\<br>{[-0]_{反}=11111111 \\mathrm{~B} ;}<br>\\end{array}$</p>\n<p>n位整数反码（含一位符号）的表示范围：$-\\left(2^{n-1}-1\\right) \\sim+\\left(2^{n-1}-1\\right)$</p>\n<p>n位纯小数反码（含一位符号）的表示范围：$-\\left(1-2^{-(n-1)}\\right) \\sim+\\left(1-2^{-(n-1)}\\right)$</p>\n<h3 id=\"补码\"><a href=\"#补码\" class=\"headerlink\" title=\"补码\"></a>补码</h3><p><strong>正数</strong>：补码符号为0，有效位与真值有效位<strong>相同</strong></p>\n<p><strong>负数：</strong>补码符号为1，有效位为真值有效位各位<strong>取反后末位+1</strong></p>\n<p>真值0只有一种表示：00000000B</p>\n<p><strong>编码100000000B表示-128（8位补码表示的最小负数）</strong>。</p>\n<p>n位整数补码（含一位符号）的表示范围：$-2^{n-1} \\sim+\\left(2^{n-1}-1\\right)$</p>\n<p>n位纯小数补码（含一位符号）的表示范围：$-1\\sim +(1-2^{-(n-1)})$</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li><strong>原码两次取补还是原码</strong>，常用于补码求原码。 </li>\n<li>正数的原码、反码、补码相同</li>\n</ul></blockquote>\n<h3 id=\"补码加减运算\"><a href=\"#补码加减运算\" class=\"headerlink\" title=\"补码加减运算\"></a>补码加减运算</h3><p>操作数用补码表示，<strong>符号位一起参与运算</strong>；运算结果为补码形式，结果符号通过运算得到。</p>\n<p>补码加：两个数的补码之和等于两个数之和的补码，即$(X+Y)_补=X_补+Y_补$</p>\n<p>补码减：两个数的补码之差等于两个数之差的补码，即$(X-Y)_补=X_补-Y_补=X_补+(-Y)_补$</p>\n<p><strong>特别注意$(-Y)_补$</strong>：将$Y_补$<strong>连同符号位</strong>一起各位变反，末位+1，称为<strong>求补（变补）</strong>操作</p>\n<p>补码表示：原码转补码</p>\n<p>变补：补码连同符号位取反末位加1，称为补码的机器负数。</p>\n<h4 id=\"溢出\"><a href=\"#溢出\" class=\"headerlink\" title=\"溢出\"></a>溢出</h4><p>超出8位补码能表示的最大正数127产生<strong>正溢</strong>，如$(126+2)_补$</p>\n<p>超出8位补码能表示的最小负数-128产生<strong>负溢</strong>，如$(-2-(127))_补$</p>\n<h3 id=\"定点数\"><a href=\"#定点数\" class=\"headerlink\" title=\"定点数\"></a>定点数</h3><p><strong>小数点位置固定不变</strong>的数称为定点数。</p>\n<ul>\n<li>无符号定点整数：正整数，不考虑符号位，所有数位都用于表示有效值。</li>\n<li>带符号定点整数：纯整数，小数点在最低位之后，最高位为符号位，其余表示有效位。</li>\n<li>带符号定点小数：纯小数，最高位为符号位，小数点位于符号位之后，用原码或补码表示。</li>\n</ul>\n<p>定点数表示的范围和分辨率（相邻两个数位的差）与二进制序列的位数有关。</p>\n<p><img src=\"https://pic.imgdb.cn/item/6579b950c458853aef47d986.jpg\" alt=\"\"></p>\n<h3 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h3><p>小数点位置不固定，可随需要浮动。</p>\n<h4 id=\"真值\"><a href=\"#真值\" class=\"headerlink\" title=\"真值\"></a>真值</h4><p>$\\mathbf{N}= \\pm \\mathbf{R}^{\\mathrm{E}} \\times \\mathbf{M}$</p>\n<p>式中$  N  $为真值，$R^{E}  $为比例因子，$M  $是尾数,  $E  $为阶码， $R  $为阶码的底；</p>\n<p>对于某种特定浮点格式，<strong>R固定不变且隐含约定</strong>，一般选择与尾数M的基数相同。</p>\n<h4 id=\"浮点数的机器格式\"><a href=\"#浮点数的机器格式\" class=\"headerlink\" title=\"浮点数的机器格式\"></a>浮点数的机器格式</h4><p><img src=\"https://pic.imgdb.cn/item/6579bb05c458853aef4fa335.jpg\" alt=\"\"></p>\n<p>E：阶码，<strong>带符号定点整数</strong>，可用<strong>补码或移码</strong>表示；指明小数点位置，决定浮点数的表示范围。</p>\n<p>M：尾数，<strong>带符号定点小数</strong>，可用<strong>补码或原码</strong>表示；给出有效值位数，决定浮点数的精度。</p>\n<p><strong>尾数规格化</strong>（绝对值的最高位为1）：</p>\n<ul>\n<li>原码表示：$1/2\\leq|M|&lt;1$</li>\n<li>补码表示：$1/2\\leq M&lt;1,-1\\leq M\\leq -1/2$<ul>\n<li>例如：0.1001，1.0111，<strong>1.1（特例，真值-1/2）</strong></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://pic.imgdb.cn/item/6579bd4dc458853aef5b4350.jpg\" alt=\"\"></p>\n<h4 id=\"移码\"><a href=\"#移码\" class=\"headerlink\" title=\"移码\"></a>移码</h4><p>常用于表示浮点数的<strong>阶码</strong>。</p>\n<p>定义：真值$  X  $的$  m+1  $位（含一位符号位）移码表示为：</p>\n<p>$X_{\\text {移 }}=2^{m}+X $，其中：$-2^{m} \\leqslant X&lt;2^{m}$</p>\n<p>相当于真值X沿坐标轴平移了$  2^{m} $，所以称为移码。</p>\n<p>我们需要注意，移码和补码符号是相反的，<strong>真值为负移码永远为正，为正移码永远为负</strong>。</p>\n<p><img src=\"https://pic.imgdb.cn/item/6579be48c458853aef5ff1ac.jpg\" alt=\"\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>最高位为符号位，正数移码符号位为1, 负数移码符号位为0，<strong>与原码、补码表示相反</strong></li>\n<li>除符号位之外，<strong>移码的其余各位与补码相同</strong></li>\n<li>随着$X$从最小逐渐增至最大，相应地$X_移$从$00\\cdots00$逐渐增至$  11 \\cdots \\cdots \\cdot 11 $，呈递增状，能更直观地比较阶码大小。</li>\n</ul>\n<h3 id=\"IEEE754（非常重要，必考）\"><a href=\"#IEEE754（非常重要，必考）\" class=\"headerlink\" title=\"IEEE754（非常重要，必考）\"></a>IEEE754（非常重要，必考）</h3><p><img src=\"https://pic.imgdb.cn/item/6579bf41c458853aef6485f3.jpg\" alt=\"\"></p>\n<ul>\n<li><p><strong>短浮点数</strong>（或称短实数、单精度浮点数，32位）</p>\n</li>\n<li><p><strong>长浮点数</strong>（或称长实数、双精度浮点数，64位）</p>\n</li>\n<li><p><strong>临时浮点数</strong>（或称临时实数、扩展精度浮点数，80位）</p>\n</li>\n</ul>\n<p><img src=\"https://pic.imgdb.cn/item/6579bf75c458853aef658797.jpg\" alt=\"\"></p>\n<p>根据浮点数的尾数规格化，我们<strong>省略了一位数字$2^0$</strong>，所以实际上尾数数值应该有24位。</p>\n<p><strong>十进制真值转换为浮点数</strong>：</p>\n<ul>\n<li>先将十进制转换为二进制</li>\n<li>规格化二进制数（隐藏尾数最高位1，还原为真值时需要加回来）</li>\n<li>计算移码表示的阶码，表示为二进制（<strong>偏置值+阶码真值</strong>）</li>\n<li>以短浮点数格式存储该数</li>\n</ul>\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><p><img src=\"https://pic.imgdb.cn/item/6579c0afc458853aef6b515c.jpg\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/6579c0dbc458853aef6c2b49.jpg\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/6579c113c458853aef6d37b1.jpg\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/6579c147c458853aef6e3275.jpg\" alt=\"\"></p>\n<h4 id=\"IEEE754转为十进制真值\"><a href=\"#IEEE754转为十进制真值\" class=\"headerlink\" title=\"IEEE754转为十进制真值\"></a>IEEE754转为十进制真值</h4><p>单精度浮点计算公式</p>\n<p>$(-1)^{S} \\times 1 . M \\times 2^{E-127}\\left\\{\\begin{array}{l}<br>S: \\text { 符号位 (1为负, } 0 \\text { 为 正) } \\\\<br>M: \\text { 尾数, 表示小数 } \\\\<br>E: \\text { 阶码 }<br>\\end{array}\\right.$</p>\n<p>其他精度只需更换对应的偏置值即可。</p>\n<p><img src=\"https://pic.imgdb.cn/item/6579c1d0c458853aef70c3d7.jpg\" alt=\"\"></p>\n<h1 id=\"指令-amp-指令系统\"><a href=\"#指令-amp-指令系统\" class=\"headerlink\" title=\"指令&amp;指令系统\"></a>指令&amp;指令系统</h1><p>指令：一系列按照某种规律有序排列的，能被CPU识别、执行的二进制代码。</p>\n<p>指令系统（或集）：一台计算机所能执行的全部指令。</p>\n<p>指令系统—-对应—-计算机硬件功能</p>\n<h2 id=\"指令基本格式\"><a href=\"#指令基本格式\" class=\"headerlink\" title=\"指令基本格式\"></a>指令基本格式</h2><p>一条指令提供两方面的信息：</p>\n<p>① 与CPU操作有关的信息—-操作码（OP）</p>\n<p>② 与操作数有关的信息—-地址码（AD）。</p>\n<p>注意：一条指令中的<strong>操作码OP有且仅有一个</strong>，而<strong>地址码A可有0、1、2、3个</strong>。</p>\n<p>$\\begin{array}{|l|l|}<br>\\hline \\text { 操作码OP } &amp; \\text { 地址码 } \\mathrm{A} \\\\<br>\\hline<br>\\end{array}$</p>\n<p>指令长度：影响指令执行时间</p>\n<p>在1~7个字节之间，操作码1~2B，操作数（地址码）0~2个</p>\n<p>指令类型：</p>\n<ul>\n<li>零操作数：可隐含提供操作数</li>\n<li>单操作数：可隐含提供另一个操作数</li>\n<li>双操作数</li>\n</ul>\n<p>指令格式设计时需要注意：</p>\n<ul>\n<li><p>指令字长</p>\n<ul>\n<li>固定字长</li>\n<li>可变字长</li>\n</ul>\n</li>\n<li><p>操作码</p>\n<ul>\n<li>位数与位置固定</li>\n<li>可扩展</li>\n</ul>\n</li>\n<li><p>地址码</p>\n<ul>\n<li><p>涉及的地址</p>\n</li>\n<li><p>指令中给出地址</p>\n<ul>\n<li>数量</li>\n<li>显式地址：0123地址指令</li>\n<li>隐式地址</li>\n</ul>\n<p><strong>简化地址结构</strong>的基本途径：<strong>尽量使用隐地址</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p>寻址方式</p>\n<ul>\n<li>直接寻址</li>\n<li>间接寻址</li>\n<li>经过某种变换（包括计算）获取</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"操作码\"><a href=\"#操作码\" class=\"headerlink\" title=\"操作码\"></a>操作码</h2><p>操作码的位数决定了操作类型的多少，位数越多所能表示的操作种类也就越多。</p>\n<ul>\n<li><p>定长操作码</p>\n<p>指令长度比较长时，位置、位数固定，位置在指令的前几位</p>\n</li>\n<li><p>扩展操作码：</p>\n<p>指令长度比较长时，位置、位数不固定，用扩展标志表示</p>\n</li>\n</ul>\n<h2 id=\"扩展操作码\"><a href=\"#扩展操作码\" class=\"headerlink\" title=\"扩展操作码\"></a>扩展操作码</h2><p><img src=\"https://pic.imgdb.cn/item/657c2b1ac458853aef0a2d7a.jpg\" alt=\"\"></p>\n<p>设地址长度为n，上一层留出m种状态，下一层便可扩展出$m\\times 2^n$种状态。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c2b3ec458853aef0aae1d.jpg\" alt=\"\"></p>\n<h2 id=\"地址结构\"><a href=\"#地址结构\" class=\"headerlink\" title=\"地址结构\"></a>地址结构</h2><p>在指令中明确给出几个地址，给出哪些地址。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c2c8dc458853aef0f15a8.jpg\" alt=\"\"></p>\n<p>指令给出操作数地址方式</p>\n<ul>\n<li>显式：直接、间接、变址、基址</li>\n<li>隐式：隐含约定寄存器号、主存储器单元号</li>\n</ul>\n<h3 id=\"四地址指令\"><a href=\"#四地址指令\" class=\"headerlink\" title=\"四地址指令\"></a>四地址指令</h3><p><img src=\"https://pic.imgdb.cn/item/657c2e46c458853aef15aeaa.jpg\" alt=\"\"></p>\n<h3 id=\"三地址指令\"><a href=\"#三地址指令\" class=\"headerlink\" title=\"三地址指令\"></a>三地址指令</h3><p><img src=\"https://pic.imgdb.cn/item/657c2efec458853aef182e28.jpg\" alt=\"\"></p>\n<h3 id=\"二地址指令\"><a href=\"#二地址指令\" class=\"headerlink\" title=\"二地址指令\"></a>二地址指令</h3><p><img src=\"https://pic.imgdb.cn/item/657c2f1dc458853aef189bb6.jpg\" alt=\"\"></p>\n<h3 id=\"一地址指令\"><a href=\"#一地址指令\" class=\"headerlink\" title=\"一地址指令\"></a>一地址指令</h3><p><img src=\"https://pic.imgdb.cn/item/657c2f40c458853aef19181c.jpg\" alt=\"\"></p>\n<p>例：无符号乘法</p>\n<p>1）字节乘法：<code>OPRD × AL → AX</code></p>\n<p>如：<code>MUL DL  ;DL × AL → AX</code></p>\n<p>2）字乘法：<code>OPRD × AX → DX: AX</code></p>\n<p>如：<code>MUL BX  ;BX × AX → DX: AX</code></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>OPRD是源操作数，AL 是隐含的另一个源操作数，AX是隐含的目的操作数</p>\n<p>AX是一个十六寄存器，AL是它的低八位，AH是它的高八位</p>\n<p>MUL是无符号乘法指令，指令格式 MUL SRC</p>\n<p>如果SRC是字节操作数，则把AL中的无符号数与SRC相乘得到16位结果送AX中，即：AX←（AL)*(SRC)。如果SRC是字操作数，则把AX中的无符号数与SRC相乘得到32位结果送DX和AX中，DX存高16位，AX存低16位                                            </p></blockquote>\n<p><img src=\"https://pic.imgdb.cn/item/657c3008c458853aef1c931b.jpg\" alt=\"\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>NEG 被0减 相当于补码</p>\n<p>NOT 按位变反 相当于反码</p></blockquote>\n<h3 id=\"零地址指令\"><a href=\"#零地址指令\" class=\"headerlink\" title=\"零地址指令\"></a>零地址指令</h3><p><img src=\"https://pic.imgdb.cn/item/657c302ac458853aef1d1d3c.jpg\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/657c304cc458853aef1d9bb7.jpg\" alt=\"\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>FLAGS 标志寄存器：又称程序状态字（PSW）是一个16位的寄存器，存放条件标志、控制标志，主要用于反映处理器的状态和ALU运算结果的某些特征及控制指令的执行。</p>\n<p>pushf 将标志寄存器的值压栈，而 popf 是从栈中取出数据，存入标志寄存器</p>\n<p>取标志指令LAHF  功能：将标志寄存器低八位的内容送给AH</p>\n<p>设置标志指令SAHF功能：将AH的内容送给标志寄存器的低八位</p></blockquote>\n<p><img src=\"https://pic.imgdb.cn/item/657c3203c458853aef243639.jpg\" alt=\"\"></p>\n<h2 id=\"寻址方式\"><a href=\"#寻址方式\" class=\"headerlink\" title=\"==寻址方式==\"></a>==寻址方式==</h2><p><strong>按字编址</strong>：按字长编址，字长由计算机位数决定，比如32位就是1字=32bit</p>\n<p><strong>按字节编址</strong>：一个地址对应一个字节</p>\n<p>能被CPU直接使用的操作数位置：</p>\n<ul>\n<li>CPU内的R</li>\n<li>主存M（CACHE、接口中的R）</li>\n</ul>\n<p>① CPU能够直接访问的操作数只能存放在主存储器（包括CACHE、接口中的R）或CPU内的寄存器中；</p>\n<p>② 由于主存储器的容量远远大于CPU内的寄存器的容量，<strong>因此CPU能够直接访问的操作数主要存放在主存储器中</strong>。</p>\n<p>寻址方式可分为四大类，其它的寻址方式则是它们的变型或组合：</p>\n<ul>\n<li><p>立即寻址</p>\n<p>在读取指令时也就从指令之中获得了操作数，即<strong>操作数包含在指令中</strong>。</p>\n</li>\n<li><p>直接寻址</p>\n<p>直接给出<strong>主存地址或寄存器</strong>编号，<strong>从CPU内或主存单元内读取操作数</strong>。</p>\n</li>\n<li><p>间接寻址</p>\n<p>先从某寄存器中或主存中<strong>读取地址</strong>，再<strong>按这个地址访问主存</strong>以读取操作数。</p>\n</li>\n<li><p>变址类</p>\n<p>指令给出的是<strong>形式地址</strong>（不是最终地址），<strong>经过某种变换（例如相加、相减、高低位地址拼接等），才获得有效地址</strong>，据此访问主存储器以读取操作数。</p>\n</li>\n</ul>\n<h2 id=\"立即寻址\"><a href=\"#立即寻址\" class=\"headerlink\" title=\"立即寻址\"></a>立即寻址</h2><p>立即寻址是一种特殊的寻址方式。</p>\n<p>指令中在操作码字段后面的部分是操作数本身，也就是在<strong>取出指令的同时也就取出了可以立即使用的操作数</strong>。</p>\n<p>如<code>MOV AX, 1234H</code></p>\n<h3 id=\"直接寻址（绝对地址）\"><a href=\"#直接寻址（绝对地址）\" class=\"headerlink\" title=\"直接寻址（绝对地址）\"></a>直接寻址（绝对地址）</h3><p>由指令<strong>直接</strong>给出操作数地址，<strong>根据该地址可读取或写入操作数</strong>，这种方式称为直接寻址方式。</p>\n<h3 id=\"直接寻址（主存直接寻址）\"><a href=\"#直接寻址（主存直接寻址）\" class=\"headerlink\" title=\"直接寻址（主存直接寻址）\"></a>直接寻址（主存直接寻址）</h3><p>若指令中给出的地址码是主存的某个单元号，<strong>操作数存放在该指定的主存单元中</strong>，这种寻址方式称为直接寻址或主存直接寻址方式。</p>\n<p>假定主存储器是按字编址，一个操作数占一个主存单元，操作数为S，主存单元地址码为A；指令也是占一个字，其中包含操作码OP和地址码A。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c3b58c458853aef4ba81f.jpg\" alt=\"\"></p>\n<p>操作数S与地址码A的关系为：S=(A)</p>\n<h3 id=\"寄存器寻址（寄存器直接寻址）\"><a href=\"#寄存器寻址（寄存器直接寻址）\" class=\"headerlink\" title=\"寄存器寻址（寄存器直接寻址）\"></a>寄存器寻址（寄存器直接寻址）</h3><p>若指令中给出的地址码是寄存器编号，操作数存放在该指定的寄存器中,这种寻址方式称为寄存器寻址或寄存器直接寻址方式。</p>\n<p>在CPU中有若干寄存器，其中的一些是可编程访问的，称为可编址寄存器，设计时为它们分配不同的寄存器编号。指令中给出的寄存器号是Ri，从寄存器Ri中可直接读取操作数S。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c3d62c458853aef551161.jpg\" alt=\"\"></p>\n<p>操作数S与寄存器Ri的关系为：S=(Ri）</p>\n<h3 id=\"直接寻址与寄存器寻址方式的比较\"><a href=\"#直接寻址与寄存器寻址方式的比较\" class=\"headerlink\" title=\"直接寻址与寄存器寻址方式的比较\"></a>直接寻址与寄存器寻址方式的比较</h3><ul>\n<li><p>直接寻址是<strong>访问一次主存</strong>才能读取所需操作数</p>\n</li>\n<li><p>寄存器寻址是从<strong>CPU的寄存器中读取操作数</strong>，不需访问主存，所需时间大约是从主存中读数时间的几分之一到几十分之一，因而寄存器寻址比直接寻址快得多。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：减少指令中地址数目与减少一个地址的位数是两个不同的概念。</p>\n<p>采用<strong>隐地址</strong>可以减少指令中地址的数目；</p>\n<p>采用<strong>寄存器寻址方式、寄存器间址方式</strong>可以使指令中为给出一个地址所需的位数减少。</p>\n<p>其实，<strong>均减少了指令长度</strong>。</p></blockquote>\n</li>\n</ul>\n<h2 id=\"间接寻址\"><a href=\"#间接寻址\" class=\"headerlink\" title=\"间接寻址\"></a>间接寻址</h2><p>地址段提供的不一定就是操作数地址，如间接寻址方式。</p>\n<h3 id=\"主存间接寻址方式\"><a href=\"#主存间接寻址方式\" class=\"headerlink\" title=\"主存间接寻址方式\"></a>主存间接寻址方式</h3><ul>\n<li><p>若操作数存放在<strong>主存某个存储单元</strong>中，则该主存单元的地址被称为<strong>操作数地址</strong>。</p>\n</li>\n<li><p>若操作数地址存放在<strong>另一主存单元</strong>之中（<strong>不是由指令直接给出</strong>），则该主存单元被称为<strong>间址单元</strong>，间址单元本身的地址被称为<strong>操作数地址的地址</strong>。</p>\n</li>\n<li>若指令中地址给出的是<strong>间址单元地址</strong>（即操作数地址的地址，而不是操作数地址，且在主存），从中读取操作数地址，按照<strong>操作数地址再次访问主存，从相应单元中读写操作数</strong>，这种寻址方式称为<strong>间接寻址或主存间接寻址方式</strong>。</li>\n</ul>\n<p>指令中给出地址A1，据此访问间址单元，从中读取地址A2，按A2再访问一次主存，读取操作数S。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c417ec458853aef6a350d.jpg\" alt=\"\"></p>\n<p>操作数S与地址A1的关系为：S=((A1))=(A2)</p>\n<p>寻址过程为：间址单元地址$~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数地址$~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数</p>\n<h3 id=\"寄存器间接寻址方式\"><a href=\"#寄存器间接寻址方式\" class=\"headerlink\" title=\"寄存器间接寻址方式\"></a>寄存器间接寻址方式</h3><p>若指令中给出的地址码是<strong>寄存器编码</strong>，被指定的寄存器中存放的是操作数地址，按照该地址访问某主存单元，该单元的内容为操作数，这种寻址方式称为寄存器间接寻址。</p>\n<p>指令在地址段给出的是寄存器号Ri，从Ri中读出的是操作数地址A，按地址码A访问主存，从相应单元中读取操作数S。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c4472c458853aef7813ff.jpg\" alt=\"\"></p>\n<p>操作数S与地址A1的关系为：S=((Ri))</p>\n<p>寻址过程为：间址单元地址$~\\stackrel{\\text { M2 }}{\\longrightarrow}~$操作数地址$~\\stackrel{\\text { M2 }}{\\longrightarrow}~$操作数</p>\n<h2 id=\"间接寻址的变形\"><a href=\"#间接寻址的变形\" class=\"headerlink\" title=\"间接寻址的变形\"></a>间接寻址的变形</h2><h3 id=\"自减型寄存器间址方式\"><a href=\"#自减型寄存器间址方式\" class=\"headerlink\" title=\"自减型寄存器间址方式\"></a>自减型寄存器间址方式</h3><p>若指令中给出寄存器号，被指定的寄存器内容<strong>先减1</strong>后作为操作数地址，按照该地址访问主存储器，相应的主存单元内容为操作数，自减型寄存器间址方式常用助记符<code>-(R)</code>表示。 </p>\n<p>指令在地址段给出的是寄存器号Ri，将Ri中的内容减1作为操作数地址A，按地址码A访问主存，从相应单元中读取操作数S。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c48aec458853aef8b7bb0.jpg\" alt=\"\"></p>\n<p>寄存器号$~\\stackrel{\\text { Ri }}{\\longrightarrow}~$操作数地址= (Ri) - 1$~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数</p>\n<p>操作数S与寄存器Ri的关系为：<code>S=((Ri-1))</code></p>\n<p>通过重复执行这同一条指令，就可以访问从(Ri-1)开始沿地址码减小方向的一个连续数据区。</p>\n<h3 id=\"堆栈寻址\"><a href=\"#堆栈寻址\" class=\"headerlink\" title=\"堆栈寻址\"></a>堆栈寻址</h3><p>堆栈寻址方式是指<strong>操作数在堆栈中</strong>，指令隐含约定<strong>由堆栈指针SP寄存器提供栈顶单元地址</strong>（SP也可以编码形式出现在指令中），进行读出或写入的一种寻址方式。 </p>\n<p>根据压入数据时栈顶单元的地址是减小还是增大或不变，可以将堆栈的工作方式大致分为<strong>向上生成方式（SP+1）、向下生成方式（SP-1）和栈顶固定方式</strong>三种。</p>\n<p>指令在地址段给出的是<strong>寄存器号SP</strong>，对SP中的内容进行相应操作（<strong>减1或不变，对应压栈或出栈</strong>），得到操作数地址A，按地址码A访问主存，从相应单元中访问操作数S。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c4da4c458853aefa2b7a6.jpg\" alt=\"\"></p>\n<ul>\n<li><p>压栈：寄存器号$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数地址 = (SP) - 1 $~\\stackrel{\\text { M }}{\\longrightarrow}~$操作数</p>\n<p>操作数与寄存器SP的关系为：<code>S = ((SP - 1))</code></p>\n</li>\n<li><p>出栈：寄存器号$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数地址$~\\stackrel{\\text { SP }}{\\longrightarrow}~$操作数</p>\n<p>操作数与寄存器SP的关系为：<code>S = ((SP))</code>，弹出后修改堆栈指针：(SP) + 1 $\\rightarrow$ SP</p>\n</li>\n</ul>\n<h3 id=\"多重间接寻址（主存多重间接寻址）\"><a href=\"#多重间接寻址（主存多重间接寻址）\" class=\"headerlink\" title=\"多重间接寻址（主存多重间接寻址）\"></a>多重间接寻址（主存多重间接寻址）</h3><p>根据指令找到间址单元，其中的内容还不是操作数地址，而是又一层间址单元的地址；根据该地址访问又一层间址单元，取出来的才是操作数地址（存放操作数的存储单元的地址码），可在间址单元的存储内容中设置一位<strong>间址标志位</strong>，一般选取最高位，当该位为1时，表明所读出的是间接地址,还需再次间址；直到该位为0,表明这次取出的是操作数的有效地址，按这个地址访问主存，读出的是操作数(即间址过程结束)。</p>\n<ul>\n<li><p>寄存器多重间址</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c5271c458853aefbccfb3.jpg\" alt=\"\"></p>\n<p>寄存器号$~\\stackrel{\\text { R }}{\\longrightarrow}~$一级间址$~\\stackrel{\\text { M }}{\\longrightarrow}~\\cdots \\stackrel{\\text { M }}{\\longrightarrow}$操作数</p>\n</li>\n<li><p>存储器多重间址</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c52f8c458853aefc00741.jpg\" alt=\"\"></p>\n<p>寄存器号$~\\stackrel{\\text { M }}{\\longrightarrow}~$一级间址$~\\stackrel{\\text { M }}{\\longrightarrow}~\\cdots \\stackrel{\\text { M }}{\\longrightarrow}~$操作数</p>\n</li>\n</ul>\n<h2 id=\"变址寻址\"><a href=\"#变址寻址\" class=\"headerlink\" title=\"变址寻址\"></a>变址寻址</h2><p>若指令中给出变址寄存器号和一个形式地址，<strong>变址寄存器的内容(称为变址量)与形式地址相加</strong>，得到操作数有效地址(即操作数实际地址)，按照有效地址访问某主存单元,该单元的内容即为操作数，这种寻址方式称为变址寻址方式。变址方式常用助记符<strong>X（R）</strong>表示。</p>\n<p>指令中为获得某个操作数地址给出两个信息：</p>\n<p>形式地址D，变址寄存器Rx。有效地址<strong>A= D+(Rx)= D+N</strong>，根据A访问主存储器，读写操作数S。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c5590c458853aefcfc999.jpg\" alt=\"\"></p>\n<p>例如：</p>\n<p><code>MOV AX, 10H[BX]  ;</code></p>\n<p>​    等价于<code>MOV AX, DS: 10H[BX]</code></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>其中 <code>DS</code> 是数据段寄存器，而 <code>10H[BX]</code> 依然表示偏移量和基地址。数据从内存地址 <code>DS * 16 + BX + 10H</code> 处加载到寄存器AX中。</p></blockquote>\n<p><code>MOV AL, 20H[SI]   ;</code></p>\n<p>   <code>等价于MOV AL, DS: 20H[SI]</code></p>\n<h2 id=\"基址寻址\"><a href=\"#基址寻址\" class=\"headerlink\" title=\"基址寻址\"></a>基址寻址</h2><p>若指令中给出<strong>基址寄存器号和一个形式地址</strong>，<strong>基址寄存器内容（作为基准地址）与形式地址（作为位移量）相加</strong>，其和为操作数有效地址(即操作数实际地址)，按照该地址访问主存储器，该单元的内容即为操作数，这种寻址方式称为基址寻址。</p>\n<p>指令中为获得某个操作数地址给出了两个信息：</p>\n<p>形式地址D，基址寄存器RB。有效地址<strong>A= D+(RB)= D+N</strong>，根据A访问主存储器，读写操作数S。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c582cc458853aefde0c94.jpg\" alt=\"\"></p>\n<h3 id=\"基址-amp-变址比较\"><a href=\"#基址-amp-变址比较\" class=\"headerlink\" title=\"基址&amp;变址比较\"></a>基址&amp;变址比较</h3><p><img src=\"https://pic.imgdb.cn/item/657c5878c458853aefdfae74.jpg\" alt=\"\"></p>\n<p>基址寻址方式的目的是扩大有限字长指令的寻址空间,变址寻址方式的目的是为了灵活修改地址以适应连续区间(程序循环)的操作。</p>\n<p>如果在同一条指令中要兼有这两种功能，可以采取复合型的寻址方式，即<strong>基址加变址方式</strong>。</p>\n<h2 id=\"变址-amp-基址寻址变化\"><a href=\"#变址-amp-基址寻址变化\" class=\"headerlink\" title=\"变址&amp;基址寻址变化\"></a>变址&amp;基址寻址变化</h2><h3 id=\"相对寻址X-PC\"><a href=\"#相对寻址X-PC\" class=\"headerlink\" title=\"相对寻址X(PC)\"></a>相对寻址<code>X(PC)</code></h3><p>若指令中<strong>选定程序计数器PC作为变址寄存器</strong>，或是隐含地指定PC，<strong>指令中给出的形式地址作为位移量</strong>（可正、可负），二者相加后形成操作数的有效地址。这种寻址方式实际上就是<strong>以当前指令位置为基准</strong>，相对它进行位移定位（往前或往后），所以称为相对寻址。</p>\n<p>程序计数器PC的内容为<strong>现行指令地址A</strong>，按地址A从主存中读取指令;</p>\n<p><strong>指令中形式地址段给出位移量d</strong>，它是从现行指令位置到操作数S所在单元之间的距离（单元数）;</p>\n<p>操作数有效地址<strong>D=A+d</strong>，据此访问主存储器，从D单元中读取操作数。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c5a5cc458853aefe9cf59.jpg\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/657c5aadc458853aefeb64bb.jpg\" alt=\"\"></p>\n<h3 id=\"页面寻址\"><a href=\"#页面寻址\" class=\"headerlink\" title=\"页面寻址\"></a>页面寻址</h3><p>将PC内容的高位段与位移量相拼接,相对寻址就演变成页面寻址。</p>\n<p>程序计数器PC的内容为A，指令中形式地址段给出位移量d。</p>\n<p>按页面寻址方式，操作数有效地址 = $(PC)_H，d $；</p>\n<p>据此访问主存储器，从单元中读取操作数。</p>\n<p><img src=\"https://pic.imgdb.cn/item/657c5c41c458853aeff3f523.jpg\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/657c5c7dc458853aeff537f1.jpg\" alt=\"\"></p>\n<p>以上四类十余种寻址方式,重点在“数在哪里”(在指令中、在CPU寄存器中、在主存中)。</p>\n<p>① 如果操作数在主存中，指令直接给出有效地址还是通过“多次读取”间接获得有效地址(通过寄存器间址、通过存储单元间址)?</p>\n<p>② 如何通过计算使地址量可变 (与变址寄存器内容加、与基址寄存器内容加、与程序计数器内容加或拼接)?</p>\n<h2 id=\"指令类型\"><a href=\"#指令类型\" class=\"headerlink\" title=\"指令类型\"></a>指令类型</h2><p>自己看看得了</p>\n","text":"计算机中的信息表示一、基本概念及应用（注明：应用是指基本概念的应用） 一个数值型数据的完整表示需三个方面？ 权、基数？ 真值？机器数的定义？分类？ 数的定点表示...","permalink":"/post/计组复习-1","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","count":10,"path":"api/tags/计算机组成原理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">计算机中的信息表示</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%80%BC%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">进位计数值及其相互转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E8%BF%9B%E5%88%B6\"><span class=\"toc-text\">十进制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6\"><span class=\"toc-text\">二进制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">带符号数的表示</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%A0%81\"><span class=\"toc-text\">原码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E7%A0%81\"><span class=\"toc-text\">反码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E7%A0%81\"><span class=\"toc-text\">补码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">补码加减运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">溢出</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E7%82%B9%E6%95%B0\"><span class=\"toc-text\">定点数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%AE%E7%82%B9%E6%95%B0\"><span class=\"toc-text\">浮点数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9C%9F%E5%80%BC\"><span class=\"toc-text\">真值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%9C%BA%E5%99%A8%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">浮点数的机器格式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E7%A0%81\"><span class=\"toc-text\">移码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IEEE754%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%8C%E5%BF%85%E8%80%83%EF%BC%89\"><span class=\"toc-text\">IEEE754（非常重要，必考）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">例题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#IEEE754%E8%BD%AC%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9C%9F%E5%80%BC\"><span class=\"toc-text\">IEEE754转为十进制真值</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4-amp-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">指令&amp;指令系统</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">指令基本格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%A0%81\"><span class=\"toc-text\">操作码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81\"><span class=\"toc-text\">扩展操作码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">地址结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">四地址指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">三地址指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">二地址指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">一地址指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">零地址指令</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">&#x3D;&#x3D;寻址方式&#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80\"><span class=\"toc-text\">立即寻址</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%88%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%EF%BC%89\"><span class=\"toc-text\">直接寻址（绝对地址）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%88%E4%B8%BB%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%89\"><span class=\"toc-text\">直接寻址（主存直接寻址）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%89\"><span class=\"toc-text\">寄存器寻址（寄存器直接寻址）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">直接寻址与寄存器寻址方式的比较</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80\"><span class=\"toc-text\">间接寻址</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E5%AD%98%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">主存间接寻址方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">寄存器间接寻址方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E7%9A%84%E5%8F%98%E5%BD%A2\"><span class=\"toc-text\">间接寻址的变形</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%87%8F%E5%9E%8B%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E5%9D%80%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">自减型寄存器间址方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80\"><span class=\"toc-text\">堆栈寻址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%88%E4%B8%BB%E5%AD%98%E5%A4%9A%E9%87%8D%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%89\"><span class=\"toc-text\">多重间接寻址（主存多重间接寻址）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80\"><span class=\"toc-text\">变址寻址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80\"><span class=\"toc-text\">基址寻址</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E5%9D%80-amp-%E5%8F%98%E5%9D%80%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">基址&amp;变址比较</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E5%9D%80-amp-%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">变址&amp;基址寻址变化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80X-PC\"><span class=\"toc-text\">相对寻址X(PC)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E5%AF%BB%E5%9D%80\"><span class=\"toc-text\">页面寻址</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">指令类型</span></a></li></ol></li></ol>","author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"这里是破酥的个人博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"计组复习-2","uid":"d791938eaa4548a75cb2973241af39d9","slug":"计组复习-2","date":"2023-12-15T08:06:14.000Z","updated":"2023-12-24T01:24:05.330Z","comments":true,"path":"api/articles/计组复习-2.json","keywords":null,"cover":[],"text":"第三章 中央处理器一、基本概念及应用（注明：应用是指基本概念的应用） 1.CPU内部各寄存器的功能？ 2.数据通路结构？ 3.何谓同步控制方式，何谓异步控制？有...","permalink":"/post/计组复习-2","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","count":10,"path":"api/tags/计算机组成原理.json"}],"author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"这里是破酥的个人博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"DMA方式","uid":"add768c24e8f1c57682e3d07a8cf025b","slug":"DMA方式","date":"2023-12-12T07:14:56.000Z","updated":"2023-12-12T08:01:38.003Z","comments":true,"path":"api/articles/DMA方式.json","keywords":null,"cover":[],"text":"DMA方式及接口定义 DMA，即直接存储器访问（Direct Memory Access），它指这样一种传送控制方式：依靠硬件直接在主存与外围设备之间进行数据传...","permalink":"/post/DMA方式","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","count":10,"path":"api/tags/计算机组成原理.json"}],"author":{"name":"C4IN","slug":"blog-author","avatar":"/pic/au.jpg","link":"/","description":"这里是破酥的个人博客","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}